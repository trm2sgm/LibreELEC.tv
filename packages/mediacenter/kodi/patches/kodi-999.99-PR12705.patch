From 014fef086797708c81a87fa97f78532331793359 Mon Sep 17 00:00:00 2001
From: Arpit Nandwani <arpit.nandwani@gmail.com>
Date: Tue, 6 Jun 2017 21:37:55 +0530
Subject: [PATCH 01/25] Added Python3 Templates

* Updated all the files from old function names to new function names as
  given in pydocs - http://py3c.readthedocs.io/en/latest/reference.html
* changed char to wchar_t
* File pointer (FILE *) updated
* Updated ob_type to be called by multi layered PyObject
* Removed tp_compare since it's depreciated
* Updated definitions for InitModule
* Updated the Python3 Android Script
---
 cmake/treedata/optional/common/python.txt          |   1 +
 xbmc/interfaces/python3/AddonPythonInvoker.cpp     | 127 +++
 xbmc/interfaces/python3/AddonPythonInvoker.h       |  34 +
 xbmc/interfaces/python3/CMakeLists.txt             |  21 +
 xbmc/interfaces/python3/CallbackHandler.cpp        |  76 ++
 xbmc/interfaces/python3/CallbackHandler.h          |  50 ++
 .../interfaces/python3/ContextItemAddonInvoker.cpp |  53 ++
 xbmc/interfaces/python3/ContextItemAddonInvoker.h  |  40 +
 xbmc/interfaces/python3/LanguageHook.cpp           | 210 +++++
 xbmc/interfaces/python3/LanguageHook.h             | 101 +++
 xbmc/interfaces/python3/MethodType.groovy          |  26 +
 xbmc/interfaces/python3/PyContext.cpp              | 129 +++
 xbmc/interfaces/python3/PyContext.h                |  58 ++
 xbmc/interfaces/python3/PythonInvoker.cpp          | 687 +++++++++++++++
 xbmc/interfaces/python3/PythonInvoker.h            |  77 ++
 xbmc/interfaces/python3/PythonSwig.cpp.template    | 958 +++++++++++++++++++++
 xbmc/interfaces/python3/PythonTools.groovy         | 152 ++++
 xbmc/interfaces/python3/XBPython.cpp               | 704 +++++++++++++++
 xbmc/interfaces/python3/XBPython.h                 | 137 +++
 xbmc/interfaces/python3/preamble.h                 |  27 +
 xbmc/interfaces/python3/pythreadstate.h            |  73 ++
 xbmc/interfaces/python3/swig.cpp                   | 385 +++++++++
 xbmc/interfaces/python3/swig.h                     | 211 +++++
 xbmc/interfaces/python3/test/CMakeLists.txt        |   5 +
 xbmc/interfaces/python3/test/TestSwig.cpp          |  33 +
 .../python3/typemaps/python.Alternative.intm       |  55 ++
 .../python3/typemaps/python.Alternative.outtm      |  46 +
 xbmc/interfaces/python3/typemaps/python.Tuple.intm |  47 +
 .../interfaces/python3/typemaps/python.Tuple.outtm |  51 ++
 .../interfaces/python3/typemaps/python.buffer.intm |  38 +
 .../python3/typemaps/python.buffer.outtm           |  23 +
 xbmc/interfaces/python3/typemaps/python.dict.intm  |  35 +
 xbmc/interfaces/python3/typemaps/python.map.intm   |  36 +
 .../python3/typemaps/python.smart_ptr.outtm        |  26 +
 .../python3/typemaps/python.string.outtm           |  23 +
 .../interfaces/python3/typemaps/python.vector.intm |  47 +
 .../python3/typemaps/python.vector.outtm           |  48 ++
 .../httprequesthandler/python3/CMakeLists.txt      |  10 +
 .../python3/HTTPPythonInvoker.cpp                  |  84 ++
 .../httprequesthandler/python3/HTTPPythonInvoker.h |  44 +
 .../httprequesthandler/python3/HTTPPythonRequest.h |  54 ++
 .../python3/HTTPPythonWsgiInvoker.cpp              | 453 ++++++++++
 .../python3/HTTPPythonWsgiInvoker.h                |  58 ++
 43 files changed, 5553 insertions(+)
 create mode 100644 xbmc/interfaces/python3/AddonPythonInvoker.cpp
 create mode 100644 xbmc/interfaces/python3/AddonPythonInvoker.h
 create mode 100644 xbmc/interfaces/python3/CMakeLists.txt
 create mode 100644 xbmc/interfaces/python3/CallbackHandler.cpp
 create mode 100644 xbmc/interfaces/python3/CallbackHandler.h
 create mode 100644 xbmc/interfaces/python3/ContextItemAddonInvoker.cpp
 create mode 100644 xbmc/interfaces/python3/ContextItemAddonInvoker.h
 create mode 100644 xbmc/interfaces/python3/LanguageHook.cpp
 create mode 100644 xbmc/interfaces/python3/LanguageHook.h
 create mode 100644 xbmc/interfaces/python3/MethodType.groovy
 create mode 100644 xbmc/interfaces/python3/PyContext.cpp
 create mode 100644 xbmc/interfaces/python3/PyContext.h
 create mode 100644 xbmc/interfaces/python3/PythonInvoker.cpp
 create mode 100644 xbmc/interfaces/python3/PythonInvoker.h
 create mode 100644 xbmc/interfaces/python3/PythonSwig.cpp.template
 create mode 100644 xbmc/interfaces/python3/PythonTools.groovy
 create mode 100644 xbmc/interfaces/python3/XBPython.cpp
 create mode 100644 xbmc/interfaces/python3/XBPython.h
 create mode 100644 xbmc/interfaces/python3/preamble.h
 create mode 100644 xbmc/interfaces/python3/pythreadstate.h
 create mode 100644 xbmc/interfaces/python3/swig.cpp
 create mode 100644 xbmc/interfaces/python3/swig.h
 create mode 100644 xbmc/interfaces/python3/test/CMakeLists.txt
 create mode 100644 xbmc/interfaces/python3/test/TestSwig.cpp
 create mode 100644 xbmc/interfaces/python3/typemaps/python.Alternative.intm
 create mode 100644 xbmc/interfaces/python3/typemaps/python.Alternative.outtm
 create mode 100644 xbmc/interfaces/python3/typemaps/python.Tuple.intm
 create mode 100644 xbmc/interfaces/python3/typemaps/python.Tuple.outtm
 create mode 100644 xbmc/interfaces/python3/typemaps/python.buffer.intm
 create mode 100644 xbmc/interfaces/python3/typemaps/python.buffer.outtm
 create mode 100644 xbmc/interfaces/python3/typemaps/python.dict.intm
 create mode 100644 xbmc/interfaces/python3/typemaps/python.map.intm
 create mode 100644 xbmc/interfaces/python3/typemaps/python.smart_ptr.outtm
 create mode 100644 xbmc/interfaces/python3/typemaps/python.string.outtm
 create mode 100644 xbmc/interfaces/python3/typemaps/python.vector.intm
 create mode 100644 xbmc/interfaces/python3/typemaps/python.vector.outtm
 create mode 100644 xbmc/network/httprequesthandler/python3/CMakeLists.txt
 create mode 100644 xbmc/network/httprequesthandler/python3/HTTPPythonInvoker.cpp
 create mode 100644 xbmc/network/httprequesthandler/python3/HTTPPythonInvoker.h
 create mode 100644 xbmc/network/httprequesthandler/python3/HTTPPythonRequest.h
 create mode 100644 xbmc/network/httprequesthandler/python3/HTTPPythonWsgiInvoker.cpp
 create mode 100644 xbmc/network/httprequesthandler/python3/HTTPPythonWsgiInvoker.h

diff --git a/cmake/treedata/optional/common/python.txt b/cmake/treedata/optional/common/python.txt
index 49604855c82c..554c994719da 100644
--- a/cmake/treedata/optional/common/python.txt
+++ b/cmake/treedata/optional/common/python.txt
@@ -1,4 +1,5 @@
 xbmc/interfaces/legacy interfaces/legacy # PYTHON
 xbmc/interfaces/legacy/wsgi interfaces/legacy/wsgi # PYTHON
 xbmc/interfaces/python interfaces/python # PYTHON
+xbmc/interfaces/python3 interfaces/python3 # PYTHON
 xbmc/interfaces/swig build/swig # PYTHON
diff --git a/xbmc/interfaces/python3/AddonPythonInvoker.cpp b/xbmc/interfaces/python3/AddonPythonInvoker.cpp
new file mode 100644
index 000000000000..92110a92b1cc
--- /dev/null
+++ b/xbmc/interfaces/python3/AddonPythonInvoker.cpp
@@ -0,0 +1,127 @@
+/*
+ *      Copyright (C) 2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+// python.h should always be included first before any other includes
+#include <Python.h>
+#include <osdefs.h>
+
+#include "system.h"
+#include "AddonPythonInvoker.h"
+
+#include <utility>
+
+#define MODULE "xbmc"
+
+#define RUNSCRIPT_PREAMBLE \
+        "" \
+        "import " MODULE "\n" \
+        "xbmc.abortRequested = False\n" \
+        "class xbmcout:\n" \
+        "  def __init__(self, loglevel=" MODULE ".LOGDEBUG):\n" \
+        "    self.ll=loglevel\n" \
+        "  def write(self, data):\n" \
+        "    " MODULE ".log(data,self.ll)\n" \
+        "  def close(self):\n" \
+        "    " MODULE ".log('.')\n" \
+        "  def flush(self):\n" \
+        "    " MODULE ".log('.')\n" \
+        "import sys\n" \
+        "sys.stdout = xbmcout()\n" \
+        "sys.stderr = xbmcout(" MODULE ".LOGERROR)\n" \
+        ""
+
+#define RUNSCRIPT_SETUPTOOLS_HACK \
+  "" \
+  "import types,sys\n" \
+  "pkg_resources_code = \\\n" \
+  "\"\"\"\n" \
+  "def resource_filename(__name__,__path__):\n" \
+  "  return __path__\n" \
+  "\"\"\"\n" \
+  "pkg_resources = types.ModuleType('pkg_resources')\n" \
+  "exec(pkg_resources_code, pkg_resources.__dict__)\n" \
+  "sys.modules['pkg_resources'] = pkg_resources\n" \
+  ""
+
+#define RUNSCRIPT_POSTSCRIPT \
+        "print ('-->Python Interpreter Initialized<--')\n" \
+        ""
+
+#if defined(TARGET_ANDROID)
+
+#define RUNSCRIPT_COMPLIANT \
+  RUNSCRIPT_PREAMBLE RUNSCRIPT_SETUPTOOLS_HACK RUNSCRIPT_POSTSCRIPT
+
+#else
+
+#define RUNSCRIPT_COMPLIANT \
+  RUNSCRIPT_PREAMBLE RUNSCRIPT_POSTSCRIPT
+
+#endif
+
+namespace PythonBindings {
+  void initModule_xbmcgui(void);
+  void initModule_xbmc(void);
+  void initModule_xbmcplugin(void);
+  void initModule_xbmcaddon(void);
+  void initModule_xbmcvfs(void);
+}
+
+using namespace PythonBindings;
+
+typedef struct
+{
+  const char *name;
+  CPythonInvoker::PythonModuleInitialization initialization;
+} PythonModule;
+
+static PythonModule PythonModules[] =
+  {
+    { "xbmcgui",    initModule_xbmcgui    },
+    { "xbmc",       initModule_xbmc       },
+    { "xbmcplugin", initModule_xbmcplugin },
+    { "xbmcaddon",  initModule_xbmcaddon  },
+    { "xbmcvfs",    initModule_xbmcvfs    }
+  };
+
+#define PythonModulesSize sizeof(PythonModules) / sizeof(PythonModule)
+
+CAddonPythonInvoker::CAddonPythonInvoker(ILanguageInvocationHandler *invocationHandler)
+  : CPythonInvoker(invocationHandler)
+{ }
+
+CAddonPythonInvoker::~CAddonPythonInvoker() = default;
+
+std::map<std::string, CPythonInvoker::PythonModuleInitialization> CAddonPythonInvoker::getModules() const
+{
+  static std::map<std::string, PythonModuleInitialization> modules;
+  if (modules.empty())
+  {
+    for (size_t i = 0; i < PythonModulesSize; i++)
+      modules.insert(std::make_pair(PythonModules[i].name, PythonModules[i].initialization));
+  }
+
+  return modules;
+}
+
+const char* CAddonPythonInvoker::getInitializationScript() const
+{
+  return RUNSCRIPT_COMPLIANT;
+}
diff --git a/xbmc/interfaces/python3/AddonPythonInvoker.h b/xbmc/interfaces/python3/AddonPythonInvoker.h
new file mode 100644
index 000000000000..1bc10183f199
--- /dev/null
+++ b/xbmc/interfaces/python3/AddonPythonInvoker.h
@@ -0,0 +1,34 @@
+#pragma once
+/*
+ *      Copyright (C) 2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "interfaces/python/PythonInvoker.h"
+
+class CAddonPythonInvoker : public CPythonInvoker
+{
+public:
+  explicit CAddonPythonInvoker(ILanguageInvocationHandler *invocationHandler);
+  ~CAddonPythonInvoker() override;
+
+protected:
+  // overrides of CPythonInvoker
+  std::map<std::string, PythonModuleInitialization> getModules() const override;
+  const char* getInitializationScript() const override;
+};
diff --git a/xbmc/interfaces/python3/CMakeLists.txt b/xbmc/interfaces/python3/CMakeLists.txt
new file mode 100644
index 000000000000..061cc2b77f86
--- /dev/null
+++ b/xbmc/interfaces/python3/CMakeLists.txt
@@ -0,0 +1,21 @@
+set(SOURCES AddonPythonInvoker.cpp
+            CallbackHandler.cpp
+            ContextItemAddonInvoker.cpp
+            LanguageHook.cpp
+            PythonInvoker.cpp
+            XBPython.cpp
+            swig.cpp
+            PyContext.cpp)
+
+set(HEADERS AddonPythonInvoker.h
+            CallbackHandler.h
+            ContextItemAddonInvoker.h
+            LanguageHook.h
+            preamble.h
+            PyContext.h
+            PythonInvoker.h
+            pythreadstate.h
+            swig.h
+            XBPython.h)
+
+core_add_library(python_interface)
diff --git a/xbmc/interfaces/python3/CallbackHandler.cpp b/xbmc/interfaces/python3/CallbackHandler.cpp
new file mode 100644
index 000000000000..e0cf64b40163
--- /dev/null
+++ b/xbmc/interfaces/python3/CallbackHandler.cpp
@@ -0,0 +1,76 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "CallbackHandler.h"
+#include "LanguageHook.h"
+
+namespace XBMCAddon
+{
+  namespace Python
+  {
+    /**
+     * We are ASS-U-MEing that this construction is happening
+     *  within the context of a Python call. This way we can
+     *  store off the PyThreadState to later verify that we're
+     *  handling callbacks in the appropriate thread.
+     */
+    PythonCallbackHandler::PythonCallbackHandler()
+    {
+      XBMC_TRACE;
+      objectThreadState = PyThreadState_Get();
+    }
+
+    /**
+     * Now we are answering the question as to whether or not we are in the
+     *  PyThreadState that we were in when we started.
+     */
+    bool PythonCallbackHandler::isStateOk(AddonClass* obj)
+    {
+      XBMC_TRACE;
+      PyThreadState* state = PyThreadState_Get();
+      if (objectThreadState == state)
+      {
+        // make sure the interpreter is still active.
+        AddonClass::Ref<XBMCAddon::Python::PythonLanguageHook> lh(XBMCAddon::Python::PythonLanguageHook::GetIfExists(state->interp));
+        if (lh.isNotNull() && lh->HasRegisteredAddonClassInstance(obj) && lh.get() == obj->GetLanguageHook())
+          return true;
+      }
+      return false;
+    }
+
+    /**
+     * For this method we expect the PyThreadState to be passed as the user
+     *  data for the check.
+     *
+     * @todo This is a stupid way to get this information back to the handler.
+     *  there should be a more language neutral means.
+     */
+    bool PythonCallbackHandler::shouldRemoveCallback(AddonClass* obj, void* threadState)
+    {
+      XBMC_TRACE;
+      if (threadState == objectThreadState)
+        return true;
+
+      // we also want to remove the callback if the language hook no longer exists.
+      //   this is a belt-and-suspenders cleanup mechanism
+      return ! XBMCAddon::Python::PythonLanguageHook::IsAddonClassInstanceRegistered(obj);
+    }
+  }
+}
diff --git a/xbmc/interfaces/python3/CallbackHandler.h b/xbmc/interfaces/python3/CallbackHandler.h
new file mode 100644
index 000000000000..5934d9005d92
--- /dev/null
+++ b/xbmc/interfaces/python3/CallbackHandler.h
@@ -0,0 +1,50 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <Python.h>
+
+#include "interfaces/legacy/CallbackHandler.h"
+
+namespace XBMCAddon
+{
+  namespace Python
+  {
+    /**
+     * This class represents a specialization of the callback handler
+     *  that specifically checks to see if we're in an OK thread state
+     *  based on Python specifics.
+     */
+    class PythonCallbackHandler : public RetardedAsyncCallbackHandler
+    {
+      PyThreadState* objectThreadState;
+    public:
+
+      /**
+       * We are ASS-U-MEing that this construction is happening
+       *  within the context of a Python call. This way we can
+       *  store off the PyThreadState to later verify that we're
+       *  handling callbacks in the appropriate thread.
+       */
+      PythonCallbackHandler();
+      bool isStateOk(AddonClass* obj) override;
+      bool shouldRemoveCallback(AddonClass* obj, void* threadState) override;
+    };
+  }
+}
diff --git a/xbmc/interfaces/python3/ContextItemAddonInvoker.cpp b/xbmc/interfaces/python3/ContextItemAddonInvoker.cpp
new file mode 100644
index 000000000000..d7987c63d7b9
--- /dev/null
+++ b/xbmc/interfaces/python3/ContextItemAddonInvoker.cpp
@@ -0,0 +1,53 @@
+/*
+ *      Copyright (C) 2015 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+// python.h should always be included first before any other includes
+#include <Python.h>
+#include <osdefs.h>
+
+#include "system.h"
+#include "ContextItemAddonInvoker.h"
+#include "utils/log.h"
+#include "interfaces/python/swig.h"
+
+
+CContextItemAddonInvoker::CContextItemAddonInvoker(
+    ILanguageInvocationHandler *invocationHandler,
+    const CFileItemPtr& item)
+  : CAddonPythonInvoker(invocationHandler), m_item(CFileItemPtr(new CFileItem(*item.get())))
+{
+}
+
+CContextItemAddonInvoker::~CContextItemAddonInvoker() = default;
+
+void CContextItemAddonInvoker::onPythonModuleInitialization(void* moduleDict)
+{
+  CAddonPythonInvoker::onPythonModuleInitialization(moduleDict);
+  if (m_item)
+  {
+    XBMCAddon::xbmcgui::ListItem* arg = new XBMCAddon::xbmcgui::ListItem(m_item);
+    PyObject* pyItem = PythonBindings::makePythonInstance(arg, true);
+    if (pyItem == Py_None || PySys_SetObject((char*)"listitem", pyItem) == -1)
+    {
+      CLog::Log(LOGERROR, "CPythonInvoker(%d, %s): Failed to set sys parameter", GetId(), m_sourceFile.c_str());
+      //FIXME: we should really abort execution
+    }
+  }
+}
diff --git a/xbmc/interfaces/python3/ContextItemAddonInvoker.h b/xbmc/interfaces/python3/ContextItemAddonInvoker.h
new file mode 100644
index 000000000000..312353f2e63f
--- /dev/null
+++ b/xbmc/interfaces/python3/ContextItemAddonInvoker.h
@@ -0,0 +1,40 @@
+#pragma once
+/*
+ *      Copyright (C) 2015 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <memory>
+#include "interfaces/python/AddonPythonInvoker.h"
+
+class CFileItem;
+typedef std::shared_ptr<CFileItem> CFileItemPtr;
+
+class CContextItemAddonInvoker : public CAddonPythonInvoker
+{
+public:
+  explicit CContextItemAddonInvoker(ILanguageInvocationHandler *invocationHandler,
+                                    const CFileItemPtr& item);
+  ~CContextItemAddonInvoker() override;
+
+protected:
+  void onPythonModuleInitialization(void* moduleDict) override;
+
+private:
+  const CFileItemPtr m_item;
+};
diff --git a/xbmc/interfaces/python3/LanguageHook.cpp b/xbmc/interfaces/python3/LanguageHook.cpp
new file mode 100644
index 000000000000..32219fd3379c
--- /dev/null
+++ b/xbmc/interfaces/python3/LanguageHook.cpp
@@ -0,0 +1,210 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+
+#include "LanguageHook.h"
+#include "CallbackHandler.h"
+#include "XBPython.h"
+
+#include "interfaces/legacy/AddonUtils.h"
+#include "PyContext.h"
+
+namespace XBMCAddon
+{
+  namespace Python
+  {
+    static AddonClass::Ref<PythonLanguageHook> instance;
+
+    static CCriticalSection hooksMutex;
+    static std::map<PyInterpreterState*,AddonClass::Ref<PythonLanguageHook> > hooks;
+
+    // vtab instantiation
+    PythonLanguageHook::~PythonLanguageHook()
+    {
+      XBMC_TRACE;
+      XBMCAddon::LanguageHook::deallocating();
+    }
+
+    void PythonLanguageHook::MakePendingCalls()
+    {
+      XBMC_TRACE;
+      PythonCallbackHandler::makePendingCalls();
+    }
+
+    void PythonLanguageHook::DelayedCallOpen()
+    {
+      XBMC_TRACE;
+      PyGILLock::releaseGil();
+    }
+
+    void PythonLanguageHook::DelayedCallClose()
+    {
+      XBMC_TRACE;
+      PyGILLock::acquireGil();
+    }
+
+    void PythonLanguageHook::RegisterMe()
+    {
+      XBMC_TRACE;
+      CSingleLock lock(hooksMutex);
+      hooks[m_interp] = AddonClass::Ref<PythonLanguageHook>(this);
+    }
+
+    void PythonLanguageHook::UnregisterMe()
+    {
+      XBMC_TRACE;
+      CSingleLock lock(hooksMutex);
+      hooks.erase(m_interp);
+    }
+
+    static AddonClass::Ref<XBMCAddon::Python::PythonLanguageHook> g_languageHook;
+
+    // Ok ... we're going to get it even if it doesn't exist. If it doesn't exist then
+    // we're going to assume we're not in control of the interpreter. This (apparently)
+    // can be the case. E.g. Libspotify manages to call into a script using a ctypes
+    // extension but under the control of an Interpreter we know nothing about. In
+    // cases like this we're going to use a global interpreter
+    AddonClass::Ref<PythonLanguageHook> PythonLanguageHook::GetIfExists(PyInterpreterState* interp)
+    {
+      XBMC_TRACE;
+      CSingleLock lock(hooksMutex);
+      std::map<PyInterpreterState*,AddonClass::Ref<PythonLanguageHook> >::iterator iter = hooks.find(interp);
+      if (iter != hooks.end())
+        return AddonClass::Ref<PythonLanguageHook>(iter->second);
+
+      // if we got here then we need to use the global one.
+      if (g_languageHook.isNull())
+        g_languageHook = new XBMCAddon::Python::PythonLanguageHook();
+
+      return g_languageHook;
+    }
+
+    bool PythonLanguageHook::IsAddonClassInstanceRegistered(AddonClass* obj)
+    {
+      for (std::map<PyInterpreterState*,AddonClass::Ref<PythonLanguageHook> >::iterator iter = hooks.begin();
+           iter != hooks.end(); ++iter)
+      {
+        if ((iter->second)->HasRegisteredAddonClassInstance(obj))
+          return true;
+      }
+      return false;
+    }
+
+    /**
+     * PythonCallbackHandler expects to be instantiated PER AddonClass instance
+     *  that is to be used as a callback. This is why this cannot be instantiated
+     *  once.
+     *
+     * There is an expectation that this method is called from the Python thread
+     *  that instantiated an AddonClass that has the potential for a callback.
+     *
+     * See RetardedAsyncCallbackHandler for more details.
+     * See PythonCallbackHandler for more details
+     * See PythonCallbackHandler::PythonCallbackHandler for more details
+     */
+    XBMCAddon::CallbackHandler* PythonLanguageHook::GetCallbackHandler()
+    {
+      XBMC_TRACE;
+      return new PythonCallbackHandler();
+    }
+
+    String PythonLanguageHook::GetAddonId()
+    {
+      XBMC_TRACE;
+
+      // Get a reference to the main module
+      // and global dictionary
+      PyObject* main_module = PyImport_AddModule((char*)"__main__");
+      PyObject* global_dict = PyModule_GetDict(main_module);
+      // Extract a reference to the function "func_name"
+      // from the global dictionary
+      PyObject* pyid = PyDict_GetItemString(global_dict, "__xbmcaddonid__");
+      if (pyid)
+        return PyUnicode_AsUTF8(pyid);
+      return "";
+    }
+
+    String PythonLanguageHook::GetAddonVersion()
+    {
+      XBMC_TRACE;
+      // Get a reference to the main module
+      // and global dictionary
+      PyObject* main_module = PyImport_AddModule((char*)"__main__");
+      PyObject* global_dict = PyModule_GetDict(main_module);
+      // Extract a reference to the function "func_name"
+      // from the global dictionary
+      PyObject* pyversion = PyDict_GetItemString(global_dict, "__xbmcapiversion__");
+      if (pyversion)
+        return PyUnicode_AsUTF8(pyversion);
+      return "";
+    }
+
+    long PythonLanguageHook::GetInvokerId()
+    {
+      XBMC_TRACE;
+
+      // Get a reference to the main module
+      // and global dictionary
+      PyObject* main_module = PyImport_AddModule((char*)"__main__");
+      PyObject* global_dict = PyModule_GetDict(main_module);
+      // Extract a reference to the function "func_name"
+      // from the global dictionary
+      PyObject* pyid = PyDict_GetItemString(global_dict, "__xbmcinvokerid__");
+      if (pyid)
+        return PyLong_AsLong(pyid);
+      return -1;
+    }
+
+
+    void PythonLanguageHook::RegisterPlayerCallback(IPlayerCallback* player) { XBMC_TRACE; g_pythonParser.RegisterPythonPlayerCallBack(player); }
+    void PythonLanguageHook::UnregisterPlayerCallback(IPlayerCallback* player) { XBMC_TRACE; g_pythonParser.UnregisterPythonPlayerCallBack(player); }
+    void PythonLanguageHook::RegisterMonitorCallback(XBMCAddon::xbmc::Monitor* monitor) { XBMC_TRACE; g_pythonParser.RegisterPythonMonitorCallBack(monitor); }
+    void PythonLanguageHook::UnregisterMonitorCallback(XBMCAddon::xbmc::Monitor* monitor) { XBMC_TRACE; g_pythonParser.UnregisterPythonMonitorCallBack(monitor); }
+
+    bool PythonLanguageHook::WaitForEvent(CEvent& hEvent, unsigned int milliseconds)
+    {
+      XBMC_TRACE;
+      return g_pythonParser.WaitForEvent(hEvent,milliseconds);
+    }
+
+    void PythonLanguageHook::RegisterAddonClassInstance(AddonClass* obj)
+    {
+      XBMC_TRACE;
+      CSingleLock l(*this);
+      obj->Acquire();
+      currentObjects.insert(obj);
+    }
+
+    void PythonLanguageHook::UnregisterAddonClassInstance(AddonClass* obj)
+    {
+      XBMC_TRACE;
+      CSingleLock l(*this);
+      if (currentObjects.erase(obj) > 0)
+        obj->Release();
+    }
+
+    bool PythonLanguageHook::HasRegisteredAddonClassInstance(AddonClass* obj)
+    {
+      XBMC_TRACE;
+      CSingleLock l(*this);
+      return currentObjects.find(obj) != currentObjects.end();
+    }
+  }
+}
diff --git a/xbmc/interfaces/python3/LanguageHook.h b/xbmc/interfaces/python3/LanguageHook.h
new file mode 100644
index 000000000000..07847992bad0
--- /dev/null
+++ b/xbmc/interfaces/python3/LanguageHook.h
@@ -0,0 +1,101 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#pragma once
+
+#include <Python.h>
+
+#include "interfaces/legacy/LanguageHook.h"
+#include "threads/Event.h"
+
+#include <set>
+#include <map>
+
+namespace XBMCAddon
+{
+  namespace Python
+  {
+    struct MutableInteger;
+
+    /**
+     * This class supplies the python specific functionality for
+     *  plugging into the API. It's got a static only implementation
+     *  and uses the singleton pattern for access.
+     */
+    class PythonLanguageHook : public XBMCAddon::LanguageHook
+    {
+      PyInterpreterState* m_interp;
+      CCriticalSection crit;
+      std::set<AddonClass*> currentObjects;
+
+      // This constructor is only used to instantiate the global LanguageHook
+      inline PythonLanguageHook() : m_interp(NULL)  {  }
+
+    public:
+
+      inline explicit PythonLanguageHook(PyInterpreterState* interp) : m_interp(interp)  {  }
+      ~PythonLanguageHook() override;
+
+      void DelayedCallOpen() override;
+      void DelayedCallClose() override;
+      void MakePendingCalls() override;
+      
+      /**
+       * PythonCallbackHandler expects to be instantiated PER AddonClass instance
+       *  that is to be used as a callback. This is why this cannot be instantiated
+       *  once.
+       *
+       * There is an expectation that this method is called from the Python thread
+       *  that instantiated an AddonClass that has the potential for a callback.
+       *
+       * See RetardedAsyncCallbackHandler for more details.
+       * See PythonCallbackHandler for more details
+       * See PythonCallbackHandler::PythonCallbackHandler for more details
+       */
+      XBMCAddon::CallbackHandler* GetCallbackHandler() override;
+
+      String GetAddonId() override;
+      String GetAddonVersion() override;
+      long GetInvokerId() override;
+
+      void RegisterPlayerCallback(IPlayerCallback* player) override;
+      void UnregisterPlayerCallback(IPlayerCallback* player) override;
+      void RegisterMonitorCallback(XBMCAddon::xbmc::Monitor* monitor) override;
+      void UnregisterMonitorCallback(XBMCAddon::xbmc::Monitor* monitor) override;
+      bool WaitForEvent(CEvent& hEvent, unsigned int milliseconds) override;
+
+      static AddonClass::Ref<PythonLanguageHook> GetIfExists(PyInterpreterState* interp);
+      static bool IsAddonClassInstanceRegistered(AddonClass* obj);
+
+      void RegisterAddonClassInstance(AddonClass* obj);
+      void UnregisterAddonClassInstance(AddonClass* obj);
+      bool HasRegisteredAddonClassInstance(AddonClass* obj);
+      inline bool HasRegisteredAddonClasses() { CSingleLock l(*this); return !currentObjects.empty(); }
+
+      // You should hold the lock on the LanguageHook itself if you're
+      // going to do anything with the set that gets returned.
+      inline std::set<AddonClass*>& GetRegisteredAddonClasses() { return currentObjects; }
+
+      void UnregisterMe();
+      void RegisterMe();
+    };
+  }
+}
+
diff --git a/xbmc/interfaces/python3/MethodType.groovy b/xbmc/interfaces/python3/MethodType.groovy
new file mode 100644
index 000000000000..7739e90b53e0
--- /dev/null
+++ b/xbmc/interfaces/python3/MethodType.groovy
@@ -0,0 +1,26 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+public enum MethodType
+{
+  constructor, destructor, method
+}
+
+
diff --git a/xbmc/interfaces/python3/PyContext.cpp b/xbmc/interfaces/python3/PyContext.cpp
new file mode 100644
index 000000000000..7ae67d0d39da
--- /dev/null
+++ b/xbmc/interfaces/python3/PyContext.cpp
@@ -0,0 +1,129 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <Python.h>
+
+#include "PyContext.h"
+#include "threads/ThreadLocal.h"
+#include "utils/log.h"
+
+namespace XBMCAddon
+{
+  namespace Python
+  {
+    struct PyContextState
+    {
+      inline explicit PyContextState(bool pcreatedByGilRelease = false) :
+        value(0), state(NULL), gilReleasedDepth(0), createdByGilRelease(pcreatedByGilRelease) {}
+
+      int value;
+      PyThreadState* state;
+      int gilReleasedDepth;
+      bool createdByGilRelease;
+    };
+
+    static XbmcThreads::ThreadLocal<PyContextState> tlsPyContextState;
+
+    void* PyContext::enterContext()
+    {
+      PyContextState* cur = tlsPyContextState.get();
+      if (cur == NULL)
+      {
+        cur = new PyContextState();
+        tlsPyContextState.set(cur);
+      }
+
+      // increment the count
+      cur->value++;
+
+      return cur;
+    }
+
+    void PyContext::leaveContext()
+    {
+      // here we ASSUME that the constructor was called.
+      PyContextState* cur = tlsPyContextState.get();
+      cur->value--;
+      int curlevel = cur->value;
+
+      // this is a hack but ...
+      if (curlevel < 0)
+      {
+        CLog::Log(LOGERROR, "FATAL: PyContext closed more than opened");
+        curlevel = cur->value = 0;
+      }
+
+      if (curlevel == 0)
+      {
+        // clear the tlsPyContextState
+        tlsPyContextState.set(NULL);
+        delete cur;
+      }
+    }
+
+    void PyGILLock::releaseGil()
+    {
+      PyContextState* cur = tlsPyContextState.get();
+
+      // This means we're not within the python context, but
+      // because we may be in a thread spawned by python itself,
+      // we need to handle this.
+      if (!cur)
+      {
+        cur = static_cast<PyContextState*>(PyContext::enterContext());
+        cur->createdByGilRelease = true;
+      }
+
+      if (cur->gilReleasedDepth == 0) // true if we are at the outermost
+      {
+        PyThreadState* _save;
+        // this macro sets _save
+        {
+          Py_UNBLOCK_THREADS
+        }
+        cur->state = _save;
+      }
+      cur->gilReleasedDepth++; // the first time this goes to 1
+    }
+
+    void PyGILLock::acquireGil()
+    {
+      PyContextState* cur = tlsPyContextState.get(); 
+
+      // it's not possible for cur to be NULL (and if it is, we want to fail anyway).
+
+      // decrement the depth and make sure we're in the right place.
+      cur->gilReleasedDepth--;
+      if (cur->gilReleasedDepth == 0) // are we back to zero?
+      {
+        PyThreadState* _save = cur->state;
+        // This macros uses _save
+        {
+          Py_BLOCK_THREADS
+        }
+        cur->state = NULL; // clear the state to indicate we've reacquired the gil
+
+        // we clear it only if we created it on this level.
+        if (cur->createdByGilRelease)
+          PyContext::leaveContext();
+      }
+    }
+  }
+}
diff --git a/xbmc/interfaces/python3/PyContext.h b/xbmc/interfaces/python3/PyContext.h
new file mode 100644
index 000000000000..1c74156d7541
--- /dev/null
+++ b/xbmc/interfaces/python3/PyContext.h
@@ -0,0 +1,58 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+namespace XBMCAddon
+{
+  namespace Python
+  {
+    class PyGILLock;
+
+    /**
+     * These classes should NOT be used with 'new'. They are expected to reside 
+     *  as stack instances and they act as "Guard" classes that track the
+     *  current context.
+     */
+    class PyContext
+    {
+    protected:
+      friend class PyGILLock;
+      static void* enterContext();
+      static void leaveContext();
+    public:
+
+      inline PyContext() { enterContext(); }
+      inline ~PyContext() { leaveContext(); }
+    };
+
+    /**
+     * This class supports recursive locking of the GIL. It assumes that
+     * all Python GIL manipulation is done through this class so that it 
+     * can monitor the current owner.
+     */
+    class PyGILLock
+    {
+    public:
+      static void releaseGil();
+      static void acquireGil();
+
+      inline PyGILLock() { releaseGil(); }
+      inline ~PyGILLock() { acquireGil(); }
+    };
+  }
+}
diff --git a/xbmc/interfaces/python3/PythonInvoker.cpp b/xbmc/interfaces/python3/PythonInvoker.cpp
new file mode 100644
index 000000000000..324ce424e59b
--- /dev/null
+++ b/xbmc/interfaces/python3/PythonInvoker.cpp
@@ -0,0 +1,687 @@
+/*
+ *      Copyright (C) 2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+// python.h should always be included first before any other includes
+#include <Python.h>
+#include <iterator>
+#include <osdefs.h>
+
+#include "system.h"
+#include "PythonInvoker.h"
+#include "Application.h"
+#include "messaging/ApplicationMessenger.h"
+#include "addons/AddonManager.h"
+#include "dialogs/GUIDialogKaiToast.h"
+#include "filesystem/File.h"
+#include "filesystem/SpecialProtocol.h"
+#include "guilib/GraphicContext.h"
+#include "guilib/GUIWindowManager.h"
+#include "guilib/LocalizeStrings.h"
+#include "interfaces/legacy/Addon.h"
+#include "interfaces/python/LanguageHook.h"
+#include "interfaces/python/PyContext.h"
+#include "interfaces/python/pythreadstate.h"
+#include "interfaces/python/swig.h"
+#include "interfaces/python/XBPython.h"
+#include "threads/SingleLock.h"
+#if defined(TARGET_WINDOWS)
+#include "utils/CharsetConverter.h"
+#endif // defined(TARGET_WINDOWS)
+#include "utils/log.h"
+#include "utils/StringUtils.h"
+#include "utils/URIUtils.h"
+#ifdef TARGET_POSIX
+#include "linux/XTimeUtils.h"
+#endif
+
+#ifdef TARGET_WINDOWS
+extern "C" FILE *fopen_utf8(const char *_Filename, const char *_Mode);
+#else
+#define fopen_utf8 fopen
+#endif
+
+#define GC_SCRIPT \
+  "import gc\n" \
+  "gc.collect(2)\n"
+
+#define PY_PATH_SEP DELIM
+
+// Time before ill-behaved scripts are terminated
+#define PYTHON_SCRIPT_TIMEOUT 5000 // ms
+
+using namespace XFILE;
+using namespace KODI::MESSAGING;
+
+extern "C"
+{
+  int xbp_chdir(const char *dirname);
+  char* dll_getenv(const char* szKey);
+}
+
+#define PythonModulesSize sizeof(PythonModules) / sizeof(PythonModule)
+
+CCriticalSection CPythonInvoker::s_critical;
+
+static const std::string getListOfAddonClassesAsString(XBMCAddon::AddonClass::Ref<XBMCAddon::Python::PythonLanguageHook>& languageHook)
+{
+  std::string message;
+  CSingleLock l(*(languageHook.get()));
+  std::set<XBMCAddon::AddonClass*>& acs = languageHook->GetRegisteredAddonClasses();
+  bool firstTime = true;
+  for (std::set<XBMCAddon::AddonClass*>::iterator iter = acs.begin(); iter != acs.end(); ++iter)
+  {
+    if (!firstTime)
+      message += ",";
+    else
+      firstTime = false;
+    message += (*iter)->GetClassname();
+  }
+
+  return message;
+}
+
+static std::vector<std::vector<char>> storeArgumentsCCompatible(std::vector<std::string> const & input)
+{
+  std::vector<std::vector<char>> output;
+  std::transform(input.begin(), input.end(), std::back_inserter(output),
+                [](std::string const & i) { return std::vector<char>(i.c_str(), i.c_str() + i.length() + 1); });
+
+  if (output.empty())
+    output.push_back(std::vector<char>(1u, '\0'));
+
+  return output;
+}
+
+static std::vector<char *> getCPointersToArguments(std::vector<std::vector<char>> & input)
+{
+  std::vector<char *> output;
+  std::transform(input.begin(), input.end(), std::back_inserter(output),
+                [](std::vector<char> & i) { return &i[0]; });
+  return output;
+}
+
+CPythonInvoker::CPythonInvoker(ILanguageInvocationHandler *invocationHandler)
+  : ILanguageInvoker(invocationHandler),
+    m_threadState(NULL), m_stop(false)
+{ }
+
+CPythonInvoker::~CPythonInvoker()
+{
+  // nothing to do for the default invoker used for registration with the
+  // CScriptInvocationManager
+  if (GetId() < 0)
+    return;
+
+  if (GetState() < InvokerStateDone)
+    CLog::Log(LOGDEBUG, "CPythonInvoker(%d): waiting for python thread \"%s\" to stop",
+      GetId(), (!m_sourceFile.empty() ? m_sourceFile.c_str() : "unknown script"));
+  Stop(true);
+  pulseGlobalEvent();
+
+  onExecutionFinalized();
+}
+
+bool CPythonInvoker::Execute(const std::string &script, const std::vector<std::string> &arguments /* = std::vector<std::string>() */)
+{
+  if (script.empty())
+    return false;
+
+  if (!CFile::Exists(script))
+  {
+    CLog::Log(LOGERROR, "CPythonInvoker(%d): python script \"%s\" does not exist", GetId(), CSpecialProtocol::TranslatePath(script).c_str());
+    return false;
+  }
+
+  if (!onExecutionInitialized())
+    return false;
+
+  return ILanguageInvoker::Execute(script, arguments);
+}
+
+bool CPythonInvoker::execute(const std::string &script, const std::vector<std::string> &arguments)
+{
+  // copy the code/script into a local string buffer
+  m_sourceFile = script;
+
+  // copy the arguments into a local buffer
+  unsigned int argc = arguments.size();
+  std::vector<std::vector<char>> argvStorage = storeArgumentsCCompatible(arguments);
+  std::vector<char *> argv = getCPointersToArguments(argvStorage);
+
+  CLog::Log(LOGDEBUG, "CPythonInvoker(%d, %s): start processing", GetId(), m_sourceFile.c_str());
+
+  // get the global lock
+  PyEval_AcquireLock();
+  PyThreadState* state = Py_NewInterpreter();
+  if (state == NULL)
+  {
+    PyEval_ReleaseLock();
+    CLog::Log(LOGERROR, "CPythonInvoker(%d, %s): FAILED to get thread state!", GetId(), m_sourceFile.c_str());
+    return false;
+  }
+  // swap in my thread state
+  PyThreadState_Swap(state);
+
+  XBMCAddon::AddonClass::Ref<XBMCAddon::Python::PythonLanguageHook> languageHook(new XBMCAddon::Python::PythonLanguageHook(state->interp));
+  languageHook->RegisterMe();
+
+  onInitialization();
+  setState(InvokerStateInitialized);
+
+  std::string realFilename(CSpecialProtocol::TranslatePath(m_sourceFile));
+  if (realFilename == m_sourceFile)
+    CLog::Log(LOGDEBUG, "CPythonInvoker(%d, %s): the source file to load is \"%s\"", GetId(), m_sourceFile.c_str(), m_sourceFile.c_str());
+  else
+    CLog::Log(LOGDEBUG, "CPythonInvoker(%d, %s): the source file to load is \"%s\" (\"%s\")", GetId(), m_sourceFile.c_str(), m_sourceFile.c_str(), realFilename.c_str());
+
+  // get path from script file name and add python path's
+  // this is used for python so it will search modules from script path first
+  std::string scriptDir = URIUtils::GetDirectory(realFilename);
+  URIUtils::RemoveSlashAtEnd(scriptDir);
+  addPath(scriptDir);
+
+  // add all addon module dependencies to path
+  if (m_addon)
+  {
+    std::set<std::string> paths;
+    getAddonModuleDeps(m_addon, paths);
+    for (std::set<std::string>::const_iterator it = paths.begin(); it != paths.end(); ++it)
+      addPath(*it);
+  }
+  else
+  { // for backwards compatibility.
+    // we don't have any addon so just add all addon modules installed
+    CLog::Log(LOGWARNING, "CPythonInvoker(%d): Script invoked without an addon. Adding all addon "
+        "modules installed to python path as fallback. This behaviour will be removed in future "
+        "version.", GetId());
+    ADDON::VECADDONS addons;
+    ADDON::CAddonMgr::GetInstance().GetAddons(addons, ADDON::ADDON_SCRIPT_MODULE);
+    for (unsigned int i = 0; i < addons.size(); ++i)
+      addPath(CSpecialProtocol::TranslatePath(addons[i]->LibPath()));
+  }
+
+  // we want to use sys.path so it includes site-packages
+  // if this fails, default to using Py_GetPath
+  PyObject *sysMod(PyImport_ImportModule((char*)"sys")); // must call Py_DECREF when finished
+  PyObject *sysModDict(PyModule_GetDict(sysMod)); // borrowed ref, no need to delete
+  PyObject *pathObj(PyDict_GetItemString(sysModDict, "path")); // borrowed ref, no need to delete
+
+  if (pathObj != NULL && PyList_Check(pathObj))
+  {
+    for (int i = 0; i < PyList_Size(pathObj); i++)
+    {
+      PyObject *e = PyList_GetItem(pathObj, i); // borrowed ref, no need to delete
+      if (e != NULL && PyUnicode_Check(e))
+        addNativePath(PyUnicode_AsUTF8(e)); // returns internal data, don't delete or modify
+    }
+  }
+  else
+    addNativePath((char *)Py_GetPath());
+
+  Py_DECREF(sysMod); // release ref to sysMod
+
+  // set current directory and python's path.
+  PySys_SetArgv(argc, (wchar_t **)(&argv[0]));
+
+#ifdef TARGET_WINDOWS
+  std::string pyPathUtf8;
+  g_charsetConverter.systemToUtf8(m_pythonPath, pyPathUtf8, false);
+  CLog::Log(LOGDEBUG, "CPythonInvoker(%d, %s): setting the Python path to %s", GetId(), m_sourceFile.c_str(), pyPathUtf8.c_str());
+#else // ! TARGET_WINDOWS
+  CLog::Log(LOGDEBUG, "CPythonInvoker(%d, %s): setting the Python path to %s", GetId(), m_sourceFile.c_str(), m_pythonPath.c_str());
+#endif // ! TARGET_WINDOWS
+  PySys_SetPath((wchar_t *)m_pythonPath.c_str());
+
+  CLog::Log(LOGDEBUG, "CPythonInvoker(%d, %s): entering source directory %s", GetId(), m_sourceFile.c_str(), scriptDir.c_str());
+  PyObject* module = PyImport_AddModule((char*)"__main__");
+  PyObject* moduleDict = PyModule_GetDict(module);
+
+  // when we are done initing we store thread state so we can be aborted
+  PyThreadState_Swap(NULL);
+  PyEval_ReleaseLock();
+
+  // we need to check if we was asked to abort before we had inited
+  bool stopping = false;
+  { CSingleLock lock(m_critical);
+    m_threadState = state;
+    stopping = m_stop;
+  }
+
+  PyEval_AcquireLock();
+  PyThreadState_Swap(state);
+
+  bool failed = false;
+  std::string exceptionType, exceptionValue, exceptionTraceback;
+  if (!stopping)
+  {
+    try
+    {
+      // run script from file
+      // We need to have python open the file because on Windows the DLL that python
+      //  is linked against may not be the DLL that xbmc is linked against so
+      //  passing a FILE* to python from an fopen has the potential to crash.
+      std::string nativeFilename(realFilename); // filename in system encoding
+#ifdef TARGET_WINDOWS
+      if (!g_charsetConverter.utf8ToSystem(nativeFilename, true))
+      {
+        CLog::Log(LOGERROR, "CPythonInvoker(%d, %s): can't convert filename \"%s\" to system encoding", GetId(), m_sourceFile.c_str(), realFilename.c_str());
+        return false;
+      }
+#endif
+
+    PyObject *ioMod, *openedFile;
+    ioMod = PyImport_ImportModule("io");
+    openedFile = PyObject_CallMethod(ioMod, "open", "ss", (char *)nativeFilename.c_str(), "r");
+    Py_DECREF(ioMod);
+    FILE *fp = py3c_PyFile_AsFileWithMode(openedFile, (char *)"r");
+
+      if (fp != NULL)
+      {
+        PyObject *f = PyUnicode_FromString(nativeFilename.c_str());
+        PyDict_SetItemString(moduleDict, "__file__", f);
+
+        onPythonModuleInitialization(moduleDict);
+
+        Py_DECREF(f);
+        setState(InvokerStateRunning);
+        XBMCAddon::Python::PyContext pycontext; // this is a guard class that marks this callstack as being in a python context
+        executeScript(fp, nativeFilename, module, moduleDict);
+      }
+      else
+        CLog::Log(LOGERROR, "CPythonInvoker(%d, %s): %s not found!", GetId(), m_sourceFile.c_str(), m_sourceFile.c_str());
+    }
+    catch (const XbmcCommons::Exception& e)
+    {
+      setState(InvokerStateFailed);
+      e.LogThrowMessage();
+      failed = true;
+    }
+    catch (...)
+    {
+      setState(InvokerStateFailed);
+      CLog::Log(LOGERROR, "CPythonInvoker(%d, %s): failure in script", GetId(), m_sourceFile.c_str());
+      failed = true;
+    }
+  }
+
+  bool systemExitThrown = false;
+  InvokerState stateToSet;
+  if (!failed && !PyErr_Occurred())
+  {
+    CLog::Log(LOGINFO, "CPythonInvoker(%d, %s): script successfully run", GetId(), m_sourceFile.c_str());
+    stateToSet = InvokerStateDone;
+    onSuccess();
+  }
+  else if (PyErr_ExceptionMatches(PyExc_SystemExit))
+  {
+    systemExitThrown = true;
+    CLog::Log(LOGINFO, "CPythonInvoker(%d, %s): script aborted", GetId(), m_sourceFile.c_str());
+    stateToSet = InvokerStateFailed;
+    onAbort();
+  }
+  else
+  {
+    stateToSet = InvokerStateFailed;
+
+    // if it failed with an exception we already logged the details
+    if (!failed)
+    {
+      PythonBindings::PythonToCppException *e = NULL;
+      if (PythonBindings::PythonToCppException::ParsePythonException(exceptionType, exceptionValue, exceptionTraceback))
+        e = new PythonBindings::PythonToCppException(exceptionType, exceptionValue, exceptionTraceback);
+      else
+        e = new PythonBindings::PythonToCppException();
+
+      e->LogThrowMessage();
+      delete e;
+    }
+
+    onError(exceptionType, exceptionValue, exceptionTraceback);
+  }
+
+  // no need to do anything else because the script has already stopped
+  if (failed)
+  {
+    setState(stateToSet);
+    return true;
+  }
+
+  PyObject *m = PyImport_AddModule((char*)"xbmc");
+  if (m == NULL || PyObject_SetAttrString(m, (char*)"abortRequested", PyBool_FromLong(1)))
+    CLog::Log(LOGERROR, "CPythonInvoker(%d, %s): failed to set abortRequested", GetId(), m_sourceFile.c_str());
+
+  // make sure all sub threads have finished
+  for (PyThreadState* s = state->interp->tstate_head, *old = NULL; s;)
+  {
+    if (s == state)
+    {
+      s = s->next;
+      continue;
+    }
+    if (old != s)
+    {
+      CLog::Log(LOGINFO, "CPythonInvoker(%d, %s): waiting on thread %" PRIu64, GetId(), m_sourceFile.c_str(), (uint64_t)s->thread_id);
+      old = s;
+    }
+
+    CPyThreadState pyState;
+    Sleep(100);
+    pyState.Restore();
+
+    s = state->interp->tstate_head;
+  }
+
+  // pending calls must be cleared out
+  XBMCAddon::RetardedAsyncCallbackHandler::clearPendingCalls(state);
+
+  PyThreadState_Swap(NULL);
+  PyEval_ReleaseLock();
+
+  // set stopped event - this allows ::stop to run and kill remaining threads
+  // this event has to be fired without holding m_critical
+  // also the GIL (PyEval_AcquireLock) must not be held
+  // if not obeyed there is still no deadlock because ::stop waits with timeout (smart one!)
+  m_stoppedEvent.Set();
+
+  { CSingleLock lock(m_critical);
+    m_threadState = NULL;
+  }
+
+  PyEval_AcquireLock();
+  PyThreadState_Swap(state);
+
+  onDeinitialization();
+
+  // run the gc before finishing
+  //
+  // if the script exited by throwing a SystemExit exception then going back
+  // into the interpreter causes this python bug to get hit:
+  //    http://bugs.python.org/issue10582
+  // and that causes major failures. So we are not going to go back in
+  // to run the GC if that's the case.
+  if (!m_stop && languageHook->HasRegisteredAddonClasses() && !systemExitThrown &&
+      PyRun_SimpleString(GC_SCRIPT) == -1)
+    CLog::Log(LOGERROR, "CPythonInvoker(%d, %s): failed to run the gc to clean up after running prior to shutting down the Interpreter", GetId(), m_sourceFile.c_str());
+
+  Py_EndInterpreter(state);
+
+  // If we still have objects left around, produce an error message detailing what's been left behind
+  if (languageHook->HasRegisteredAddonClasses())
+    CLog::Log(LOGWARNING, "CPythonInvoker(%d, %s): the python script \"%s\" has left several "
+      "classes in memory that we couldn't clean up. The classes include: %s",
+      GetId(), m_sourceFile.c_str(), m_sourceFile.c_str(), getListOfAddonClassesAsString(languageHook).c_str());
+
+  // unregister the language hook
+  languageHook->UnregisterMe();
+
+  PyEval_ReleaseLock();
+
+  setState(stateToSet);
+
+  return true;
+}
+
+void CPythonInvoker::executeScript(void *fp, const std::string &script, void *module, void *moduleDict)
+{
+  if (fp == NULL || script.empty() || module == NULL || moduleDict == NULL)
+    return;
+
+  int m_Py_file_input = Py_file_input;
+  PyRun_FileExFlags(static_cast<FILE*>(fp), script.c_str(), m_Py_file_input, static_cast<PyObject*>(moduleDict), static_cast<PyObject*>(moduleDict), 1, NULL);
+}
+
+bool CPythonInvoker::stop(bool abort)
+{
+  CSingleLock lock(m_critical);
+  m_stop = true;
+
+  if (!IsRunning())
+    return false;
+
+  setState(InvokerStateStopping);
+
+  if (m_threadState != NULL)
+  {
+    PyEval_AcquireLock();
+    PyThreadState* old = PyThreadState_Swap((PyThreadState*)m_threadState);
+
+    //tell xbmc.Monitor to call onAbortRequested()
+    if (m_addon != NULL)
+      onAbortRequested();
+
+    PyObject *m;
+    m = PyImport_AddModule((char*)"xbmc");
+    if (m == NULL || PyObject_SetAttrString(m, (char*)"abortRequested", PyBool_FromLong(1)))
+      CLog::Log(LOGERROR, "CPythonInvoker(%d, %s): failed to set abortRequested", GetId(), m_sourceFile.c_str());
+
+    PyThreadState_Swap(old);
+    old = NULL;
+    PyEval_ReleaseLock();
+
+    XbmcThreads::EndTime timeout(PYTHON_SCRIPT_TIMEOUT);
+    while (!m_stoppedEvent.WaitMSec(15))
+    {
+      if (timeout.IsTimePast())
+      {
+        CLog::Log(LOGERROR, "CPythonInvoker(%d, %s): script didn't stop in %d seconds - let's kill it", GetId(), m_sourceFile.c_str(), PYTHON_SCRIPT_TIMEOUT / 1000);
+        break;
+      }
+
+      // We can't empty-spin in the main thread and expect scripts to be able to
+      // dismantle themselves. Python dialogs aren't normal XBMC dialogs, they rely
+      // on TMSG_GUI_PYTHON_DIALOG messages, so pump the message loop.
+      if (g_application.IsCurrentThread())
+      {
+        CApplicationMessenger::GetInstance().ProcessMessages();
+      }
+    }
+
+    // Useful for add-on performance metrics
+    if (!timeout.IsTimePast())
+      CLog::Log(LOGDEBUG, "CPythonInvoker(%d, %s): script termination took %dms", GetId(), m_sourceFile.c_str(), PYTHON_SCRIPT_TIMEOUT - timeout.MillisLeft());
+
+    // everything which didn't exit by now gets killed
+    {
+      // grabbing the PyLock while holding the m_critical is asking for a deadlock
+      CSingleExit ex2(m_critical);
+      PyEval_AcquireLock();
+    }
+
+    // Since we released the m_critical it's possible that the state is cleaned up
+    // so we need to recheck for m_threadState == NULL
+    if (m_threadState != NULL)
+    {
+      old = PyThreadState_Swap((PyThreadState*)m_threadState);
+      for (PyThreadState* state = ((PyThreadState*)m_threadState)->interp->tstate_head; state; state = state->next)
+      {
+        // Raise a SystemExit exception in python threads
+        Py_XDECREF(state->async_exc);
+        state->async_exc = PyExc_SystemExit;
+        Py_XINCREF(state->async_exc);
+      }
+
+      // If a dialog entered its doModal(), we need to wake it to see the exception
+      pulseGlobalEvent();
+    }
+
+    if (old != NULL)
+      PyThreadState_Swap(old);
+
+    lock.Leave();
+    PyEval_ReleaseLock();
+  }
+
+  return true;
+}
+
+void CPythonInvoker::onExecutionFailed()
+{
+  PyThreadState_Swap(NULL);
+  PyEval_ReleaseLock();
+
+  setState(InvokerStateFailed);
+  CLog::Log(LOGERROR, "CPythonInvoker(%d, %s): abnormally terminating python thread", GetId(), m_sourceFile.c_str());
+
+  CSingleLock lock(m_critical);
+  m_threadState = NULL;
+
+  ILanguageInvoker::onExecutionFailed();
+}
+
+std::map<std::string, CPythonInvoker::PythonModuleInitialization> CPythonInvoker::getModules() const
+{
+  static std::map<std::string, PythonModuleInitialization> modules;
+  return modules;
+}
+
+void CPythonInvoker::onInitialization()
+{
+  XBMC_TRACE;
+  {
+    GilSafeSingleLock lock(s_critical);
+    initializeModules(getModules());
+  }
+
+  // get a possible initialization script
+  const char* runscript = getInitializationScript();
+  if (runscript!= NULL && strlen(runscript) > 0)
+  {
+    // redirecting default output to debug console
+    if (PyRun_SimpleString(runscript) == -1)
+      CLog::Log(LOGFATAL, "CPythonInvoker(%d, %s): initialize error", GetId(), m_sourceFile.c_str());
+  }
+}
+
+void CPythonInvoker::onPythonModuleInitialization(void* moduleDict)
+{
+  if (m_addon.get() == NULL || moduleDict == NULL)
+    return;
+
+  PyObject *moduleDictionary = (PyObject *)moduleDict;
+
+  PyObject *pyaddonid = PyUnicode_FromString(m_addon->ID().c_str());
+  PyDict_SetItemString(moduleDictionary, "__xbmcaddonid__", pyaddonid);
+
+  ADDON::AddonVersion version = m_addon->GetDependencyVersion("xbmc.python");
+  PyObject *pyxbmcapiversion = PyUnicode_FromString(version.asString().c_str());
+  PyDict_SetItemString(moduleDictionary, "__xbmcapiversion__", pyxbmcapiversion);
+
+  PyObject *pyinvokerid = PyLong_FromLong(GetId());
+  PyDict_SetItemString(moduleDictionary, "__xbmcinvokerid__", pyinvokerid);
+
+  CLog::Log(LOGDEBUG, "CPythonInvoker(%d, %s): instantiating addon using automatically obtained id of \"%s\" dependent on version %s of the xbmc.python api",
+            GetId(), m_sourceFile.c_str(), m_addon->ID().c_str(), version.asString().c_str());
+}
+
+void CPythonInvoker::onDeinitialization()
+{
+  XBMC_TRACE;
+}
+
+void CPythonInvoker::onError(const std::string &exceptionType /* = "" */, const std::string &exceptionValue /* = "" */, const std::string &exceptionTraceback /* = "" */)
+{
+  CPyThreadState releaseGil;
+  CSingleLock gc(g_graphicsContext);
+
+  CGUIDialogKaiToast *pDlgToast = g_windowManager.GetWindow<CGUIDialogKaiToast>(WINDOW_DIALOG_KAI_TOAST);
+  if (pDlgToast != NULL)
+  {
+    std::string message;
+    if (m_addon && !m_addon->Name().empty())
+      message = StringUtils::Format(g_localizeStrings.Get(2102).c_str(), m_addon->Name().c_str());
+    else if (m_sourceFile == CSpecialProtocol::TranslatePath("special://profile/autoexec.py"))
+      message = StringUtils::Format(g_localizeStrings.Get(2102).c_str(), "autoexec.py");
+    else
+       message = g_localizeStrings.Get(2103);
+    pDlgToast->QueueNotification(CGUIDialogKaiToast::Error, message, g_localizeStrings.Get(2104));
+  }
+}
+
+const char* CPythonInvoker::getInitializationScript() const
+{
+  return NULL;
+}
+
+void CPythonInvoker::initializeModules(const std::map<std::string, PythonModuleInitialization> &modules)
+{
+  for (std::map<std::string, PythonModuleInitialization>::const_iterator module = modules.begin(); module != modules.end(); ++module)
+  {
+    if (!initializeModule(module->second))
+      CLog::Log(LOGWARNING, "CPythonInvoker(%d, %s): unable to initialize python module \"%s\"", GetId(), m_sourceFile.c_str(), module->first.c_str());
+  }
+}
+
+bool CPythonInvoker::initializeModule(PythonModuleInitialization module)
+{
+  if (module == NULL)
+    return false;
+
+  module();
+  return true;
+}
+
+void CPythonInvoker::getAddonModuleDeps(const ADDON::AddonPtr& addon, std::set<std::string>& paths)
+{
+  ADDON::ADDONDEPS deps = addon->GetDeps();
+  for (ADDON::ADDONDEPS::const_iterator it = deps.begin(); it != deps.end(); ++it)
+  {
+    //Check if dependency is a module addon
+    ADDON::AddonPtr dependency;
+    if (ADDON::CAddonMgr::GetInstance().GetAddon(it->first, dependency, ADDON::ADDON_SCRIPT_MODULE))
+    {
+      std::string path = CSpecialProtocol::TranslatePath(dependency->LibPath());
+      if (paths.find(path) == paths.end())
+      {
+        // add it and its dependencies
+        paths.insert(path);
+        getAddonModuleDeps(dependency, paths);
+      }
+    }
+  }
+}
+
+void CPythonInvoker::addPath(const std::string& path)
+{
+#if defined(TARGET_WINDOWS)
+  if (path.empty())
+    return;
+
+  std::string nativePath(path);
+  if (!g_charsetConverter.utf8ToSystem(nativePath, true))
+  {
+    CLog::Log(LOGERROR, "%s: can't convert UTF-8 path \"%s\" to system encoding", __FUNCTION__, path.c_str());
+    return;
+  }
+  addNativePath(nativePath);
+#else
+  addNativePath(path);
+#endif // defined(TARGET_WINDOWS)
+}
+
+void CPythonInvoker::addNativePath(const std::string& path)
+{
+  if (path.empty())
+    return;
+
+  if (!m_pythonPath.empty())
+    m_pythonPath += PY_PATH_SEP;
+
+  m_pythonPath += path;
+}
diff --git a/xbmc/interfaces/python3/PythonInvoker.h b/xbmc/interfaces/python3/PythonInvoker.h
new file mode 100644
index 000000000000..f461355f6fdf
--- /dev/null
+++ b/xbmc/interfaces/python3/PythonInvoker.h
@@ -0,0 +1,77 @@
+#pragma once
+/*
+ *      Copyright (C) 2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <map>
+#include <string>
+#include <vector>
+
+#include "interfaces/generic/ILanguageInvoker.h"
+#include "threads/CriticalSection.h"
+#include "threads/Event.h"
+
+class CPythonInvoker : public ILanguageInvoker
+{
+public:
+  explicit CPythonInvoker(ILanguageInvocationHandler *invocationHandler);
+  ~CPythonInvoker() override;
+
+  bool Execute(const std::string &script, const std::vector<std::string> &arguments = std::vector<std::string>()) override;
+  bool IsStopping() const override { return m_stop || ILanguageInvoker::IsStopping(); }
+
+  typedef PyObject* (*PythonModuleInitialization)();
+
+protected:
+  // implementation of ILanguageInvoker
+  bool execute(const std::string &script, const std::vector<std::string> &arguments) override;
+  virtual void executeScript(void *fp, const std::string &script, void *module, void *moduleDict);
+  bool stop(bool abort) override;
+  void onExecutionFailed() override;
+
+  // custom virtual methods
+  virtual std::map<std::string, PythonModuleInitialization> getModules() const;
+  virtual const char* getInitializationScript() const;
+  virtual void onInitialization();
+  // actually a PyObject* but don't wanna draw Python.h include into the header
+  virtual void onPythonModuleInitialization(void* moduleDict);
+  virtual void onDeinitialization();
+
+  virtual void onSuccess() { }
+  virtual void onAbort() { }
+  virtual void onError(const std::string &exceptionType = "", const std::string &exceptionValue = "", const std::string &exceptionTraceback = "");
+
+  std::string m_sourceFile;
+  CCriticalSection m_critical;
+
+private:
+  void initializeModules(const std::map<std::string, PythonModuleInitialization> &modules);
+  bool initializeModule(PythonModuleInitialization module);
+  void addPath(const std::string& path); // add path in UTF-8 encoding
+  void addNativePath(const std::string& path); // add path in system/Python encoding
+  void getAddonModuleDeps(const ADDON::AddonPtr& addon, std::set<std::string>& paths);
+  bool execute(const std::string &script, const std::vector<std::wstring> &arguments);
+
+  std::string m_pythonPath;
+  void *m_threadState;
+  bool m_stop;
+  CEvent m_stoppedEvent;
+
+  static CCriticalSection s_critical;
+};
diff --git a/xbmc/interfaces/python3/PythonSwig.cpp.template b/xbmc/interfaces/python3/PythonSwig.cpp.template
new file mode 100644
index 000000000000..1b2c9fcc3289
--- /dev/null
+++ b/xbmc/interfaces/python3/PythonSwig.cpp.template
@@ -0,0 +1,958 @@
+<%
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+%>
+<%
+import Helper
+import SwigTypeParser
+import PythonTools
+
+import groovy.xml.XmlUtil
+import groovy.text.SimpleTemplateEngine
+import java.util.regex.Pattern
+
+/**
+ * All of the method nodes and all of the class nodes are used several
+ * times over, so they are pulled out once here.
+ */
+
+// ---------------------------------------------------------
+// initialize the SwigTypeParser with the module's typetables
+module.findAll( { it.name() == 'typetab' } ).each {  SwigTypeParser.appendTypeTable(it) }
+// ---------------------------------------------------------
+
+// ---------------------------------------------------------
+// Flatten out all of the method/function nodes, whether inside
+//  classes or not, into 'methods'
+List methods = module.depthFirst().findAll { it.name() == 'function' || it.name() == 'constructor' || it.name() == 'destructor' }
+// ---------------------------------------------------------
+
+// ---------------------------------------------------------
+// Flatten out all of the class nodes into 'classes'
+List classes = module.depthFirst().findAll { it.name() == 'class' }
+// ---------------------------------------------------------
+
+// ---------------------------------------------------------
+// Initialize the Helper with the type conversions
+Helper.setup(this,classes,
+    /**
+     * This is meant to contain mini-templates for converting the return type
+     * of the native call to be returned to the python caller.
+     */
+    [ 'void' : 'Py_INCREF(Py_None);\n    ${result} = Py_None;',
+      'long': '${result} = PyLong_FromLong(${api});',
+      'unsigned long': '${result} = PyLong_FromLong(${api});',
+      'bool': '${result} = Py_BuildValue((char*)"b", ${api});',
+      'long long': '${result} = Py_BuildValue((char*)"L", ${api});',
+      'int': '${result} = Py_BuildValue((char*)"i", ${api});',
+      'double': '${result} = PyFloat_FromDouble(${api});',
+      'float': '${result} = Py_BuildValue((char*)"f", ${api});',
+      'std::string' : new File('typemaps/python.string.outtm'),
+      'p.q(const).char' : '${result} = PyUnicode_FromString(${api});',
+      (Pattern.compile('''(p.){0,1}XbmcCommons::Buffer''')) : new File('typemaps/python.buffer.outtm'),
+      (Pattern.compile('''std::shared_ptr<\\(.*\\)>''')) : new File('typemaps/python.smart_ptr.outtm'),
+      (Pattern.compile('''std::unique_ptr<\\(.*\\)>''')) : new File('typemaps/python.smart_ptr.outtm'),
+      (Pattern.compile('''(p.){0,1}std::vector<\\(.*\\)>''')) : new File('typemaps/python.vector.outtm'),
+      (Pattern.compile('''(p.){0,1}Tuple<\\(.*\\)>''')) : new File('typemaps/python.Tuple.outtm'),
+      (Pattern.compile('''(p.){0,1}Alternative<\\(.*\\)>''')) : new File('typemaps/python.Alternative.outtm')
+    ], '${result} = makePythonInstance(${api},true);',
+    /**
+     * This is meant to contain mini-templates for converting the parameter types
+     * of the native call to be converted from the python types provided by the caller.
+     *
+     * Note: if the type can be handled by PythonTools.ltypeToFormatChar then it wont
+     * appear here as it gets converted directly within the PyArg_ParseTupleAndKeywords
+     * call.
+     */
+    [
+      'std::string' : 'if (${slarg}) PyXBMCGetUnicodeString(${api},${slarg},false,"${api}","${method.@name}");',
+      (Pattern.compile('''(p.){0,1}std::vector<\\(.*\\)>''')) : new File('typemaps/python.vector.intm'),
+      (Pattern.compile('''(p.){0,1}Tuple(3){0,1}<\\(.*\\)>''')) : new File('typemaps/python.Tuple.intm'),
+      (Pattern.compile('''(p.){0,1}Alternative<\\(.*\\)>''')) : new File('typemaps/python.Alternative.intm'),
+      (Pattern.compile('''(r.){0,1}XbmcCommons::Buffer''')) : new File('typemaps/python.buffer.intm'),
+      (Pattern.compile('''(p.){0,1}std::map<\\(.*\\)>''')) : new File('typemaps/python.map.intm'),
+      (Pattern.compile('''(r.){0,1}XBMCAddon::Dictionary<\\(.*\\)>''')) : new File('typemaps/python.dict.intm'),
+      (Pattern.compile('''p.void''')) : '${api} = (void*)${slarg};',
+      'bool' : '${api} = (PyLong_AsLong(${slarg}) == 0L ? false : true);',
+      'long' : '${api} = PyLong_AsLong(${slarg});',
+      'unsigned long' : '${api} = PyLong_AsUnsignedLong(${slarg});',
+      'long long' : '${api} = PyLong_AsLongLong(${slarg});',
+      'unsigned long long' : '${api} = PyLong_AsUnsignedLongLong(${slarg});',
+      'int' : '${api} = (int)PyLong_AsLong(${slarg});',
+      'double' : '${api} = PyFloat_AsDouble(${slarg});',
+      'float' : '${api} = (float)PyFloat_AsDouble(${slarg});',
+      'XBMCAddon::StringOrInt' : 'if (${slarg}) PyXBMCGetUnicodeString(${api},${slarg},PyLong_Check(${slarg}) || PyLong_Check(${slarg}) || PyFloat_Check(${slarg}),"${api}","${method.@name}");'
+    ], '${api} = (${swigTypeParser.SwigType_str(ltype)})retrieveApiInstance(${slarg},"${ltype}","${helper.findNamespace(method)}","${helper.callingName(method)}");')
+// ---------------------------------------------------------
+
+/*******************************************************************************/
+/**
+ * The doMethod will actually write out the CPython method call for
+ *  the method/function represented by the provided Node ('method').
+ */
+void doMethod(Node method, MethodType methodType)
+{
+  boolean isOperator = method.@name.startsWith("operator ")
+  boolean doAsMappingIndex = false
+  boolean doAsCallable = false
+
+  if (isOperator)
+  {
+    if("[]" == method.@name.substring(9))
+      doAsMappingIndex = true
+    else if("()" == method.@name.substring(9))
+      doAsCallable = true
+    else
+      return;
+  }
+
+  boolean constructor = methodType == MethodType.constructor
+
+  // if we're a constructor, but we're private, then we're outta here
+  if (constructor && method.@access != null && method.@access != "public")
+    return
+
+  boolean destructor = methodType == MethodType.destructor
+  List params = method?.parm
+  int numParams = params?.size()
+  String clazz = Helper.findFullClassName(method)
+  String returns = constructor ? 'p.' + clazz : (destructor ? 'void' : Helper.getReturnSwigType(method))
+  Node classnode = Helper.findClassNode(method)
+  String classNameAsVariable = clazz == null ? null : PythonTools.getClassNameAsVariable(classnode)
+  boolean useKeywordParsing = !('true' == classnode?.@feature_python_nokwds || 'true' == method?.@feature_python_nokwds)
+
+  // do the docs
+  if (!constructor && !destructor)
+  {
+    if (Helper.hasDoc(method))
+    {
+%>
+  PyDoc_STRVAR(${PythonTools.getPyMethodName(method,methodType)}__doc__,
+               ${PythonTools.makeDocString(method.doc[0])});
+<%  }
+  }
+%>
+  static <% if(methodType == MethodType.destructor) { %>void<% } else { %>PyObject*<% } %> ${module.@name}_${PythonTools.getPyMethodName(method,methodType)} (<%= ((clazz == null) ? "PyObject" :
+                   (constructor ? "PyTypeObject" : 'PyHolder')) %>* ${constructor ? 'pytype' : 'self'} <%
+                   if (doAsMappingIndex) { %>, PyObject* py${params[0].@name}<% }
+                   else if (methodType != MethodType.destructor) { %> , PyObject *args, PyObject *kwds <%} %> )
+  {
+    XBMC_TRACE;
+<%  if (numParams > 0)
+    {
+      if (useKeywordParsing && !doAsMappingIndex)
+      { %>
+    static const char *keywords[] = {<%
+          params.each { %>
+          "${it.@name}",<% } %>
+          NULL};
+<%    }
+      params.each {
+%>
+    ${SwigTypeParser.SwigType_str(SwigTypeParser.convertTypeToLTypeForParam(it.@type))} ${it.@name} ${it.@value != null ? ' = ' + it.@value : SwigTypeParser.SwigType_ispointer(it.@type) ? ' = nullptr' :  ''};<%
+        if (!PythonTools.parameterCanBeUsedDirectly(it) && !doAsMappingIndex)
+        { %>
+    PyObject* py${it.@name} = NULL;<%
+        }
+     }
+    if (!doAsMappingIndex)
+    { %>
+    if (!${useKeywordParsing ? 'PyArg_ParseTupleAndKeywords' : 'PyArg_ParseTuple'}(
+       args,
+       <% if (useKeywordParsing) { %>kwds,<% } %>
+       (char*)"<%= PythonTools.makeFormatStringFromParameters(method) %>",
+       <% if (useKeywordParsing) { %>(char**)keywords,<% } %><%    params.eachWithIndex { param,i -> %>
+         &${PythonTools.parameterCanBeUsedDirectly(param) ? '' : 'py'}${param.@name}${i < params.size() - 1 ? "," : ""}<% } %>
+       ))
+    {
+      return NULL;
+    }
+
+<%  }
+    }
+    // now actually invoke the method
+    if (returns != "void") { %>    ${SwigTypeParser.SwigType_lstr(returns)} apiResult;<%   }
+%>
+    try
+    {
+<%
+    // now do the input conversion if any are necessary
+    params.findAll({ !PythonTools.parameterCanBeUsedDirectly(it) || doAsMappingIndex }).each { %>      ${Helper.getInConversion(it.@type, it.@name, 'py' + it.@name, method)} <% println() }
+%>
+<%
+    // check to see if this method is a call to a virtual function on a director class.
+    boolean isDirectorCall = Helper.isDirector(method)
+    if (isDirectorCall)
+    {
+%>      // This is a director call coming from python so it explicitly calls the base class method.
+<%
+    }
+    // now do the method call itself
+    if (!destructor) {
+    if (constructor || !clazz) {  %>      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());<% println() }
+%>      <%
+    if (returns != "void") { %>apiResult = (${SwigTypeParser.SwigType_lstr(returns)})<% }
+    if (clazz && !constructor) {
+      %>((${clazz}*)retrieveApiInstance((PyObject*)self,&Ty${classNameAsVariable}_Type,"${Helper.callingName(method)}","${clazz}"))-> <%
+    }
+    if (constructor && classnode.@feature_director) {
+    %>(&(Ty${classNameAsVariable}_Type.pythonType) != pytype) ? new ${classNameAsVariable}_Director(<% params.eachWithIndex { param, i -> %> ${param.@name}${i < params.size() - 1 ? "," : ""} <% } %>) : <% }
+
+    // Here is the actual call ... if this is a Director we need to do an upCall (from Python)
+    if (isDirectorCall){ %>${clazz}::<% }
+    %>${Helper.callingName(method)}( <% params.eachWithIndex { param, i -> %> ${param.@name}${i < params.size() - 1 ? "," : ""} <% } %> );
+<%
+      if (constructor) {  %>      prepareForReturn(apiResult);<% }
+    } // close the 'if method is not a destructor'
+    else {  // it is a destructor
+%>
+      ${clazz}* theObj = (${clazz}*)retrieveApiInstance((PyObject*)self,&Ty${classNameAsVariable}_Type,"~${Helper.callingName(method)}","${clazz}");
+      cleanForDealloc(theObj);
+<%
+    }
+%>
+    }
+    catch (const XBMCAddon::WrongTypeException& e)
+    {
+      CLog::Log(LOGERROR,"EXCEPTION: %s",e.GetMessage());
+      PyErr_SetString(PyExc_TypeError, e.GetMessage()); <%
+      if (!destructor) {  %>
+      return NULL; <%
+      } %>
+    }
+    catch (const XbmcCommons::Exception& e)
+    {
+      CLog::Log(LOGERROR,"EXCEPTION: %s",e.GetMessage());
+      PyErr_SetString(PyExc_RuntimeError, e.GetMessage()); <%
+      if (!destructor) {  %>
+      return NULL; <%
+      } %>
+    }
+    catch (...)
+    {
+      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"${Helper.callingName(method)}\"");
+      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"${Helper.callingName(method)}\""); <%
+      if (!destructor) {  %>
+      return NULL; <%
+      } %>
+    }
+<%
+    if (!destructor) { %>
+    PyObject* result = Py_None;
+
+    // transform the result
+<%
+    if (constructor) {
+      %>    result = makePythonInstance(apiResult,pytype,false);<%
+    }
+    else {
+%>    ${Helper.getOutConversion(returns,'result',method)}<%
+    }
+    if (constructor && method.@feature_director) { %>
+    if (&(Ty${classNameAsVariable}_Type.pythonType) != pytype)
+      ((${classNameAsVariable}_Director*)apiResult)->setPyObjectForDirector(result);<%
+    }
+ %>
+
+    return result; <% }
+    else { %>
+    (((PyObject*)(self))->ob_type)->tp_free((PyObject*)self);
+    <%
+    }
+    %>
+  } <%
+}
+/*******************************************************************************/
+
+/**
+ * This method writes out the instance of a TypeInfo (which includes
+ * The PyTypeObject as a member) for the class node provided.
+ *
+ * If classNameAsVariable is not null then the class name as a
+ * variable will be appended to it.
+ */
+void doClassTypeInfo(Node clazz, List classNameAsVariables = null)
+{
+  String classNameAsVariable = PythonTools.getClassNameAsVariable(clazz)
+  String fullClassName = Helper.findFullClassName(clazz)
+  classNameAsVariables?.add(classNameAsVariable)
+%>
+  //=========================================================================
+  // These variables will hold the Python Type information for ${fullClassName}
+  TypeInfo Ty${classNameAsVariable}_Type(typeid(${fullClassName}));<%
+%>
+  //=========================================================================
+<%
+}
+
+/**
+ * This method will take the name of an API class from another module and
+ *  create an external reference to its TypeInfo instance.
+ */
+void doExternClassTypeInfo(String knownType)
+{
+  String classNameAsVariable = knownType.replaceAll('::','_')
+%>
+  //=========================================================================
+  // These variables define the type ${knownType} from another module
+  extern TypeInfo Ty${classNameAsVariable}_Type;
+  //=========================================================================
+<%
+}
+
+/*******************************************************************************/
+/**
+ * This method takes the class node and outputs all of the python meta-data
+ *  and class oddities (like comparators, as_mapping, etc.). These include:
+ *
+ * 1) comparator *_cmp python method as long as there's an operator==, an
+ *    operator>, AND an operator<.
+ * 2) it will create a python "as_mapping" method as long as there's both
+ *    an operator[], AND a .size() method on the class.
+ * 3) it will handle the explicitly defined rich compare (_rcmp) if the
+ *    feature is included in the .i file using %feature("python:rcmp")
+ * 4) The array of PyMethodDefs for the class definition
+ * 5) It will handle public fields as if the were python properties by:
+ *    a) Creating a get/set_member if there are read/write properties.
+ *    b) Creating only a get if there are only read-only properties.
+ * 6) It will write the init[Classname] method for the class which will
+ *    initialize the TypeInfo and PyTypeObject structs.
+ *
+ * If initTypeCalls is not null then the method name for the generated init
+ *  method (see #6 above) will be appended to it.
+ */
+void doClassMethodInfo(Node clazz, List initTypeCalls)
+{
+  String classNameAsVariable = PythonTools.getClassNameAsVariable(clazz)
+  String fullClassName = Helper.findFullClassName(clazz)
+  String initTypeCall = "initPy${classNameAsVariable}_Type"
+  initTypeCalls?.add(initTypeCall)
+
+  // see if we have any valid (or invalid) operators
+  boolean doComparator = false
+  boolean doAsMapping = false
+  boolean hasEquivalenceOp = false
+  boolean hasLtOp = false
+  boolean hasGtOp = false
+  Node indexOp = null
+  Node callableOp = null
+  Node sizeNode = null
+
+  List normalMethods = clazz.function.findAll { !it.@name.startsWith("operator ") }
+  List operators =  clazz.function.findAll { it.@name.startsWith("operator ") }
+  List properties = clazz.variable.findAll { it.@access != null && it.@access == "public" }
+  List properties_set = properties.findAll { it.@feature_immutable == null || it.@feature_immutable == 0 }
+
+  operators.each {
+    // we have an operator. The only one we can handle is ==
+    if (it.@name.substring(9).startsWith("=="))
+      hasEquivalenceOp = true
+    else if (it.@name.substring(9) == "<")
+      hasLtOp = true
+    else if (it.@name.substring(9) == ">")
+      hasGtOp = true
+    else if (it.@name.substring(9) == "[]")
+      indexOp = it
+    else if (it.@name.substring(9) == "()")
+      callableOp = it
+    else
+      System.err.println ("Warning: class ${fullClassName} has an operator \"${it.@name}\" that is being ignored.");
+  }
+
+  if (hasGtOp || hasLtOp || hasEquivalenceOp)
+  {
+    if (!(hasLtOp && hasGtOp && hasEquivalenceOp))
+      System.err.println ("Warning: class ${fullClassName} has an inconsistent operator set. To get a comparator you must implement all 3 operators >,<,==.")
+    else
+      doComparator = true
+  }
+
+  if (indexOp)
+  {
+    sizeNode =  clazz.function.find { it.@name == "size" }
+    if (sizeNode)
+      doAsMapping = true
+    else
+      System.err.println ("Warning: class ${fullClassName} has an inconsistent operator set. To get a as_mapping you must implement 'size' as well as operator[]")
+  }
+
+  if (doComparator){
+%>
+  static int ${module.@name}_${classNameAsVariable}_cmp(PyObject* obj1, PyObject* obj2)
+  {
+    return PythonCompare<${fullClassName}>::compare(obj1,obj2,"p.${fullClassName}","${Helper.findNamespace(clazz)}","compare on ${fullClassName}");
+  }
+<%
+  }
+
+  if (doAsMapping)
+  {
+%>
+  static Py_ssize_t ${module.@name}_${classNameAsVariable}_size_(PyObject* self)
+  {
+    return (Py_ssize_t)((${fullClassName}*)retrieveApiInstance(self,&Ty${classNameAsVariable}_Type,"${Helper.callingName(indexOp)}","${fullClassName}"))-> size();
+  }
+
+  //=========================================================================
+  // tp_as_mapping struct for ${fullClassName}
+  //=========================================================================
+  PyMappingMethods ${module.@name}_${classNameAsVariable}_as_mapping = {
+    ${module.@name}_${classNameAsVariable}_size_,    /* inquiry mp_length;                  __len__ */
+    (PyCFunction)${module.@name}_${PythonTools.getPyMethodName(indexOp,MethodType.method)},   /* binaryfunc mp_subscript             __getitem__ */
+    0,                  /* objargproc mp_ass_subscript;     __setitem__ */
+  };
+<%
+  }
+
+  if (clazz.@feature_python_rcmp)
+  { %>
+  static PyObject* ${module.@name}_${classNameAsVariable}_rcmp(PyObject* obj1, PyObject *obj2, int method)
+  ${Helper.unescape(clazz.@feature_python_rcmp)}
+<%
+  }
+%>
+  //=========================================================================
+  // This section contains the initialization for the
+  // Python extension for the Api class ${fullClassName}
+  //=========================================================================
+  // All of the methods on this class
+  static PyMethodDef ${classNameAsVariable}_methods[] = { <%
+    normalMethods.each {  %>
+    {(char*)"${it.@sym_name}", (PyCFunction)${module.@name}_${PythonTools.getPyMethodName(it,MethodType.method)}, METH_VARARGS|METH_KEYWORDS, ${Helper.hasDoc(it) ? PythonTools.getPyMethodName(it,MethodType.method) + '__doc__' : 'NULL'} }, <% }
+
+    // now do all of the explicit feature:python:method's that may be in this class
+    List tmpl = []
+    tmpl.addAll(clazz.attributes().keySet())
+    List newMethodKeys = tmpl.findAll { it.startsWith('feature_python_method_') }
+    newMethodKeys.each { key ->
+      String featureEntry = clazz.attribute(key)
+      String methodName = key.substring('feature_python_method_'.length()) %>
+    {(char*)"${methodName}", (PyCFunction)${module.@name}_${PythonTools.getClassNameAsVariable(clazz)}_${methodName}, METH_VARARGS|METH_KEYWORDS, NULL},
+<%
+    }
+%>
+    {NULL, NULL, 0, NULL}
+  };
+
+<%
+  if (properties.size() > 0) {
+%>  static PyObject* ${classNameAsVariable}_getMember(PyHolder *self, void *name)
+  {
+    if (self == NULL)
+      return NULL;
+<%
+    String clazzName = Helper.findFullClassName(properties[0])
+%>
+    try
+    {
+      ${clazzName}* theObj = (${clazzName}*)retrieveApiInstance((PyObject*)self, &Ty${classNameAsVariable}_Type, "${classNameAsVariable}_getMember()", "${clazzName}");
+
+      PyObject* result = NULL;
+   <%
+  properties.each {
+     String returns = Helper.getPropertyReturnSwigType(it);
+%>   if (strcmp((char*)name, "${it.@sym_name}") == 0)
+      {
+        ${SwigTypeParser.SwigType_lstr(returns)} apiResult = (${SwigTypeParser.SwigType_lstr(returns)})theObj->${it.@sym_name};
+        ${Helper.getOutConversion(returns, 'result', it)}
+      }
+      else<%
+  } %>
+      {
+        Py_INCREF(Py_None);
+        return Py_None;
+      }
+
+      return result;
+    }
+    catch (const XBMCAddon::WrongTypeException& e)
+    {
+      CLog::Log(LOGERROR,"EXCEPTION: %s",e.GetMessage());
+      PyErr_SetString(PyExc_TypeError, e.GetMessage());
+      return NULL;
+    }
+    catch (const XbmcCommons::Exception& e)
+    {
+      CLog::Log(LOGERROR,"EXCEPTION: %s",e.GetMessage());
+      PyErr_SetString(PyExc_RuntimeError, e.GetMessage());
+      return NULL;
+    }
+    catch (...)
+    {
+      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"${classNameAsVariable}_getMember()\"");
+      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"${classNameAsVariable}_getMember()\"");
+      return NULL;
+    }
+
+    return NULL;
+  }
+
+<%
+    if (properties_set.size() > 0) {
+%>  int ${classNameAsVariable}_setMember(PyHolder *self, PyObject *value, void *name)
+  {
+    if (self == NULL)
+      return -1;
+
+    ${clazzName}* theObj = NULL;
+    try
+    {
+      theObj = (${clazzName}*)retrieveApiInstance((PyObject*)self, &Ty${classNameAsVariable}_Type, "${classNameAsVariable}_getMember()", "${clazzName}");
+    }
+    catch (const XBMCAddon::WrongTypeException& e)
+    {
+      CLog::Log(LOGERROR,"EXCEPTION: %s",e.GetMessage());
+      PyErr_SetString(PyExc_TypeError, e.GetMessage());
+      return -1;
+    }
+    catch (const XbmcCommons::Exception& e)
+    {
+      CLog::Log(LOGERROR,"EXCEPTION: %s",e.GetMessage());
+      PyErr_SetString(PyExc_RuntimeError, e.GetMessage());
+      return -1;
+    }
+    catch (...)
+    {
+      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"${classNameAsVariable}_getMember()\"");
+      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"${classNameAsVariable}_getMember()\"");
+      return -1;
+    }
+
+<%
+  properties_set.each {
+     String returns = Helper.getPropertyReturnSwigType(it);
+%>   if (strcmp((char*)name, "${it.@sym_name}") == 0)
+      {
+        ${SwigTypeParser.SwigType_lstr(returns)} tmp;
+        ${Helper.getInConversion(returns, 'tmp', 'value', it)}
+        if (PyErr_Occurred())
+          throw PythonBindings::PythonToCppException();
+
+        theObj->${it.@sym_name} = tmp;
+      }
+      else<%
+  } %>
+        return -1;
+
+    return 0;
+  } <%
+    }
+%>
+
+  // All of the methods on this class
+  static PyGetSetDef ${classNameAsVariable}_getsets[] = { <%
+    properties.each {  %>
+    {(char*)"${it.@sym_name}", (getter)${classNameAsVariable}_getMember, ${(it.@feature_immutable == null || it.@feature_immutable == 0) ? '(setter)' + classNameAsVariable + '_setMember' : 'NULL'}, (char*)${Helper.hasDoc(it) ? PythonTools.makeDocString(it.doc[0]) : 'NULL'}, (char*)"${it.@sym_name}" }, <% }
+%>
+    {NULL}
+  };
+<%
+  }
+
+  if ((clazz.@feature_iterator && clazz.@feature_iterator != '') ||
+      (clazz.@feature_iterable && clazz.@feature_iterable != '')) { %>
+  static PyObject* ${module.@name}_${classNameAsVariable}_iter(PyObject* self)
+  { <%
+    if (clazz.@feature_iterator) { %>
+    return self; <%
+    }
+    else { %>
+    PyObject* result = NULL;
+    try
+    {
+      ${clazz.@feature_iterable}* apiResult = ((${fullClassName}*)retrieveApiInstance(self,&Ty${classNameAsVariable}_Type,"${module.@name}_${classNameAsVariable}_iternext","${fullClassName}"))->begin();
+
+      ${Helper.getOutConversion('p.' + clazz.@feature_iterable,'result',clazz)}
+    }
+    catch (const XBMCAddon::WrongTypeException& e)
+    {
+      CLog::Log(LOGERROR,"EXCEPTION: %s",e.GetMessage());
+      PyErr_SetString(PyExc_TypeError, e.GetMessage());
+      return NULL;
+    }
+    catch (const XbmcCommons::Exception& e)
+    {
+      CLog::Log(LOGERROR,"EXCEPTION: %s",e.GetMessage());
+      PyErr_SetString(PyExc_RuntimeError, e.GetMessage());
+      return NULL;
+    }
+    catch (...)
+    {
+      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"${module.@name}_${classNameAsVariable}_iternext\"");
+      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"${module.@name}_${classNameAsVariable}_iternext\"");
+      return NULL;
+    }
+
+    return result; <%
+    } %>
+  }
+<%
+
+    if (clazz.@feature_iterator) { %>
+  static PyObject* ${module.@name}_${classNameAsVariable}_iternext(PyObject* self)
+  {
+    PyObject* result = NULL;
+    try
+    {
+      ${fullClassName}* iter = (${fullClassName}*)retrieveApiInstance(self,&Ty${classNameAsVariable}_Type,"${module.@name}_${classNameAsVariable}_iternext","${fullClassName}");
+
+      // check if we have reached the end
+      if (!iter->end())
+      {
+        ++(*iter);
+
+        ${clazz.@feature_iterator} apiResult = **iter;
+        ${Helper.getOutConversion(clazz.@feature_iterator,'result',clazz)}
+      }
+    }
+    catch (const XBMCAddon::WrongTypeException& e)
+    {
+      CLog::Log(LOGERROR,"EXCEPTION: %s",e.GetMessage());
+      PyErr_SetString(PyExc_TypeError, e.GetMessage());
+      return NULL;
+    }
+    catch (const XbmcCommons::Exception& e)
+    {
+      CLog::Log(LOGERROR,"EXCEPTION: %s",e.GetMessage());
+      PyErr_SetString(PyExc_RuntimeError, e.GetMessage());
+      return NULL;
+    }
+    catch (...)
+    {
+      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"${module.@name}_${classNameAsVariable}_iternext\"");
+      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"${module.@name}_${classNameAsVariable}_iternext\"");
+      return NULL;
+    }
+
+    return result;
+  }
+<%
+    }
+  }
+%>
+
+  // This method initializes the above mentioned Python Type structure
+  static void ${initTypeCall}()
+  {
+<%
+    if (Helper.hasDoc(clazz))
+    {
+%>
+    PyDoc_STRVAR(${classNameAsVariable}__doc__,
+                 ${PythonTools.makeDocString(clazz.doc[0])}
+                );
+<%  } %>
+
+    PyTypeObject& pythonType = Ty${classNameAsVariable}_Type.pythonType;
+    pythonType.tp_name = (char*)"${module.@name}.${clazz.@sym_name}";
+    pythonType.tp_basicsize = sizeof(PyHolder);
+    pythonType.tp_dealloc = (destructor)${module.@name}_${classNameAsVariable}_Dealloc; <%
+
+  if (clazz.@feature_python_rcmp) { %>
+    pythonType.tp_richcompare=(richcmpfunc)${module.@name}_${classNameAsVariable}_rcmp;<%
+  } %>
+
+    pythonType.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE;
+
+    pythonType.tp_doc = ${Helper.hasDoc(clazz) ? (classNameAsVariable + '__doc__') : 'NULL' };
+    pythonType.tp_methods = ${classNameAsVariable}_methods; <%
+  if (properties.size() > 0) { %>
+    pythonType.tp_getset = ${classNameAsVariable}_getsets;
+<%
+  }
+  if (callableOp) { %>
+    pythonType.tp_call = (ternaryfunc)${module.@name}_${PythonTools.getPyMethodName(callableOp,MethodType.method)};
+<%
+  }
+  if (doAsMapping) { %>
+    pythonType.tp_as_mapping = &${module.@name}_${classNameAsVariable}_as_mapping;
+<%
+  }
+
+  if (clazz.@feature_iterator) { %>
+    pythonType.tp_iter = (getiterfunc)${module.@name}_${classNameAsVariable}_iter;
+    pythonType.tp_iternext = (iternextfunc)${module.@name}_${classNameAsVariable}_iternext;
+<%
+  }
+  else if (clazz.@feature_iterable && clazz.@feature_iterable != '') { %>
+    pythonType.tp_iter = (getiterfunc)${module.@name}_${classNameAsVariable}_iter;
+<%
+  }
+
+  Node baseclass = PythonTools.findValidBaseClass(clazz, module)
+%>
+
+    pythonType.tp_base = ${baseclass ? ('&(Ty' + PythonTools.getClassNameAsVariable(baseclass) + '_Type.pythonType)') : "NULL"};
+    pythonType.tp_new = <% Helper.hasHiddenConstructor(clazz) ? print('NULL') : print("${module.@name}_${classNameAsVariable}_New") %>;
+
+    Ty${classNameAsVariable}_Type.swigType="p.${fullClassName}";<%
+  if (baseclass) { %>
+    Ty${classNameAsVariable}_Type.parentType=&Ty${PythonTools.getClassNameAsVariable(baseclass)}_Type;
+<%}
+
+  if (!Helper.hasHiddenConstructor(clazz)) { %>
+    registerAddonClassTypeInformation(&Ty${classNameAsVariable}_Type);
+<%} %>
+  }
+  //=========================================================================
+<%
+}
+/*******************************************************************************/
+
+
+List getAllVirtualMethods(Node clazz)
+{
+  List ret = []
+  ret.addAll(clazz.findAll({ it.name() == 'function' && it.@storage && it.@storage == 'virtual' }))
+  if (clazz.baselist) {
+    if (clazz.baselist[0].base) clazz.baselist[0].base.each {
+        Node baseclassnode = Helper.findClassNodeByName(module,it.@name,clazz)
+        if (baseclassnode && baseclassnode.@feature_director) ret.addAll(getAllVirtualMethods(baseclassnode))
+      }
+  }
+  return ret;
+}
+
+%>
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with Kodi; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+// ************************************************************************
+// This file was generated by xbmc compile process. DO NOT EDIT!!
+//  It was created by running the code generator on the spec file for
+//  the module "${module.@name}" on the template file PythonSwig.template.cpp
+// ************************************************************************
+
+<%
+Helper.getInsertNodes(module, 'begin').each { %>${Helper.unescape(it)}<% }
+%>
+
+#include <Python.h>
+#include <string>
+#include "interfaces/python/LanguageHook.h"
+#include "interfaces/python/swig.h"
+#include "interfaces/python/PyContext.h"
+
+<%
+Helper.getInsertNodes(module, 'header').each { %>${Helper.unescape(it)}<% }
+%>
+
+namespace PythonBindings
+{
+<%
+  // initTypeCalls is the
+  List initTypeCalls = []
+  List classNameAsVariables = []
+
+  classes.each { clazz -> doClassTypeInfo(clazz, classNameAsVariables) }
+
+  // make sure known api types are declared as externs
+
+  // first, find all of the declared known api types
+  Set<String> knownApiTypes = new HashSet<String>()
+  module.depthFirst().each
+  {
+    String attr = it.attribute('feature_knownapitypes')
+    if (attr != null)
+    {
+      attr.trim().split(',').each { knownApiTypes.add(it) }
+    }
+  }
+
+  // now declare an extern for each one
+  knownApiTypes.each { doExternClassTypeInfo(it) }
+
+%>
+
+<%
+//=========================================================================
+// Do the directors. For every class that can be extended in python, we
+// need to create a Director instance with bridging calls. This chunk of
+// code will generate those classes.
+  classes.findAll({ it.@feature_director != null }).each { clazz ->
+    // find the constructor for this class
+    constructor = clazz.constructor[0]
+%>
+  //=========================================================================
+  // This class is the Director for ${Helper.findFullClassName(clazz)}.
+  // It provides the "reverse bridge" from C++ to Python to support
+  // cross-language polymorphism.
+  //=========================================================================
+  class ${PythonTools.getClassNameAsVariable(clazz)}_Director : public Director, public ${clazz.@name}
+  {
+    public:
+<%
+      if (constructor)
+      {%>
+      inline ${PythonTools.getClassNameAsVariable(clazz)}_Director(<%
+        List params = constructor?.parm
+        params.eachWithIndex { param, i -> %>${SwigTypeParser.SwigType_str(param.@type)} ${param.@name}${i < params.size() - 1 ? "," : ""} <% }
+        %>) : ${Helper.findFullClassName(constructor)}(<%
+        params.eachWithIndex { param, i -> %> ${param.@name}${i < params.size() - 1 ? "," : ""} <% } %>) { } <%
+      }
+%>
+<%
+      getAllVirtualMethods(clazz).each
+      { %>
+      virtual ${SwigTypeParser.SwigType_str(Helper.getReturnSwigType(it))} ${Helper.callingName(it)}( <%
+    List params = it?.parm
+    String paramFormatStr = ''
+    params.each { paramFormatStr += 'O' }
+    params.eachWithIndex { param, i -> %> ${SwigTypeParser.SwigType_str(param.@type)} ${param.@name}${i < params.size() - 1 ? "," : ""} <% }
+    %> )
+      { <%
+        params.each
+        { param ->
+          %>
+        PyObject* py${param.@name} = NULL;
+        ${Helper.getOutConversion(param.@type,'result',it,['result' : 'py' + param.@name, 'api' : param.@name])}<%
+        }
+%>
+        XBMCAddon::Python::PyContext pyContext;
+        PyObject_CallMethod(self,(char*)"${Helper.callingName(it)}",(char*)"(${paramFormatStr})"<%
+          params.each {
+             %>, py${it.@name} <%
+          }
+        %>);
+        if (PyErr_Occurred())
+          throw PythonBindings::PythonToCppException();
+      }
+<%    }
+
+%>
+  };
+<%
+  }
+//=========================================================================
+
+  // types used as method parameter or return values need to be declared
+  // as extern if they are unknown types.
+  methods.each { if (it.name() != 'destructor') { doMethod(it, (it.name() == 'constructor' ? MethodType.constructor : MethodType.method)); println(); } }
+  classes.each { clazz -> doMethod(clazz, MethodType.destructor) }
+
+  // now find any methods that have been added explicitly
+  classes.each { node ->
+    List tmpl = []
+    tmpl.addAll(node.attributes().keySet())
+    List newMethodKeys = tmpl.findAll { it.startsWith('feature_python_method_') }
+    newMethodKeys.each { key ->
+      String featureEntry = node.attribute(key)
+      String methodName = key.substring('feature_python_method_'.length()) %>
+  static PyObject* ${module.@name}_${PythonTools.getClassNameAsVariable(node)}_${methodName}(PyObject* self, PyObject *args, PyObject *kwds)
+  ${Helper.unescape(featureEntry)}
+<%
+    }
+  }
+
+  classes.each { clazz -> doClassMethodInfo(clazz, initTypeCalls) }
+
+%>
+
+  static PyMethodDef ${module.@name}_methods[] = { <%
+    module.depthFirst().findAll({ it.name() == 'function' && Helper.parents(it, { Node lnode -> lnode.name() == 'class'}).size() == 0 }).each {  %>
+    {(char*)"${it.@sym_name}", (PyCFunction)${module.@name}_${PythonTools.getPyMethodName(it,MethodType.method)}, METH_VARARGS|METH_KEYWORDS, ${Helper.hasDoc(it) ? PythonTools.getPyMethodName(it,MethodType.method) + '__doc__' : 'NULL'} }, <% }
+%>
+    {NULL, NULL, 0, NULL}
+  };
+
+  // This is the call that will call all of the other initializes
+  //  for all of the classes in this module
+  static void initTypes()
+  {
+    static bool typesAlreadyInitialized = false;
+    if (!typesAlreadyInitialized)
+    {
+      typesAlreadyInitialized = true;
+<%
+      initTypeCalls.each { %>
+      ${it}();<%
+      }
+
+      classNameAsVariables.each { %>
+      if (PyType_Ready(&(Ty${it}_Type.pythonType)) < 0)
+        return;<%
+      }%>
+    }
+  }
+
+  void initModule_${module.@name}()
+  {
+    initTypes();
+
+    // init general ${module.@name} modules
+    PyObject* module;
+
+<% classNameAsVariables.each { %>
+    Py_INCREF(&(Ty${it}_Type.pythonType));<%
+   }%>
+    static struct PyModuleDef nameAsVariable
+    {
+        PyModuleDef_HEAD_INIT,
+        (char*)"${module.@name}",
+        "",
+        -1,
+        ${module.@name}_methods
+    };
+    module = PyModule_Create(&nameAsVariable);
+    if (module == NULL) return;
+
+<% classes.each { clazz -> %>
+    PyModule_AddObject(module, (char*)"${clazz.@sym_name}", (PyObject*)(&(Ty${PythonTools.getClassNameAsVariable(clazz)}_Type.pythonType)));<%
+   }%>
+
+   // constants
+   PyModule_AddStringConstant(module, (char*)"__author__", (char*)"Team Kodi <http://kodi.tv>");
+   PyModule_AddStringConstant(module, (char*)"__date__", (char*)"${new Date().toString()}");
+   PyModule_AddStringConstant(module, (char*)"__version__", (char*)"2.25.0");
+   PyModule_AddStringConstant(module, (char*)"__credits__", (char*)"Team Kodi");
+   PyModule_AddStringConstant(module, (char*)"__platform__", (char*)"ALL");
+
+   // need to handle constants
+<% module.depthFirst().findAll( { it.name() == 'constant'} ).each {
+     String pyCall =
+        (it.@type == 'int' || it.@type == 'long' || it.@type == 'unsigned int' || it.@type == 'unsigned long' || it.@type == 'bool') ?
+        'PyModule_AddIntConstant' : 'PyModule_AddStringConstant' %>
+   ${pyCall}(module,"${it.@sym_name}",${it.@value}); <%
+  } %>
+  }
+
+} // end PythonBindings namespace for python type definitions
+
+<%
+Helper.getInsertNodes(module, 'footer').each { %>${Helper.unescape(it)}<% }
+%>
diff --git a/xbmc/interfaces/python3/PythonTools.groovy b/xbmc/interfaces/python3/PythonTools.groovy
new file mode 100644
index 000000000000..0d1bd70654d1
--- /dev/null
+++ b/xbmc/interfaces/python3/PythonTools.groovy
@@ -0,0 +1,152 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+import Helper
+import SwigTypeParser
+
+public class PythonTools
+{
+   /**
+    * This array defines a mapping of the api spec type to the python parse format character.
+    *  By default, if a lookup here results in 'null' then the format char is 'O'
+    */
+   private static Map ltypeToFormatChar = [
+      'p.char':"s", bool:"b",
+      int:"i", 'unsigned int' : 'I',
+      long:"l", 'unsigned long' : 'k',
+      'double':"d", 'float':"f",
+      'long long' : "L"
+   ]
+
+   /**
+    * if the parameter can be directly read from python then its type should be in the ltypeToFormatChar
+    *  otherwise we need an intermediate pyobject
+    */
+   public static boolean parameterCanBeUsedDirectly(Node param) { return ltypeToFormatChar[SwigTypeParser.convertTypeToLTypeForParam(param.@type)] != null }
+
+   /**
+    * This method will take the parameter list from the method node passed
+    * and will convert it to a Python argument string for PyArg_ParseTupleAndKeywords
+    */
+   public static String makeFormatStringFromParameters(Node method)
+   {
+      if (!method)
+        return ''
+      List params = method.parm
+      String format = ""
+      boolean previousDefaulted = false
+      params.eachWithIndex { param, i ->
+         String defaultValue = param.@value
+         String paramtype = SwigTypeParser.convertTypeToLTypeForParam(param.@type)
+         String curFormat = ltypeToFormatChar[paramtype];
+         if (curFormat == null) // then we will assume it's an object
+            curFormat = "O";
+
+         if (defaultValue != null && !previousDefaulted)
+         {
+            format +="|"
+            previousDefaulted = true
+         }
+         format += curFormat
+      }
+      return format;
+   }
+
+   /**
+    * This method gets the FULL class name as a variable including the 
+    * namespace. If converts all of the '::' references to '_' so 
+    * that the result can be used in part, or in whole, as a variable name
+    */
+   public static String getClassNameAsVariable(Node clazz) { return Helper.findFullClassName(clazz).replaceAll('::','_') }
+
+   public static String getPyMethodName(Node method, MethodType methodType)
+   {
+      String clazz = Helper.findFullClassName(method)?.replaceAll('::','_')
+
+      // if we're not in a class then this must be a method node
+      assert (clazz != null || methodType == MethodType.method), 'Cannot use a non-class function as a constructor or destructor ' + method
+
+      // it's ok to pass a 'class' node if the methodType is either constructor or destructor
+      assert (method.name() != 'class' || (methodType == MethodType.constructor || methodType == MethodType.destructor))
+
+      // if this is a constructor node then the methodtype best reflect that
+      assert (method.name() != 'constructor' || methodType == MethodType.constructor), 'Cannot use a constructor node and not identify the type as a constructor' + method
+
+      // if this is a destructor node then the methodtype best reflect that
+      assert (method.name() != 'destructor' || methodType == MethodType.destructor), 'Cannot use a destructor node and not identify the type as a destructor' + method
+
+      if (clazz == null)
+        return method.@sym_name
+
+      if (methodType == MethodType.constructor)
+        return clazz + "_New"
+
+      if (methodType == MethodType.destructor)
+        return clazz + "_Dealloc"
+
+      if (method.@name.startsWith("operator "))
+      {
+        if ("[]" == method.@name.substring(9))
+          return clazz + "_operatorIndex_"
+
+        if ("()" == method.@name.substring(9))
+          return clazz + "_callable_"
+      }
+
+      return clazz + "_" + method.@sym_name;
+   }
+
+  public static String makeDocString(Node docnode)
+  { 
+    if (docnode?.name() != 'doc')
+      throw new RuntimeException("Invalid doc Node passed to PythonTools.makeDocString (" + docnode + ")")
+
+    String[] lines = (docnode.@value).split(Helper.newline)
+    def ret = ''
+    lines.eachWithIndex { val, index -> 
+      val = ((val =~ /\\n/).replaceAll('')) // remove extraneous \n's 
+      val = val.replaceAll("\\\\","\\\\\\\\") // escape backslash
+      val = ((val =~ /\"/).replaceAll("\\\\\"")) // escape quotes
+      ret += ('"' + val + '\\n"' + (index != lines.length - 1 ? Helper.newline : ''))
+    }
+
+    return ret
+  }
+
+  public static Node findValidBaseClass(Node clazz, Node module, boolean warn = false)
+  {
+    // I need to find the base type if there is a known class with it
+    assert clazz.baselist.size() < 2, "${clazz} has multiple baselists - need to write code to separate out the public one."
+    String baseclass = 'NULL'
+    List knownbases = []
+    if (clazz.baselist)
+    { 
+      if (clazz.baselist[0].base) clazz.baselist[0].base.each {
+          Node baseclassnode = Helper.findClassNodeByName(module,it.@name,clazz)
+          if (baseclassnode) knownbases.add(baseclassnode)
+          else if (warn && !Helper.isKnownBaseType(it.@name,clazz))
+            System.out.println("WARNING: the base class ${it.@name} for ${Helper.findFullClassName(clazz)} is unrecognized within ${module.@name}.")
+        }
+    }
+    assert knownbases.size() < 2, 
+      "The class ${Helper.findFullClassName(clazz)} has too many known base classes. Multiple inheritance isn't supported in the code generator. Please \"#ifdef SWIG\" out all but one."
+    return knownbases.size() > 0 ? knownbases[0] : null
+  }
+}
diff --git a/xbmc/interfaces/python3/XBPython.cpp b/xbmc/interfaces/python3/XBPython.cpp
new file mode 100644
index 000000000000..6227f261e24d
--- /dev/null
+++ b/xbmc/interfaces/python3/XBPython.cpp
@@ -0,0 +1,704 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+// python.h should always be included first before any other includes
+#include <Python.h>
+
+#include <algorithm>
+
+#include "system.h"
+#include "cores/DllLoader/DllLoaderContainer.h"
+#include "GUIPassword.h"
+#include "XBPython.h"
+#include "filesystem/File.h"
+#include "filesystem/SpecialProtocol.h"
+#include "utils/JSONVariantWriter.h"
+#include "utils/log.h"
+#include "utils/Variant.h"
+#include "Util.h"
+#ifdef TARGET_WINDOWS
+#include "utils/Environment.h"
+#endif
+#include "settings/AdvancedSettings.h"
+
+#include "threads/SystemClock.h"
+#include "interfaces/AnnouncementManager.h"
+
+#include "interfaces/legacy/Monitor.h"
+#include "interfaces/legacy/AddonUtils.h"
+#include "interfaces/python/AddonPythonInvoker.h"
+#include "interfaces/python/PythonInvoker.h"
+
+using namespace ANNOUNCEMENT;
+
+XBPython::XBPython()
+{
+  m_bInitialized      = false;
+  m_mainThreadState   = NULL;
+  m_ThreadId          = CThread::GetCurrentThreadId();
+  m_iDllScriptCounter = 0;
+  m_endtime           = 0;
+  m_pDll              = NULL;
+  m_vecPlayerCallbackList.clear();
+  m_vecMonitorCallbackList.clear();
+
+  CAnnouncementManager::GetInstance().AddAnnouncer(this);
+}
+
+XBPython::~XBPython()
+{
+  XBMC_TRACE;
+  CAnnouncementManager::GetInstance().RemoveAnnouncer(this);
+}
+
+#define LOCK_AND_COPY(type, dest, src) \
+  if (!m_bInitialized) return; \
+  CSingleLock lock(src); \
+  src.hadSomethingRemoved = false; \
+  type dest; \
+  dest = src
+
+#define CHECK_FOR_ENTRY(l,v) \
+  (l.hadSomethingRemoved ? (std::find(l.begin(),l.end(),v) != l.end()) : true)
+
+void XBPython::Announce(AnnouncementFlag flag, const char *sender, const char *message, const CVariant &data)
+{
+  if (flag & VideoLibrary)
+  {
+   if (strcmp(message, "OnScanFinished") == 0)
+     OnScanFinished("video");
+   else if (strcmp(message, "OnScanStarted") == 0)
+     OnScanStarted("video");
+   else if (strcmp(message, "OnCleanStarted") == 0)
+     OnCleanStarted("video");
+   else if (strcmp(message, "OnCleanFinished") == 0)
+     OnCleanFinished("video");
+  }
+  else if (flag & AudioLibrary)
+  {
+   if (strcmp(message, "OnScanFinished") == 0)
+     OnScanFinished("music");
+   else if (strcmp(message, "OnScanStarted") == 0)
+     OnScanStarted("music");
+   else if (strcmp(message, "OnCleanStarted") == 0)
+     OnCleanStarted("music");
+   else if (strcmp(message, "OnCleanFinished") == 0)
+     OnCleanFinished("music");
+  }
+  else if (flag & GUI)
+  {
+   if (strcmp(message, "OnScreensaverDeactivated") == 0)
+     OnScreensaverDeactivated();
+   else if (strcmp(message, "OnScreensaverActivated") == 0)
+     OnScreensaverActivated();
+   else if (strcmp(message, "OnDPMSDeactivated") == 0)
+     OnDPMSDeactivated();
+   else if (strcmp(message, "OnDPMSActivated") == 0)
+     OnDPMSActivated();
+  }
+
+  std::string jsonData;
+  if (CJSONVariantWriter::Write(data, jsonData, g_advancedSettings.m_jsonOutputCompact))
+    OnNotification(sender, std::string(ANNOUNCEMENT::AnnouncementFlagToString(flag)) + "." + std::string(message), jsonData);
+}
+
+// message all registered callbacks that we started playing
+void XBPython::OnPlayBackStarted()
+{
+  XBMC_TRACE;
+  LOCK_AND_COPY(std::vector<PVOID>,tmp,m_vecPlayerCallbackList);
+  for (PlayerCallbackList::iterator it = tmp.begin(); (it != tmp.end()); ++it)
+  {
+    if (CHECK_FOR_ENTRY(m_vecPlayerCallbackList,(*it)))
+      ((IPlayerCallback*)(*it))->OnPlayBackStarted();
+  }
+}
+
+// message all registered callbacks that we paused playing
+void XBPython::OnPlayBackPaused()
+{
+  XBMC_TRACE;
+  LOCK_AND_COPY(std::vector<PVOID>,tmp,m_vecPlayerCallbackList);
+  for (PlayerCallbackList::iterator it = tmp.begin(); (it != tmp.end()); ++it)
+  {
+    if (CHECK_FOR_ENTRY(m_vecPlayerCallbackList,(*it)))
+      ((IPlayerCallback*)(*it))->OnPlayBackPaused();
+  }
+}
+
+// message all registered callbacks that we resumed playing
+void XBPython::OnPlayBackResumed()
+{
+  XBMC_TRACE;
+  LOCK_AND_COPY(std::vector<PVOID>,tmp,m_vecPlayerCallbackList);
+  for (PlayerCallbackList::iterator it = tmp.begin(); (it != tmp.end()); ++it)
+  {
+    if (CHECK_FOR_ENTRY(m_vecPlayerCallbackList,(*it)))
+      ((IPlayerCallback*)(*it))->OnPlayBackResumed();
+  }
+}
+
+// message all registered callbacks that xbmc stopped playing
+void XBPython::OnPlayBackEnded()
+{
+  XBMC_TRACE;
+  LOCK_AND_COPY(std::vector<PVOID>,tmp,m_vecPlayerCallbackList);
+  for (PlayerCallbackList::iterator it = tmp.begin(); (it != tmp.end()); ++it)
+  {
+    if (CHECK_FOR_ENTRY(m_vecPlayerCallbackList,(*it)))
+      ((IPlayerCallback*)(*it))->OnPlayBackEnded();
+  }
+}
+
+// message all registered callbacks that user stopped playing
+void XBPython::OnPlayBackStopped()
+{
+  XBMC_TRACE;
+  LOCK_AND_COPY(std::vector<PVOID>,tmp,m_vecPlayerCallbackList);
+  for (PlayerCallbackList::iterator it = tmp.begin(); (it != tmp.end()); ++it)
+  {
+    if (CHECK_FOR_ENTRY(m_vecPlayerCallbackList,(*it)))
+      ((IPlayerCallback*)(*it))->OnPlayBackStopped();
+  }
+}
+
+// message all registered callbacks that playback speed changed (FF/RW)
+void XBPython::OnPlayBackSpeedChanged(int iSpeed)
+{
+  XBMC_TRACE;
+  LOCK_AND_COPY(std::vector<PVOID>,tmp,m_vecPlayerCallbackList);
+  for (PlayerCallbackList::iterator it = tmp.begin(); (it != tmp.end()); ++it)
+  {
+    if (CHECK_FOR_ENTRY(m_vecPlayerCallbackList,(*it)))
+      ((IPlayerCallback*)(*it))->OnPlayBackSpeedChanged(iSpeed);
+  }
+}
+
+// message all registered callbacks that player is seeking
+void XBPython::OnPlayBackSeek(int64_t iTime, int64_t seekOffset)
+{
+  XBMC_TRACE;
+  LOCK_AND_COPY(std::vector<PVOID>,tmp,m_vecPlayerCallbackList);
+  for (PlayerCallbackList::iterator it = tmp.begin(); (it != tmp.end()); ++it)
+  {
+    if (CHECK_FOR_ENTRY(m_vecPlayerCallbackList,(*it)))
+      ((IPlayerCallback*)(*it))->OnPlayBackSeek(iTime, seekOffset);
+  }
+}
+
+// message all registered callbacks that player chapter seeked
+void XBPython::OnPlayBackSeekChapter(int iChapter)
+{
+  XBMC_TRACE;
+  LOCK_AND_COPY(std::vector<PVOID>,tmp,m_vecPlayerCallbackList);
+  for (PlayerCallbackList::iterator it = tmp.begin(); (it != tmp.end()); ++it)
+  {
+    if (CHECK_FOR_ENTRY(m_vecPlayerCallbackList,(*it)))
+      ((IPlayerCallback*)(*it))->OnPlayBackSeekChapter(iChapter);
+  }
+}
+
+// message all registered callbacks that next item has been queued
+void XBPython::OnQueueNextItem()
+{
+  XBMC_TRACE;
+  LOCK_AND_COPY(std::vector<PVOID>,tmp,m_vecPlayerCallbackList);
+  for (PlayerCallbackList::iterator it = tmp.begin(); (it != tmp.end()); ++it)
+  {
+    if (CHECK_FOR_ENTRY(m_vecPlayerCallbackList,(*it)))
+      ((IPlayerCallback*)(*it))->OnQueueNextItem();
+  }
+}
+
+void XBPython::RegisterPythonPlayerCallBack(IPlayerCallback* pCallback)
+{
+  XBMC_TRACE;
+  CSingleLock lock(m_vecPlayerCallbackList);
+  m_vecPlayerCallbackList.push_back(pCallback);
+}
+
+void XBPython::UnregisterPythonPlayerCallBack(IPlayerCallback* pCallback)
+{
+  XBMC_TRACE;
+  CSingleLock lock(m_vecPlayerCallbackList);
+  PlayerCallbackList::iterator it = m_vecPlayerCallbackList.begin();
+  while (it != m_vecPlayerCallbackList.end())
+  {
+    if (*it == pCallback)
+    {
+      it = m_vecPlayerCallbackList.erase(it);
+      m_vecPlayerCallbackList.hadSomethingRemoved = true;
+    }
+    else
+      ++it;
+  }
+}
+
+void XBPython::RegisterPythonMonitorCallBack(XBMCAddon::xbmc::Monitor* pCallback)
+{
+  XBMC_TRACE;
+  CSingleLock lock(m_vecMonitorCallbackList);
+  m_vecMonitorCallbackList.push_back(pCallback);
+}
+
+void XBPython::UnregisterPythonMonitorCallBack(XBMCAddon::xbmc::Monitor* pCallback)
+{
+  XBMC_TRACE;
+  CSingleLock lock(m_vecMonitorCallbackList);
+  MonitorCallbackList::iterator it = m_vecMonitorCallbackList.begin();
+  while (it != m_vecMonitorCallbackList.end())
+  {
+    if (*it == pCallback)
+    {
+      it = m_vecMonitorCallbackList.erase(it);
+      m_vecMonitorCallbackList.hadSomethingRemoved = true;
+    }
+    else
+      ++it;
+  }
+}
+
+void XBPython::OnSettingsChanged(const std::string &ID)
+{
+  XBMC_TRACE;
+  LOCK_AND_COPY(std::vector<XBMCAddon::xbmc::Monitor*>,tmp,m_vecMonitorCallbackList);
+  for (MonitorCallbackList::iterator it = tmp.begin(); (it != tmp.end()); ++it)
+  {
+    if (CHECK_FOR_ENTRY(m_vecMonitorCallbackList,(*it)) && ((*it)->GetId() == ID))
+      (*it)->OnSettingsChanged();
+  }
+}
+
+void XBPython::OnScreensaverActivated()
+{
+  XBMC_TRACE;
+  LOCK_AND_COPY(std::vector<XBMCAddon::xbmc::Monitor*>,tmp,m_vecMonitorCallbackList);
+  for (MonitorCallbackList::iterator it = tmp.begin(); (it != tmp.end()); ++it)
+  {
+    if (CHECK_FOR_ENTRY(m_vecMonitorCallbackList,(*it)))
+      (*it)->OnScreensaverActivated();
+  }
+}
+
+void XBPython::OnScreensaverDeactivated()
+{
+  XBMC_TRACE;
+  LOCK_AND_COPY(std::vector<XBMCAddon::xbmc::Monitor*>,tmp,m_vecMonitorCallbackList);
+  for (MonitorCallbackList::iterator it = tmp.begin(); (it != tmp.end()); ++it)
+  {
+    if (CHECK_FOR_ENTRY(m_vecMonitorCallbackList,(*it)))
+      (*it)->OnScreensaverDeactivated();
+  }
+}
+
+void XBPython::OnDPMSActivated()
+{
+  XBMC_TRACE;
+  LOCK_AND_COPY(std::vector<XBMCAddon::xbmc::Monitor*>,tmp,m_vecMonitorCallbackList);
+  for (MonitorCallbackList::iterator it = tmp.begin(); (it != tmp.end()); ++it)
+  {
+    if (CHECK_FOR_ENTRY(m_vecMonitorCallbackList,(*it)))
+      (*it)->OnDPMSActivated();
+  }
+}
+
+void XBPython::OnDPMSDeactivated()
+{
+  XBMC_TRACE;
+  LOCK_AND_COPY(std::vector<XBMCAddon::xbmc::Monitor*>,tmp,m_vecMonitorCallbackList);
+  for (MonitorCallbackList::iterator it = tmp.begin(); (it != tmp.end()); ++it)
+  {
+    if (CHECK_FOR_ENTRY(m_vecMonitorCallbackList,(*it)))
+      (*it)->OnDPMSDeactivated();
+  }
+}
+
+void XBPython::OnScanStarted(const std::string &library)
+{
+  XBMC_TRACE;
+  LOCK_AND_COPY(std::vector<XBMCAddon::xbmc::Monitor*>,tmp,m_vecMonitorCallbackList);
+  for (MonitorCallbackList::iterator it = tmp.begin(); (it != tmp.end()); ++it)
+  {
+    if (CHECK_FOR_ENTRY(m_vecMonitorCallbackList,(*it)))
+      (*it)->OnScanStarted(library);
+  }
+}
+
+void XBPython::OnScanFinished(const std::string &library)
+{
+  XBMC_TRACE;
+  LOCK_AND_COPY(std::vector<XBMCAddon::xbmc::Monitor*>,tmp,m_vecMonitorCallbackList);
+  for (MonitorCallbackList::iterator it = tmp.begin(); (it != tmp.end()); ++it)
+  {
+    if (CHECK_FOR_ENTRY(m_vecMonitorCallbackList,(*it)))
+      (*it)->OnScanFinished(library);
+  }
+}
+
+void XBPython::OnCleanStarted(const std::string &library)
+{
+  XBMC_TRACE;
+  LOCK_AND_COPY(std::vector<XBMCAddon::xbmc::Monitor*>,tmp,m_vecMonitorCallbackList);
+  for (MonitorCallbackList::iterator it = tmp.begin(); (it != tmp.end()); ++it)
+  {
+    if (CHECK_FOR_ENTRY(m_vecMonitorCallbackList,(*it)))
+      (*it)->OnCleanStarted(library);
+  }
+}
+
+void XBPython::OnCleanFinished(const std::string &library)
+{
+  XBMC_TRACE;
+  LOCK_AND_COPY(std::vector<XBMCAddon::xbmc::Monitor*>,tmp,m_vecMonitorCallbackList);
+  for (MonitorCallbackList::iterator it = tmp.begin(); (it != tmp.end()); ++it)
+  {
+    if (CHECK_FOR_ENTRY(m_vecMonitorCallbackList,(*it)))
+      (*it)->OnCleanFinished(library);
+  }
+}
+
+void XBPython::OnNotification(const std::string &sender, const std::string &method, const std::string &data)
+{
+  XBMC_TRACE;
+  LOCK_AND_COPY(std::vector<XBMCAddon::xbmc::Monitor*>,tmp,m_vecMonitorCallbackList);
+  for (MonitorCallbackList::iterator it = tmp.begin(); (it != tmp.end()); ++it)
+  {
+    if (CHECK_FOR_ENTRY(m_vecMonitorCallbackList,(*it)))
+      (*it)->OnNotification(sender, method, data);
+  }
+}
+
+/**
+* Check for file and print an error if needed
+*/
+bool XBPython::FileExist(const char* strFile)
+{
+  if (!strFile)
+    return false;
+
+  if (!XFILE::CFile::Exists(strFile))
+  {
+    CLog::Log(LOGERROR, "Python: Cannot find '%s'", strFile);
+    return false;
+  }
+  return true;
+}
+
+void XBPython::RegisterExtensionLib(LibraryLoader *pLib)
+{
+  if (!pLib)
+    return;
+
+  CSingleLock lock(m_critSection);
+
+  CLog::Log(LOGDEBUG, "%s, adding %s (%p)", __FUNCTION__, pLib->GetName(), (void*)pLib);
+  m_extensions.push_back(pLib);
+}
+
+void XBPython::UnregisterExtensionLib(LibraryLoader *pLib)
+{
+  if (!pLib)
+    return;
+
+  CSingleLock lock(m_critSection);
+  CLog::Log(LOGDEBUG, "%s, removing %s (0x%p)", __FUNCTION__, pLib->GetName(), (void *)pLib);
+  PythonExtensionLibraries::iterator iter = m_extensions.begin();
+  while (iter != m_extensions.end())
+  {
+    if (*iter == pLib)
+    {
+      m_extensions.erase(iter);
+      break;
+    }
+    ++iter;
+  }
+}
+
+void XBPython::UnloadExtensionLibs()
+{
+  CLog::Log(LOGDEBUG, "%s, clearing python extension libraries", __FUNCTION__);
+  CSingleLock lock(m_critSection);
+  PythonExtensionLibraries::iterator iter = m_extensions.begin();
+  while (iter != m_extensions.end())
+  {
+      DllLoaderContainer::ReleaseModule(*iter);
+      ++iter;
+  }
+  m_extensions.clear();
+}
+
+// Always called with the lock held on m_critSection
+void XBPython::Finalize()
+{
+  XBMC_TRACE;
+  if (m_bInitialized)
+  {
+    CLog::Log(LOGINFO, "Python, unloading python shared library because no scripts are running anymore");
+
+    // set the m_bInitialized flag before releasing the lock. This will prevent
+    // Other methods that rely on this flag from an incorrect interpretation.
+    m_bInitialized    = false;
+    PyThreadState* curTs = (PyThreadState*)m_mainThreadState;
+    m_mainThreadState = NULL; // clear the main thread state before releasing the lock
+    {
+      CSingleExit exit(m_critSection);
+      PyEval_AcquireLock();
+      PyThreadState_Swap(curTs);
+
+      Py_Finalize();
+      PyEval_ReleaseLock();
+    }
+
+#if !(defined(TARGET_DARWIN) || defined(TARGET_WINDOWS))
+    UnloadExtensionLibs();
+#endif
+
+    // first free all dlls loaded by python, after that unload python (this is done by UnloadPythonDlls
+#if !(defined(TARGET_DARWIN) || defined(TARGET_WINDOWS))
+    DllLoaderContainer::UnloadPythonDlls();
+#endif
+#if defined(TARGET_POSIX) && !defined(TARGET_DARWIN) && !defined(TARGET_FREEBSD)
+    // we can't release it on windows, as this is done in UnloadPythonDlls() for win32 (see above).
+    // The implementation for linux needs looking at - UnloadPythonDlls() currently only searches for "python36.dll"
+    // The implementation for osx can never unload the python dylib.
+    DllLoaderContainer::ReleaseModule(m_pDll);
+#endif
+  }
+}
+
+void XBPython::Uninitialize()
+{
+  // don't handle any more announcements as most scripts are probably already
+  // stopped and executing a callback on one of their already destroyed classes
+  // would lead to a crash
+  CAnnouncementManager::GetInstance().RemoveAnnouncer(this);
+
+  LOCK_AND_COPY(std::vector<PyElem>,tmpvec,m_vecPyList);
+  m_vecPyList.clear();
+  m_vecPyList.hadSomethingRemoved = true;
+
+  lock.Leave(); //unlock here because the python thread might lock when it exits
+
+  // cleanup threads that are still running
+  tmpvec.clear(); // boost releases the XBPyThreads which, if deleted, calls OnScriptFinalized
+}
+
+void XBPython::Process()
+{
+  if (m_bInitialized)
+  {
+    PyList tmpvec;
+    CSingleLock lock(m_vecPyList);
+    for (PyList::iterator it = m_vecPyList.begin(); it != m_vecPyList.end();)
+    {
+      if (it->bDone)
+      {
+        tmpvec.push_back(*it);
+        it = m_vecPyList.erase(it);
+        m_vecPyList.hadSomethingRemoved = true;
+      }
+      else
+        ++it;
+    }
+    lock.Leave();
+
+    //delete scripts which are done
+    tmpvec.clear(); // boost releases the XBPyThreads which, if deleted, calls OnScriptFinalized
+
+    CSingleLock l2(m_critSection);
+    if(m_iDllScriptCounter == 0 && (XbmcThreads::SystemClockMillis() - m_endtime) > 10000 )
+    {
+      Finalize();
+    }
+  }
+}
+
+bool XBPython::OnScriptInitialized(ILanguageInvoker *invoker)
+{
+  if (invoker == NULL)
+    return false;
+
+  XBMC_TRACE;
+  CLog::Log(LOGINFO, "initializing python engine.");
+  CSingleLock lock(m_critSection);
+  m_iDllScriptCounter++;
+  if (!m_bInitialized)
+  {
+    // first we check if all necessary files are installed
+#ifndef TARGET_POSIX
+    if (!FileExist("special://xbmc/system/python/DLLs/_socket.pyd") ||
+      !FileExist("special://xbmc/system/python/DLLs/_ssl.pyd") ||
+      !FileExist("special://xbmc/system/python/DLLs/_bz2.pyd") ||
+      !FileExist("special://xbmc/system/python/DLLs/pyexpat.pyd") ||
+      !FileExist("special://xbmc/system/python/DLLs/select.pyd") ||
+      !FileExist("special://xbmc/system/python/DLLs/unicodedata.pyd"))
+    {
+      CLog::Log(LOGERROR, "Python: Missing files, unable to execute script");
+      Finalize();
+      return false;
+    }
+#endif
+
+    // Darwin packs .pyo files, we need PYTHONOPTIMIZE on in order to load them.
+    // linux built with unified builds only packages the pyo files so need it
+#if defined(TARGET_DARWIN) || defined(TARGET_LINUX)
+    setenv("PYTHONOPTIMIZE", "1", 1);
+#endif
+    // Info about interesting python envvars available
+    // at http://docs.python.org/using/cmdline.html#environment-variables
+
+#if !defined(TARGET_WINDOWS) && !defined(TARGET_ANDROID)
+    /* PYTHONOPTIMIZE is set off intentionally when using external Python.
+    Reason for this is because we cannot be sure what version of Python
+    was used to compile the various Python object files (i.e. .pyo,
+    .pyc, etc.). */
+    // check if we are running as real xbmc.app or just binary
+    if (!CUtil::GetFrameworksPath(true).empty())
+    {
+      // using external python, it's build looking for xxx/lib/python3.6
+      // so point it to frameworks which is where python3.6 is located
+      setenv("PYTHONHOME", CSpecialProtocol::TranslatePath("special://frameworks").c_str(), 1);
+      setenv("PYTHONPATH", CSpecialProtocol::TranslatePath("special://frameworks").c_str(), 1);
+      CLog::Log(LOGDEBUG, "PYTHONHOME -> %s", CSpecialProtocol::TranslatePath("special://frameworks").c_str());
+      CLog::Log(LOGDEBUG, "PYTHONPATH -> %s", CSpecialProtocol::TranslatePath("special://frameworks").c_str());
+    }
+#elif defined(TARGET_WINDOWS)
+    // because the third party build of python is compiled with vs2008 we need
+    // a hack to set the PYTHONPATH
+    std::string buf;
+    buf = "PYTHONPATH=" + CSpecialProtocol::TranslatePath("special://xbmc/system/python/DLLs") + ";" + CSpecialProtocol::TranslatePath("special://xbmc/system/python/Lib");
+    CEnvironment::putenv(buf);
+    buf = "PYTHONOPTIMIZE=1";
+    CEnvironment::putenv(buf);
+    buf = "PYTHONHOME=" + CSpecialProtocol::TranslatePath("special://xbmc/system/python");
+    CEnvironment::putenv(buf);
+    buf = "OS=win32";
+    CEnvironment::putenv(buf);
+#endif
+
+    if (PyEval_ThreadsInitialized())
+      PyEval_AcquireLock();
+    else
+      PyEval_InitThreads();
+
+    Py_Initialize();
+    PyEval_ReleaseLock();
+
+    // If this is not the first time we initialize Python, the interpreter
+    // lock already exists and we need to lock it as PyEval_InitThreads
+    // would not do that in that case.
+    PyEval_AcquireLock();
+    char* python_argv[1] = { (char*)"" };
+    PySys_SetArgv(1, (wchar_t **)python_argv);
+
+    if (!(m_mainThreadState = PyThreadState_Get()))
+      CLog::Log(LOGERROR, "Python threadstate is NULL.");
+    PyEval_ReleaseLock();
+
+    m_bInitialized = true;
+  }
+
+  return m_bInitialized;
+}
+
+void XBPython::OnScriptStarted(ILanguageInvoker *invoker)
+{
+  if (invoker == NULL)
+    return;
+
+  if (!m_bInitialized)
+    return;
+
+  PyElem inf;
+  inf.id        = invoker->GetId();
+  inf.bDone     = false;
+  inf.pyThread  = static_cast<CPythonInvoker*>(invoker);
+  CSingleLock lock(m_vecPyList);
+  m_vecPyList.push_back(inf);
+}
+
+void XBPython::OnScriptAbortRequested(ILanguageInvoker *invoker)
+{
+  XBMC_TRACE;
+
+  long invokerId(-1);
+  if (invoker != NULL)
+    invokerId = invoker->GetId();
+
+  LOCK_AND_COPY(std::vector<XBMCAddon::xbmc::Monitor*>, tmp, m_vecMonitorCallbackList);
+  for (MonitorCallbackList::iterator it = tmp.begin(); (it != tmp.end()); ++it)
+  {
+    if (CHECK_FOR_ENTRY(m_vecMonitorCallbackList, (*it)))
+    {
+      if (invokerId < 0 || (*it)->GetInvokerId() == invokerId)
+        (*it)->OnAbortRequested();
+    }
+  }
+}
+
+void XBPython::OnScriptEnded(ILanguageInvoker *invoker)
+{
+  CSingleLock lock(m_vecPyList);
+  PyList::iterator it = m_vecPyList.begin();
+  while (it != m_vecPyList.end())
+  {
+    if (it->id == invoker->GetId())
+    {
+      if (it->pyThread->IsStopping())
+        CLog::Log(LOGINFO, "Python script interrupted by user");
+      else
+        CLog::Log(LOGINFO, "Python script stopped");
+      it->bDone = true;
+    }
+    ++it;
+  }
+}
+
+void XBPython::OnScriptFinalized(ILanguageInvoker *invoker)
+{
+  XBMC_TRACE;
+  CSingleLock lock(m_critSection);
+  // for linux - we never release the library. its loaded and stays in memory.
+  if (m_iDllScriptCounter)
+    m_iDllScriptCounter--;
+  else
+    CLog::Log(LOGERROR, "Python script counter attempted to become negative");
+  m_endtime = XbmcThreads::SystemClockMillis();
+}
+
+ILanguageInvoker* XBPython::CreateInvoker()
+{
+  return new CAddonPythonInvoker(this);
+}
+
+void XBPython::PulseGlobalEvent()
+{
+  m_globalEvent.Set();
+}
+
+bool XBPython::WaitForEvent(CEvent& hEvent, unsigned int milliseconds)
+{
+  // wait for either this event our our global event
+  XbmcThreads::CEventGroup eventGroup{&hEvent, &m_globalEvent};
+  CEvent* ret = eventGroup.wait(milliseconds);
+  if (ret)
+    m_globalEvent.Reset();
+  return ret != NULL;
+}
diff --git a/xbmc/interfaces/python3/XBPython.h b/xbmc/interfaces/python3/XBPython.h
new file mode 100644
index 000000000000..85424dc0a549
--- /dev/null
+++ b/xbmc/interfaces/python3/XBPython.h
@@ -0,0 +1,137 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "cores/IPlayerCallback.h"
+#include "threads/CriticalSection.h"
+#include "threads/Event.h"
+#include "threads/Thread.h"
+#include "interfaces/IAnnouncer.h"
+#include "interfaces/generic/ILanguageInvocationHandler.h"
+#include "ServiceBroker.h"
+
+#include <memory>
+#include <vector>
+
+#define g_pythonParser CServiceBroker::GetXBPython()
+
+class CPythonInvoker;
+class CVariant;
+
+typedef struct {
+  int id;
+  bool bDone;
+  CPythonInvoker* pyThread;
+}PyElem;
+
+class LibraryLoader;
+
+namespace XBMCAddon
+{
+  namespace xbmc
+  {
+    class Monitor;
+  }
+}
+
+template <class T> struct LockableType : public T, public CCriticalSection
+{ bool hadSomethingRemoved; };
+
+typedef LockableType<std::vector<void*> > PlayerCallbackList;
+typedef LockableType<std::vector<XBMCAddon::xbmc::Monitor*> > MonitorCallbackList;
+typedef LockableType<std::vector<PyElem> > PyList;
+typedef std::vector<LibraryLoader*> PythonExtensionLibraries;
+
+class XBPython :
+  public IPlayerCallback,
+  public ANNOUNCEMENT::IAnnouncer,
+  public ILanguageInvocationHandler
+{
+public:
+  XBPython();
+  ~XBPython() override;
+  void OnPlayBackEnded() override;
+  void OnPlayBackStarted() override;
+  void OnPlayBackPaused() override;
+  void OnPlayBackResumed() override;
+  void OnPlayBackStopped() override;
+  void OnPlayBackSpeedChanged(int iSpeed) override;
+  void OnPlayBackSeek(int64_t iTime, int64_t seekOffset) override;
+  void OnPlayBackSeekChapter(int iChapter) override;
+  void OnQueueNextItem() override;
+
+  void Announce(ANNOUNCEMENT::AnnouncementFlag flag, const char *sender, const char *message, const CVariant &data) override;
+  void RegisterPythonPlayerCallBack(IPlayerCallback* pCallback);
+  void UnregisterPythonPlayerCallBack(IPlayerCallback* pCallback);
+  void RegisterPythonMonitorCallBack(XBMCAddon::xbmc::Monitor* pCallback);
+  void UnregisterPythonMonitorCallBack(XBMCAddon::xbmc::Monitor* pCallback);
+  void OnSettingsChanged(const std::string &strings);
+  void OnScreensaverActivated();
+  void OnScreensaverDeactivated();
+  void OnDPMSActivated();
+  void OnDPMSDeactivated();
+  void OnScanStarted(const std::string &library);
+  void OnScanFinished(const std::string &library);
+  void OnCleanStarted(const std::string &library);
+  void OnCleanFinished(const std::string &library);
+  void OnNotification(const std::string &sender, const std::string &method, const std::string &data);
+
+  void Process() override;
+  void PulseGlobalEvent() override;
+  void Uninitialize() override;
+  bool OnScriptInitialized(ILanguageInvoker *invoker) override;
+  void OnScriptStarted(ILanguageInvoker *invoker) override;
+  void OnScriptAbortRequested(ILanguageInvoker *invoker) override;
+  void OnScriptEnded(ILanguageInvoker *invoker) override;
+  void OnScriptFinalized(ILanguageInvoker *invoker) override;
+  ILanguageInvoker* CreateInvoker() override;
+
+  bool WaitForEvent(CEvent& hEvent, unsigned int milliseconds);
+
+  void RegisterExtensionLib(LibraryLoader *pLib);
+  void UnregisterExtensionLib(LibraryLoader *pLib);
+  void UnloadExtensionLibs();
+
+private:
+  void Finalize();
+
+  CCriticalSection    m_critSection;
+  bool              FileExist(const char* strFile);
+
+  void*             m_mainThreadState;
+  ThreadIdentifier  m_ThreadId;
+  bool              m_bInitialized;
+  int               m_iDllScriptCounter; // to keep track of the total scripts running that need the dll
+  unsigned int      m_endtime;
+
+  //Vector with list of threads used for running scripts
+  PyList              m_vecPyList;
+  PlayerCallbackList  m_vecPlayerCallbackList;
+  MonitorCallbackList m_vecMonitorCallbackList;
+  LibraryLoader*      m_pDll;
+
+  // any global events that scripts should be using
+  CEvent m_globalEvent;
+
+  // in order to finalize and unload the python library, need to save all the extension libraries that are
+  // loaded by it and unload them first (not done by finalize)
+  PythonExtensionLibraries m_extensions;
+};
diff --git a/xbmc/interfaces/python3/preamble.h b/xbmc/interfaces/python3/preamble.h
new file mode 100644
index 000000000000..4d5597dd8bcc
--- /dev/null
+++ b/xbmc/interfaces/python3/preamble.h
@@ -0,0 +1,27 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#pragma once
+
+#ifdef SWIGPYTHON
+
+#include <Python.h>
+
+#endif
diff --git a/xbmc/interfaces/python3/pythreadstate.h b/xbmc/interfaces/python3/pythreadstate.h
new file mode 100644
index 000000000000..0237edcb9176
--- /dev/null
+++ b/xbmc/interfaces/python3/pythreadstate.h
@@ -0,0 +1,73 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "threads/SingleLock.h"
+
+//WARNING: since this will unlock/lock the python global interpreter lock,
+//         it will not work recursively
+
+//this is basically a scoped version of a Py_BEGIN_ALLOW_THREADS .. Py_END_ALLOW_THREADS block
+class CPyThreadState
+{
+  public:
+    explicit CPyThreadState(bool save = true)
+    {
+      m_threadState = NULL;
+
+      if (save)
+        Save();
+    }
+
+    ~CPyThreadState()
+    {
+      Restore();
+    }
+
+    void Save()
+    {
+      if (!m_threadState)
+        m_threadState = PyEval_SaveThread(); //same as Py_BEGIN_ALLOW_THREADS
+    }
+
+    void Restore()
+    {
+      if (m_threadState)
+      {
+        PyEval_RestoreThread(m_threadState); //same as Py_END_ALLOW_THREADS
+        m_threadState = NULL;
+      }
+    }
+
+  private:
+    PyThreadState* m_threadState;
+};
+
+/**
+ * A CSingleLock that will relinquish the GIL during the time
+ *  it takes to obtain the CriticalSection
+ */
+class GilSafeSingleLock : public CPyThreadState, public CSingleLock
+{
+public:
+  explicit GilSafeSingleLock(const CCriticalSection& critSec) : CPyThreadState(true), CSingleLock(critSec) { CPyThreadState::Restore(); }
+};
+
diff --git a/xbmc/interfaces/python3/swig.cpp b/xbmc/interfaces/python3/swig.cpp
new file mode 100644
index 000000000000..e9f1111e19bb
--- /dev/null
+++ b/xbmc/interfaces/python3/swig.cpp
@@ -0,0 +1,385 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "LanguageHook.h"
+#include "swig.h"
+#include "utils/StringUtils.h"
+#include "interfaces/legacy/AddonString.h"
+
+#include <string>
+
+namespace PythonBindings
+{
+  TypeInfo::TypeInfo(const std::type_info& ti) : swigType(NULL), parentType(NULL), typeIndex(ti)
+  {
+    static PyTypeObject py_type_object_header = { PyVarObject_HEAD_INIT(NULL, 0)};
+    static int size = (long*)&(py_type_object_header.tp_name) - (long*)&py_type_object_header;
+    memcpy(&(this->pythonType), &py_type_object_header, size);
+  }
+
+  class PyObjectDecrementor
+  {
+    PyObject* obj;
+  public:
+    inline explicit PyObjectDecrementor(PyObject* pyobj) : obj(pyobj) {}
+    inline ~PyObjectDecrementor() { Py_XDECREF(obj); }
+
+    inline PyObject* get() { return obj; }
+  };
+
+  void PyXBMCGetUnicodeString(std::string& buf, PyObject* pObject, bool coerceToString,
+                              const char* argumentName, const char* methodname)
+  {
+    // It's okay for a string to be "None". In this case the buf returned
+    // will be the emptyString.
+    if (pObject == Py_None)
+    {
+      buf = XBMCAddon::emptyString;
+      return;
+    }
+
+    //! @todo UTF-8: Does python use UTF-16?
+    //!              Do we need to convert from the string charset to UTF-8
+    //!              for non-unicode data?
+    if (PyUnicode_Check(pObject))
+    {
+      // Python unicode objects are UCS2 or UCS4 depending on compilation
+      // options, wchar_t is 16-bit or 32-bit depending on platform.
+      // Avoid the complexity by just letting python convert the string.
+
+      buf = PyUnicode_AsUTF8(pObject);
+      return;
+    }
+
+    if (PyBytes_Check(pObject))    // If pobject is of type Bytes
+    {
+      buf = PyBytes_AsString(pObject);
+      return;
+    }
+
+    // if we got here then we need to coerce the value to a string
+    if (coerceToString)
+    {
+      PyObjectDecrementor dec(PyObject_Str(pObject));
+      PyObject* pyStrCast = dec.get();
+      if (pyStrCast)
+      {
+        PyXBMCGetUnicodeString(buf,pyStrCast,false,argumentName,methodname);
+        return;
+      }
+    }
+
+    // Object is not a unicode or a normal string.
+    buf = "";
+    throw XBMCAddon::WrongTypeException("argument \"%s\" for method \"%s\" must be unicode or str", argumentName, methodname);
+  }
+
+  // need to compare the typestring
+  bool isParameterRightType(const char* passedType, const char* expectedType, const char* methodNamespacePrefix, bool tryReverse)
+  {
+    if (strcmp(expectedType,passedType) == 0)
+      return true;
+
+    // well now things are a bit more complicated. We need to see if the passed type
+    // is a subset of the overall type
+    std::string et(expectedType);
+    bool isPointer = (et[0] == 'p' && et[1] == '.');
+    std::string baseType(et,(isPointer ? 2 : 0)); // this may contain a namespace
+
+    std::string ns(methodNamespacePrefix);
+    // cut off trailing '::'
+    if (ns.size() > 2 && ns[ns.size() - 1] == ':' && ns[ns.size() - 2] == ':')
+      ns = ns.substr(0,ns.size()-2);
+
+    bool done = false;
+    while(! done)
+    {
+      done = true;
+
+      // now we need to see if the expected type can be munged
+      //  into the passed type by tacking on the namespace of
+      //  of the method.
+      std::string check(isPointer ? "p." : "");
+      check += ns;
+      check += "::";
+      check += baseType;
+
+      if (strcmp(check.c_str(),passedType) == 0)
+        return true;
+
+      // see if the namespace is nested.
+      int posOfScopeOp = ns.find("::");
+      if (posOfScopeOp >= 0)
+      {
+        done = false;
+        // cur off the outermost namespace
+        ns = ns.substr(posOfScopeOp + 2);
+      }
+    }
+
+    // so far we applied the namespace to the expected type. Now lets try
+    //  the reverse if we haven't already.
+    if (tryReverse)
+      return isParameterRightType(expectedType, passedType, methodNamespacePrefix, false);
+
+    return false;
+  }
+
+  PythonToCppException::PythonToCppException() : XbmcCommons::UncheckedException(" ")
+  {
+    setClassname("PythonToCppException");
+
+    std::string msg;
+    std::string type, value, traceback;
+    if (!ParsePythonException(type, value, traceback))
+      UncheckedException::SetMessage("Strange: No Python exception occured");
+    else
+      SetMessage(type, value, traceback);
+  }
+
+  PythonToCppException::PythonToCppException(const std::string &exceptionType, const std::string &exceptionValue, const std::string &exceptionTraceback) : XbmcCommons::UncheckedException(" ")
+  {
+    setClassname("PythonToCppException");
+
+    SetMessage(exceptionType, exceptionValue, exceptionTraceback);
+  }
+
+  bool PythonToCppException::ParsePythonException(std::string &exceptionType, std::string &exceptionValue, std::string &exceptionTraceback)
+  {
+    PyObject* exc_type;
+    PyObject* exc_value;
+    PyObject* exc_traceback;
+    PyObject* pystring = NULL;
+
+    PyErr_Fetch(&exc_type, &exc_value, &exc_traceback);
+    if (exc_type == NULL && exc_value == NULL && exc_traceback == NULL)
+      return false;
+
+    exceptionType.clear();
+    exceptionValue.clear();
+    exceptionTraceback.clear();
+
+    if (exc_type != NULL && (pystring = PyObject_Str(exc_type)) != NULL && PyUnicode_Check(pystring))
+    {
+      char *str = PyUnicode_AsUTF8(pystring);
+      if (str != NULL)
+        exceptionType = str;
+
+      pystring = PyObject_Str(exc_value);
+      if (pystring != NULL)
+      {
+        str = PyUnicode_AsUTF8(pystring);
+        exceptionValue = str;
+      }
+
+      PyObject *tracebackModule = PyImport_ImportModule("traceback");
+      if (tracebackModule != NULL)
+      {
+        char method[] = "format_exception";
+        char format[] = "OOO";
+        PyObject *tbList = PyObject_CallMethod(tracebackModule, method, format, exc_type, exc_value == NULL ? Py_None : exc_value, exc_traceback == NULL ? Py_None : exc_traceback);
+
+        if (tbList)
+        {
+          PyObject *emptyString = PyUnicode_FromString("");
+          char method[] = "join";
+          char format[] = "O";
+          PyObject *strRetval = PyObject_CallMethod(emptyString, method, format, tbList);
+          Py_DECREF(emptyString);
+
+          if (strRetval)
+          {
+            str = PyUnicode_AsUTF8(strRetval);
+            if (str != NULL)
+              exceptionTraceback = str;
+            Py_DECREF(strRetval);
+          }
+          Py_DECREF(tbList);
+        }
+        Py_DECREF(tracebackModule);
+
+      }
+    }
+
+    Py_XDECREF(exc_type);
+    Py_XDECREF(exc_value);
+    Py_XDECREF(exc_traceback);
+    Py_XDECREF(pystring);
+
+    return true;
+  }
+
+  void PythonToCppException::SetMessage(const std::string &exceptionType, const std::string &exceptionValue, const std::string &exceptionTraceback)
+  {
+    std::string msg = "-->Python callback/script returned the following error<--\n";
+    msg += " - NOTE: IGNORING THIS CAN LEAD TO MEMORY LEAKS!\n";
+
+    if (!exceptionType.empty())
+    {
+      msg += StringUtils::Format("Error Type: %s\n", exceptionType.c_str());
+
+      if (!exceptionValue.empty())
+        msg += StringUtils::Format("Error Contents: %s\n", exceptionValue.c_str());
+
+      if (!exceptionTraceback.empty())
+        msg += exceptionTraceback;
+
+      msg += "-->End of Python script error report<--\n";
+    }
+    else
+      msg += "<unknown exception type>";
+
+    UncheckedException::SetMessage("%s", msg.c_str());
+  }
+
+  XBMCAddon::AddonClass* doretrieveApiInstance(const PyHolder* pythonObj, const TypeInfo* typeInfo, const char* expectedType,
+                              const char* methodNamespacePrefix, const char* methodNameForErrorString)
+  {
+    if (pythonObj->magicNumber != XBMC_PYTHON_TYPE_MAGIC_NUMBER)
+      throw XBMCAddon::WrongTypeException("Non api type passed to \"%s\" in place of the expected type \"%s.\"",
+                                          methodNameForErrorString, expectedType);
+    if (!isParameterRightType(typeInfo->swigType,expectedType,methodNamespacePrefix))
+    {
+      // maybe it's a child class
+      if (typeInfo->parentType)
+        return doretrieveApiInstance(pythonObj, typeInfo->parentType,expectedType,
+                                     methodNamespacePrefix, methodNameForErrorString);
+      else
+        throw XBMCAddon::WrongTypeException("Incorrect type passed to \"%s\", was expecting a \"%s\" but received a \"%s\"",
+                                 methodNameForErrorString,expectedType,typeInfo->swigType);
+    }
+    return const_cast<XBMCAddon::AddonClass*>(reinterpret_cast<const PyHolder*>(pythonObj)->pSelf);
+  }
+
+  /**
+   * This method is a helper for the generated API. It's called prior to any API
+   * class constructor being returned from the generated code to Python
+   */
+  void prepareForReturn(XBMCAddon::AddonClass* c)
+  {
+    XBMC_TRACE;
+    if(c) {
+      c->Acquire();
+      PyThreadState* state = PyThreadState_Get();
+      XBMCAddon::Python::PythonLanguageHook::GetIfExists(state->interp)->RegisterAddonClassInstance(c);
+    }
+  }
+
+  static bool handleInterpRegistrationForClean(XBMCAddon::AddonClass* c)
+  {
+    XBMC_TRACE;
+    if(c){
+      XBMCAddon::AddonClass::Ref<XBMCAddon::Python::PythonLanguageHook> lh =
+        XBMCAddon::AddonClass::Ref<XBMCAddon::AddonClass>(c->GetLanguageHook());
+
+      if (lh.isNotNull())
+      {
+        lh->UnregisterAddonClassInstance(c);
+        return true;
+      }
+      else
+      {
+        PyThreadState* state = PyThreadState_Get();
+        lh = XBMCAddon::Python::PythonLanguageHook::GetIfExists(state->interp);
+        if (lh.isNotNull()) lh->UnregisterAddonClassInstance(c);
+        return true;
+      }
+    }
+    return false;
+  }
+
+  /**
+   * This method is a helper for the generated API. It's called prior to any API
+   * class destructor being dealloc-ed from the generated code from Python
+   */
+  void cleanForDealloc(XBMCAddon::AddonClass* c)
+  {
+    XBMC_TRACE;
+    if (handleInterpRegistrationForClean(c))
+      c->Release();
+  }
+
+  /**
+   * This method is a helper for the generated API. It's called prior to any API
+   * class destructor being dealloc-ed from the generated code from Python
+   *
+   * There is a Catch-22 in the destruction of a Window. 'dispose' needs to be
+   * called on destruction but cannot be called from the destructor.
+   * This overrides the default cleanForDealloc to resolve that.
+   */
+  void cleanForDealloc(XBMCAddon::xbmcgui::Window* c)
+  {
+    XBMC_TRACE;
+    if (handleInterpRegistrationForClean(c))
+    {
+      c->dispose();
+      c->Release();
+    }
+  }
+
+  /**
+   * This method allows for conversion of the native api Type to the Python type.
+   *
+   * When this form of the call is used (and pytype isn't NULL) then the
+   * passed type is used in the instance. This is for classes that extend API
+   * classes in python. The type passed may not be the same type that's stored
+   * in the class metadata of the AddonClass of which 'api' is an instance,
+   * it can be a subclass in python.
+   *
+   * if pytype is NULL then the type is inferred using the class metadata
+   * stored in the AddonClass instance 'api'.
+   */
+  PyObject* makePythonInstance(XBMCAddon::AddonClass* api, PyTypeObject* pytype, bool incrementRefCount)
+  {
+    // null api types result in Py_None
+    if (!api)
+    {
+      Py_INCREF(Py_None);
+      return Py_None;
+    }
+
+    // retrieve the TypeInfo from the api class
+    const TypeInfo* typeInfo = getTypeInfoForInstance(api);
+    PyTypeObject* typeObj = pytype == NULL ? (PyTypeObject*)(&(typeInfo->pythonType)) : pytype;
+
+    PyHolder* self = reinterpret_cast<PyHolder*>(typeObj->tp_alloc(typeObj,0));
+    if (!self) return NULL;
+    self->magicNumber = XBMC_PYTHON_TYPE_MAGIC_NUMBER;
+    self->typeInfo = typeInfo;
+    self->pSelf = api;
+    if (incrementRefCount)
+      Py_INCREF((PyObject*)self);
+    return (PyObject*)self;
+  }
+
+  std::map<std::type_index, const TypeInfo*> typeInfoLookup;
+
+  void registerAddonClassTypeInformation(const TypeInfo* classInfo)
+  {
+    typeInfoLookup[classInfo->typeIndex] = classInfo;
+  }
+
+  const TypeInfo* getTypeInfoForInstance(XBMCAddon::AddonClass* obj)
+  {
+    std::type_index ti(typeid(*obj));
+    return typeInfoLookup[ti];
+  }
+
+}
diff --git a/xbmc/interfaces/python3/swig.h b/xbmc/interfaces/python3/swig.h
new file mode 100644
index 000000000000..57a63fc8adf1
--- /dev/null
+++ b/xbmc/interfaces/python3/swig.h
@@ -0,0 +1,211 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#pragma once
+
+#include <Python.h>
+#include <string>
+#include <stdint.h>
+
+#include "interfaces/legacy/Exception.h"
+#include "interfaces/legacy/AddonClass.h"
+#include "interfaces/legacy/Window.h"
+#include <typeindex>
+
+namespace PythonBindings
+{
+  /**
+   * This call will convert the python object passed to a string. The object
+   * passed must be a python str or unicode object unless coerceToString is
+   * true. If coerceToString is true then the type must be castable to a string
+   * using the python call str(pObject).
+   *
+   * This method will handle a 'None' that's passed in. If 'None' is passed then
+   * the resulting buf will contain the value of XBMCAddon::emptyString (which 
+   * is simply a std::string instantiated with the default constructor.
+   */
+  void PyXBMCGetUnicodeString(std::string& buf, PyObject* pObject, bool coerceToString = false,
+                              const char* pos = "unknown", 
+                              const char* methodname = "unknown");
+
+  struct TypeInfo
+  {
+    const char* swigType;
+    TypeInfo* parentType;
+    PyTypeObject pythonType;
+    const std::type_index typeIndex;
+
+    explicit TypeInfo(const std::type_info& ti);
+  };
+
+  // This will hold the pointer to the api type, whether known or unknown
+  struct PyHolder
+  { 
+    PyObject_HEAD
+    int32_t magicNumber;
+    const TypeInfo* typeInfo;
+    XBMCAddon::AddonClass* pSelf;
+  };
+
+#define XBMC_PYTHON_TYPE_MAGIC_NUMBER 0x58626D63
+
+  /**
+   * This method retrieves the pointer from the PyHolder. The return value should
+   * be cast to the appropriate type.
+   *
+   * Since the calls to this are generated there's no NULL pointer checks
+   */
+  inline XBMCAddon::AddonClass* retrieveApiInstance(PyObject* pythonObj, const TypeInfo* typeToCheck, 
+                                   const char* methodNameForErrorString, 
+                                   const char* typenameForErrorString)
+  {
+    if (pythonObj == NULL || pythonObj == Py_None)
+      return NULL;
+    if (reinterpret_cast<PyHolder*>(pythonObj)->magicNumber != XBMC_PYTHON_TYPE_MAGIC_NUMBER || !PyObject_TypeCheck(pythonObj, const_cast<PyTypeObject*>((&(typeToCheck->pythonType)))))
+      throw XBMCAddon::WrongTypeException("Incorrect type passed to \"%s\", was expecting a \"%s\".",methodNameForErrorString,typenameForErrorString);
+    return reinterpret_cast<PyHolder*>(pythonObj)->pSelf;
+  }
+
+  bool isParameterRightType(const char* passedType, const char* expectedType, const char* methodNamespacePrefix, bool tryReverse = true);
+
+  XBMCAddon::AddonClass* doretrieveApiInstance(const PyHolder* pythonObj, const TypeInfo* typeInfo, const char* expectedType, 
+                              const char* methodNamespacePrefix, const char* methodNameForErrorString);
+
+  /**
+   * This method retrieves the pointer from the PyHolder. The return value should
+   * be cast to the appropriate type.
+   *
+   * Since the calls to this are generated there's no NULL pointer checks
+   *
+   * This method will return NULL if either the pythonObj is NULL or the 
+   * pythonObj is Py_None.
+   */
+  inline XBMCAddon::AddonClass* retrieveApiInstance(const PyObject* pythonObj, const char* expectedType, const char* methodNamespacePrefix,
+                                   const char* methodNameForErrorString)
+  {
+    return (pythonObj == NULL || pythonObj == Py_None) ? NULL :
+      doretrieveApiInstance(reinterpret_cast<const PyHolder*>(pythonObj),reinterpret_cast<const PyHolder*>(pythonObj)->typeInfo, expectedType, methodNamespacePrefix, methodNameForErrorString);
+  }
+
+  /**
+   * This method is a helper for the generated API. It's called prior to any API
+   * class constructor being returned from the generated code to Python
+   */
+  void prepareForReturn(XBMCAddon::AddonClass* c);
+
+  /**
+   * This method is a helper for the generated API. It's called prior to any API
+   * class destructor being dealloc-ed from the generated code from Python
+   */
+  void cleanForDealloc(XBMCAddon::AddonClass* c);
+
+  /**
+   * This method is a helper for the generated API. It's called prior to any API
+   * class destructor being dealloc-ed from the generated code from Python
+   *
+   * There is a Catch-22 in the destruction of a Window. 'dispose' needs to be
+   * called on destruction but cannot be called from the destructor.
+   * This overrides the default cleanForDealloc to resolve that.
+   */
+  void cleanForDealloc(XBMCAddon::xbmcgui::Window* c);
+
+  /**
+   * This method allows for conversion of the native api Type to the Python type.
+   *
+   * When this form of the call is used (and pythonType isn't NULL) then the
+   * passed type is used in the instance. This is for classes that extend API
+   * classes in python. The type passed may not be the same type that's stored
+   * in the class metadata of the AddonClass of which 'api' is an instance, 
+   * it can be a subclass in python.
+   *
+   * if pythonType is NULL then the type is inferred using the class metadata 
+   * stored in the AddonClass instance 'api'.
+   */
+  PyObject* makePythonInstance(XBMCAddon::AddonClass* api, PyTypeObject* pythonType, bool incrementRefCount);
+
+  /**
+   * This method allows for conversion of the native api Type to the Python type.
+   * 
+   * When this form of the call is used then the python type constructed will be the 
+   * type given by the class metadata in the AddonClass instance 'api'.
+   *
+   * This is just a helper inline to call the other makePythonInstance with NULL as
+   * the pythonType.
+   */
+  inline PyObject* makePythonInstance(XBMCAddon::AddonClass* api, bool incrementRefCount)
+  {
+    return makePythonInstance(api,NULL,incrementRefCount);
+  }
+
+  void registerAddonClassTypeInformation(const TypeInfo* classInfo);
+  const TypeInfo* getTypeInfoForInstance(XBMCAddon::AddonClass* obj);
+
+  class Director
+  {
+  protected:
+    PyObject* self;
+  public:
+    inline Director() : self(NULL) {}
+    inline void setPyObjectForDirector(PyObject* pyargself) { self = pyargself; }
+  };
+
+  /**
+   * This exception is thrown from Director calls that call into python when the 
+   * Python error is 
+   */
+  class PythonToCppException : public XbmcCommons::UncheckedException
+  {
+  public:
+    /**
+     * Assuming a PyErr_Occurred, this will fill the exception message with all
+     *  of the appropriate information including the traceback if it can be
+     *  obtained. It will also clear the python message.
+     */
+    PythonToCppException();
+    PythonToCppException(const std::string &exceptionType, const std::string &exceptionValue, const std::string &exceptionTraceback);
+
+    static bool ParsePythonException(std::string &exceptionType, std::string &exceptionValue, std::string &exceptionTraceback);
+
+  protected:
+    void SetMessage(const std::string &exceptionType, const std::string &exceptionValue, const std::string &exceptionTraceback);
+  };
+
+  template<class T> struct PythonCompare
+  {
+    static inline int compare(PyObject* obj1, PyObject* obj2, const char* swigType, const char* methodNamespacePrefix, const char* methodNameForErrorString)
+    {
+      XBMC_TRACE;
+      try
+      {
+        T* o1 = (T*)retrieveApiInstance(obj1, swigType, methodNamespacePrefix, methodNameForErrorString);
+        T* o2 = (T*)retrieveApiInstance(obj2, swigType, methodNamespacePrefix, methodNameForErrorString);
+
+        return ((*o1) < (*o2) ? -1 : 
+                ((*o1) > (*o2) ? 1 : 0));
+      }
+      catch (const XBMCAddon::WrongTypeException& e)
+      {
+        CLog::Log(LOGERROR,"EXCEPTION: %s",e.GetMessage());
+        PyErr_SetString(PyExc_RuntimeError, e.GetMessage());
+      }
+      return -1;
+    }
+  };
+}
diff --git a/xbmc/interfaces/python3/test/CMakeLists.txt b/xbmc/interfaces/python3/test/CMakeLists.txt
new file mode 100644
index 000000000000..ec38a51931c7
--- /dev/null
+++ b/xbmc/interfaces/python3/test/CMakeLists.txt
@@ -0,0 +1,5 @@
+if(PYTHON_FOUND)
+  set(SOURCES TestSwig.cpp)
+
+  core_add_test_library(python_test)
+endif()
diff --git a/xbmc/interfaces/python3/test/TestSwig.cpp b/xbmc/interfaces/python3/test/TestSwig.cpp
new file mode 100644
index 000000000000..73a81ccb6857
--- /dev/null
+++ b/xbmc/interfaces/python3/test/TestSwig.cpp
@@ -0,0 +1,33 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "../swig.h"
+
+#include "gtest/gtest.h"
+
+using namespace PythonBindings;
+
+TEST(TestSwig, TypeConversion)
+{
+  EXPECT_TRUE(isParameterRightType("p.XBMCAddon::xbmcgui::ListItem","p.XBMCAddon::xbmcgui::ListItem","XBMCAddon::xbmc::"));
+  EXPECT_TRUE(isParameterRightType("p.XBMCAddon::xbmc::PlayList","p.PlayList","XBMCAddon::xbmc::"));
+  EXPECT_TRUE(isParameterRightType("p.PlayList","p.XBMCAddon::xbmc::PlayList","XBMCAddon::xbmc::"));
+}
+
diff --git a/xbmc/interfaces/python3/typemaps/python.Alternative.intm b/xbmc/interfaces/python3/typemaps/python.Alternative.intm
new file mode 100644
index 000000000000..eaee4f085e89
--- /dev/null
+++ b/xbmc/interfaces/python3/typemaps/python.Alternative.intm
@@ -0,0 +1,55 @@
+<%
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+    boolean ispointer = swigTypeParser.SwigType_ispointer(ltype)
+    String accessor = ispointer ? '->' : '.'
+    int seq = sequence.increment()
+    altAccess = [ 'former', 'later' ]
+    altSwitch = [ 'first', 'second' ]
+
+    List types = swigTypeParser.SwigType_templateparmlist(ltype)
+%>
+    {
+      // we need to check the parameter type and see if it matches
+      PyObject *pyentry_${seq} = ${slarg};
+      try
+      {
+        ${swigTypeParser.SwigType_str(swigTypeParser.SwigType_ltype(types[0]))} entry0_${seq};
+        ${helper.getInConversion(types[0], 'entry0' + '_' + seq, 'pyentry' + '_' + seq, method,
+                                 [ 'sequence' : sequence ])}
+        ${api}${accessor}${altAccess[0]}() = entry0_${seq};
+      }
+      catch (const XBMCAddon::WrongTypeException&)
+      {
+        try
+        {
+          ${swigTypeParser.SwigType_str(swigTypeParser.SwigType_ltype(types[1]))} entry1_${seq};
+          ${helper.getInConversion(types[1], 'entry1' + '_' + seq, 'pyentry' + '_' + seq, method,
+                                   [ 'sequence' : sequence ])}
+          ${api}${accessor}${altAccess[1]}() = entry1_${seq};
+        }
+        catch (const XBMCAddon::WrongTypeException&)
+        {
+          throw XBMCAddon::WrongTypeException("Failed to convert to input type to either a " 
+                                              "${swigTypeParser.SwigType_ltype(types[0])} or a "
+                                              "${swigTypeParser.SwigType_ltype(types[1])}" );
+        }
+      }
+    }
\ No newline at end of file
diff --git a/xbmc/interfaces/python3/typemaps/python.Alternative.outtm b/xbmc/interfaces/python3/typemaps/python.Alternative.outtm
new file mode 100644
index 000000000000..5288f756eb4b
--- /dev/null
+++ b/xbmc/interfaces/python3/typemaps/python.Alternative.outtm
@@ -0,0 +1,46 @@
+<%
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+    List types = swigTypeParser.SwigType_templateparmlist(type)
+    boolean ispointer = swigTypeParser.SwigType_ispointer(type)
+    int seq = sequence.increment()
+    String accessor = ispointer ? '->' : '.'
+    altAccess = [ 'former', 'later' ]
+    altSwitch = [ 'first', 'second' ]
+%>
+    WhichAlternative pos = ${api}${accessor}which();
+
+    if (<%if (ispointer) { %>${api} != NULL && <%}%>pos != XBMCAddon::none)
+    { <%
+      types.eachWithIndex { curType, entryIndex -> 
+%>
+      if (pos == XBMCAddon::${altSwitch[entryIndex]})
+      {
+        ${swigTypeParser.SwigType_str(swigTypeParser.SwigType_ltype(curType))}& entry${seq} = ${api}${accessor}${altAccess[entryIndex]}();
+        {
+          ${helper.getOutConversion(curType,result,method,[ 'api' : 'entry' + seq, 'sequence' : sequence ])}
+        }
+      }
+<%
+        }
+%>
+    }
+    else
+      ${result} = Py_None;
\ No newline at end of file
diff --git a/xbmc/interfaces/python3/typemaps/python.Tuple.intm b/xbmc/interfaces/python3/typemaps/python.Tuple.intm
new file mode 100644
index 000000000000..50567f39051a
--- /dev/null
+++ b/xbmc/interfaces/python3/typemaps/python.Tuple.intm
@@ -0,0 +1,47 @@
+<%
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+    List types = swigTypeParser.SwigType_templateparmlist(ltype)
+    boolean ispointer = swigTypeParser.SwigType_ispointer(type)
+    String accessor = ispointer ? '->' : '.'
+    int seq = sequence.increment()
+    tupleAccess = [ 'first', 'second', 'third', 'fourth' ]
+%>
+    if(${slarg})
+    {
+      bool isTuple = PyObject_TypeCheck(${slarg},&PyTuple_Type);
+      if (!isTuple && !PyObject_TypeCheck(${slarg},&PyList_Type))
+        throw WrongTypeException("The parameter \"${api}\" must be either a Tuple or a List.");
+      int vecSize = (isTuple ? PyTuple_Size(${slarg}) : PyList_Size(${slarg}));
+<%
+      types.eachWithIndex { curType, entryIndex ->
+%>
+      if (vecSize > ${entryIndex})
+      {
+        PyObject *pyentry${entryIndex}_${seq} = NULL;
+        pyentry${entryIndex}_${seq} = (isTuple ? PyTuple_GetItem(${slarg}, ${entryIndex}) : PyList_GetItem(${slarg}, ${entryIndex}));
+        ${swigTypeParser.SwigType_str(swigTypeParser.SwigType_ltype(curType))} entry${entryIndex}_${seq};
+        ${helper.getInConversion(curType, 'entry' + entryIndex + '_' + seq, 'pyentry' + entryIndex + '_' + seq, method,[ 'sequence' : sequence ])}
+        ${api}${accessor}${tupleAccess[entryIndex]}() = entry${entryIndex}_${seq};
+      }
+<%
+      }
+%>
+    }
diff --git a/xbmc/interfaces/python3/typemaps/python.Tuple.outtm b/xbmc/interfaces/python3/typemaps/python.Tuple.outtm
new file mode 100644
index 000000000000..02a6cd5e4e21
--- /dev/null
+++ b/xbmc/interfaces/python3/typemaps/python.Tuple.outtm
@@ -0,0 +1,51 @@
+<%
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+    List types = swigTypeParser.SwigType_templateparmlist(type)
+    boolean ispointer = swigTypeParser.SwigType_ispointer(type)
+    int seq = sequence.increment()
+    String accessor = ispointer ? '->' : '.'
+    tupleAccess = [ 'first', 'second', 'third', 'fourth' ]
+%>
+    int vecSize = ${api}${accessor}GetNumValuesSet();
+    ${result} = PyTuple_New(vecSize);
+<%
+    if (ispointer)
+    {
+%>
+    if (${api} != NULL)
+<%  }  // this ends the if (ispointer)
+%>    {
+      PyObject* pyentry${seq}; <%
+      types.eachWithIndex { curType, entryIndex -> 
+%>
+
+      if (vecSize > ${entryIndex})
+      {
+        ${swigTypeParser.SwigType_str(swigTypeParser.SwigType_ltype(curType))}& entry${seq} = ${api}${accessor}${tupleAccess[entryIndex]}();
+        {
+          ${helper.getOutConversion(curType,'result',method,[ 'result' : 'pyentry' + seq, 'api' : 'entry' + seq, 'sequence' : sequence ])}
+        }
+        PyTuple_SetItem(${result}, ${entryIndex}, pyentry${seq});
+      }
+<%
+        }
+%>
+    }
\ No newline at end of file
diff --git a/xbmc/interfaces/python3/typemaps/python.buffer.intm b/xbmc/interfaces/python3/typemaps/python.buffer.intm
new file mode 100644
index 000000000000..89b387c5cc2f
--- /dev/null
+++ b/xbmc/interfaces/python3/typemaps/python.buffer.intm
@@ -0,0 +1,38 @@
+<%
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+%>
+    if (PyUnicode_Check(${slarg}))
+    {
+      const char* str = PyUnicode_AsUTF8(${slarg});
+      size_t size = (size_t)PyUnicode_GetLength(${slarg});
+      ${api}.allocate(size);
+      ${api}.put(str,size);
+      ${api}.flip(); // prepare the buffer for reading from
+    }
+    else if (PyByteArray_Check(${slarg}))
+    {
+      size_t size = PyByteArray_Size(${slarg});
+      ${api}.allocate(size);
+      ${api}.put(PyByteArray_AsString(${slarg}),size);
+      ${api}.flip(); // prepare the buffer for reading from
+    }
+    else
+      throw XBMCAddon::WrongTypeException("argument \"%s\" for \"%s\" must be a string or a bytearray", "${api}", "${method.@name}");
diff --git a/xbmc/interfaces/python3/typemaps/python.buffer.outtm b/xbmc/interfaces/python3/typemaps/python.buffer.outtm
new file mode 100644
index 000000000000..758ebd6e8a5e
--- /dev/null
+++ b/xbmc/interfaces/python3/typemaps/python.buffer.outtm
@@ -0,0 +1,23 @@
+<%
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+    boolean ispointer = swigTypeParser.SwigType_ispointer(type)
+    String accessor = ispointer ? '->' : '.'
+%>${result} = PyByteArray_FromStringAndSize((char*)${api}${accessor}curPosition(),${api}${accessor}remaining());
\ No newline at end of file
diff --git a/xbmc/interfaces/python3/typemaps/python.dict.intm b/xbmc/interfaces/python3/typemaps/python.dict.intm
new file mode 100644
index 000000000000..2d6ca9f8a9a1
--- /dev/null
+++ b/xbmc/interfaces/python3/typemaps/python.dict.intm
@@ -0,0 +1,35 @@
+<%
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+    List templateArgs = swigTypeParser.SwigType_templateparmlist(ltype)
+    valtype = templateArgs[0]
+%>
+    {
+      PyObject *pykey, *pyvalue;
+      Py_ssize_t pos = 0;
+      while(PyDict_Next(${slarg}, &pos, &pykey, &pyvalue))
+      {
+        std::string key;
+        PyXBMCGetUnicodeString(key,pykey,false,"${api}","${method.@name}");
+        ${swigTypeParser.SwigType_str(swigTypeParser.SwigType_ltype(valtype))} value;
+        ${helper.getInConversion(valtype, 'value', 'pyvalue' ,method)}
+        ${api}[key] = value;
+      }
+    }
\ No newline at end of file
diff --git a/xbmc/interfaces/python3/typemaps/python.map.intm b/xbmc/interfaces/python3/typemaps/python.map.intm
new file mode 100644
index 000000000000..612295332868
--- /dev/null
+++ b/xbmc/interfaces/python3/typemaps/python.map.intm
@@ -0,0 +1,36 @@
+<%
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+    List templateArgs = swigTypeParser.SwigType_templateparmlist(ltype)
+    keytype = templateArgs[0]
+    valtype = templateArgs[1]
+%>
+    {
+      PyObject *pykey, *pyvalue;
+      Py_ssize_t pos = 0;
+      while(PyDict_Next(${slarg}, &pos, &pykey, &pyvalue))
+      {
+        ${swigTypeParser.SwigType_str(swigTypeParser.SwigType_ltype(keytype))} key;
+        ${swigTypeParser.SwigType_str(swigTypeParser.SwigType_ltype(valtype))} value;
+        ${helper.getInConversion(keytype, 'key', 'pykey', method)}
+        ${helper.getInConversion(valtype, 'value', 'pyvalue' ,method)}
+        ${api}[key] = value;
+      }
+    }
\ No newline at end of file
diff --git a/xbmc/interfaces/python3/typemaps/python.smart_ptr.outtm b/xbmc/interfaces/python3/typemaps/python.smart_ptr.outtm
new file mode 100644
index 000000000000..a92b16036aa1
--- /dev/null
+++ b/xbmc/interfaces/python3/typemaps/python.smart_ptr.outtm
@@ -0,0 +1,26 @@
+<%
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+    itype = swigTypeParser.SwigType_templateparmlist(type)[0]
+    pointertype = swigTypeParser.SwigType_makepointer(itype)
+    int seq = sequence.increment()
+%>
+    ${swigTypeParser.SwigType_str(swigTypeParser.SwigType_ltype(pointertype))} entry${seq} = ${api}.get();
+    ${helper.getOutConversion(pointertype,'result',method,[ 'api' : 'entry' + seq, 'sequence' : sequence ])}
diff --git a/xbmc/interfaces/python3/typemaps/python.string.outtm b/xbmc/interfaces/python3/typemaps/python.string.outtm
new file mode 100644
index 000000000000..ebb2a1235355
--- /dev/null
+++ b/xbmc/interfaces/python3/typemaps/python.string.outtm
@@ -0,0 +1,23 @@
+<%
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+%>${result} = <%
+  if(method.@feature_python_coerceToUnicode) { %>PyUnicode_DecodeUTF8(${api}.c_str(),${api}.size(),"replace");<% }
+  else { %>PyUnicode_FromStringAndSize(${api}.c_str(), ${api}.length());<% } %>
diff --git a/xbmc/interfaces/python3/typemaps/python.vector.intm b/xbmc/interfaces/python3/typemaps/python.vector.intm
new file mode 100644
index 000000000000..42cbc6d8dd83
--- /dev/null
+++ b/xbmc/interfaces/python3/typemaps/python.vector.intm
@@ -0,0 +1,47 @@
+<%
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+    List templateArgs = swigTypeParser.SwigType_templateparmlist(ltype)
+    vectype = templateArgs[0]
+    boolean ispointer = swigTypeParser.SwigType_ispointer(type)
+    String accessor = ispointer ? '->' : '.'
+    int seq = sequence.increment()
+%>
+    if (${slarg})
+    {
+      bool isTuple = PyObject_TypeCheck(${slarg},&PyTuple_Type);
+      if (!isTuple && !PyObject_TypeCheck(${slarg},&PyList_Type))
+        throw WrongTypeException("The parameter \"${api}\" must be either a Tuple or a List.");
+
+      <%  if (ispointer) print("${api} = new std::vector<${swigTypeParser.SwigType_str(vectype)}>();") %>
+      PyObject *pyentry${seq} = NULL;
+      int vecSize = (isTuple ? PyTuple_Size(${slarg}) : PyList_Size(${slarg}));
+      for(int i = 0; i < vecSize; i++)
+      {
+        pyentry${seq} = (isTuple ? PyTuple_GetItem(${slarg}, i) : PyList_GetItem(${slarg}, i));
+        ${swigTypeParser.SwigType_str(swigTypeParser.SwigType_ltype(vectype))} entry${seq};
+        ${helper.getInConversion(vectype, 'entry' + seq, 'pyentry' + seq, method,
+                                 [ 'type' : vectype,
+                                   'ltype' : swigTypeParser.SwigType_ltype(vectype),
+                                   'sequence' : sequence
+                                   ])}
+        ${api}${accessor}push_back(entry${seq});
+      }
+    }
diff --git a/xbmc/interfaces/python3/typemaps/python.vector.outtm b/xbmc/interfaces/python3/typemaps/python.vector.outtm
new file mode 100644
index 000000000000..941204ea7981
--- /dev/null
+++ b/xbmc/interfaces/python3/typemaps/python.vector.outtm
@@ -0,0 +1,48 @@
+<%
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+    List templateArgs = swigTypeParser.SwigType_templateparmlist(type)
+    vectype = templateArgs[0]
+    boolean ispointer = swigTypeParser.SwigType_ispointer(type)
+    String accessor = ispointer ? '->' : '.'
+    seq = sequence.increment()
+
+    if (ispointer)
+    {
+%>
+    if (${api} != NULL)
+    { 
+<%  }  %>
+      ${result} = PyList_New(0);
+
+      for (std::vector<${swigTypeParser.SwigType_str(vectype)}>::iterator iter = ${api}${accessor}begin(); iter != ${api}${accessor}end(); ++iter)
+      {
+        ${swigTypeParser.SwigType_str(swigTypeParser.SwigType_ltype(vectype))}& entry${seq} = *iter;
+        PyObject* pyentry${seq};
+        ${helper.getOutConversion(vectype,'result',method,[ 'result' : 'pyentry' + seq, 'api' : 'entry' + seq, 'sequence' : sequence ])}
+        PyList_Append(${result}, pyentry${seq});
+        Py_DECREF(pyentry${seq});
+      }
+<%
+    if (ispointer)
+    {
+%>
+    }
+<%  }  %>
diff --git a/xbmc/network/httprequesthandler/python3/CMakeLists.txt b/xbmc/network/httprequesthandler/python3/CMakeLists.txt
new file mode 100644
index 000000000000..7bbbad9b4d35
--- /dev/null
+++ b/xbmc/network/httprequesthandler/python3/CMakeLists.txt
@@ -0,0 +1,10 @@
+if(MICROHTTPD_FOUND AND PYTHON_FOUND)
+  set(SOURCES HTTPPythonInvoker.cpp
+              HTTPPythonWsgiInvoker.cpp)
+
+  set(HEADERS HTTPPythonInvoker.h
+              HTTPPythonRequest.h
+              HTTPPythonWsgiInvoker.h)
+
+  core_add_library(network_httprequesthandlers_python)
+endif()
diff --git a/xbmc/network/httprequesthandler/python3/HTTPPythonInvoker.cpp b/xbmc/network/httprequesthandler/python3/HTTPPythonInvoker.cpp
new file mode 100644
index 000000000000..f59986a3ca22
--- /dev/null
+++ b/xbmc/network/httprequesthandler/python3/HTTPPythonInvoker.cpp
@@ -0,0 +1,84 @@
+/*
+ *      Copyright (C) 2015 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "HTTPPythonInvoker.h"
+#include "CompileInfo.h"
+#include "utils/StringUtils.h"
+
+CHTTPPythonInvoker::CHTTPPythonInvoker(ILanguageInvocationHandler* invocationHandler, HTTPPythonRequest* request)
+  : CPythonInvoker(invocationHandler),
+    m_request(request),
+    m_internalError(false)
+{ }
+
+CHTTPPythonInvoker::~CHTTPPythonInvoker()
+{
+  delete m_request;
+  m_request = NULL;
+}
+
+void CHTTPPythonInvoker::onAbort()
+{
+  if (m_request == NULL)
+    return;
+
+  m_internalError = true;
+  m_request->responseType = HTTPError;
+  m_request->responseStatus = MHD_HTTP_INTERNAL_SERVER_ERROR;
+}
+
+void CHTTPPythonInvoker::onError(const std::string& exceptionType /* = "" */, const std::string& exceptionValue /* = "" */, const std::string& exceptionTraceback /* = "" */)
+{
+  if (m_request == NULL)
+    return;
+
+  m_internalError = true;
+  m_request->responseType = HTTPMemoryDownloadNoFreeCopy;
+  m_request->responseStatus = MHD_HTTP_INTERNAL_SERVER_ERROR;
+
+  std::string output;
+  if (!exceptionType.empty())
+  {
+    output += exceptionType;
+
+    if (!exceptionValue.empty())
+      output += ": " + exceptionValue;
+    output += "\n";
+  }
+
+  if (!exceptionTraceback .empty())
+    output += exceptionTraceback;
+
+  // replace all special characters
+
+  StringUtils::Replace(output, "<", "&lt;");
+  StringUtils::Replace(output, ">", "&gt;");
+  StringUtils::Replace(output, " ", "&nbsp;");
+  StringUtils::Replace(output, "\n", "\n<br />");
+
+  if (!exceptionType.empty())
+  {
+    // now make the type and value bold (needs to be done here because otherwise the < and > would have been replaced
+    output = "<b>" + output;
+    output.insert(output.find('\n'), "</b>");
+  }
+
+  m_request->responseData = "<html><head><title>" + std::string(CCompileInfo::GetAppName()) + ": python error</title></head><body>" + output + "</body></html>";
+}
diff --git a/xbmc/network/httprequesthandler/python3/HTTPPythonInvoker.h b/xbmc/network/httprequesthandler/python3/HTTPPythonInvoker.h
new file mode 100644
index 000000000000..a09919c602e0
--- /dev/null
+++ b/xbmc/network/httprequesthandler/python3/HTTPPythonInvoker.h
@@ -0,0 +1,44 @@
+#pragma once
+/*
+*      Copyright (C) 2015 Team XBMC
+*      http://xbmc.org
+*
+*  This Program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License as published by
+*  the Free Software Foundation; either version 2, or (at your option)
+*  any later version.
+*
+*  This Program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with XBMC; see the file COPYING.  If not, see
+*  <http://www.gnu.org/licenses/>.
+*
+*/
+
+#include <string>
+
+#include "interfaces/python/PythonInvoker.h"
+#include "network/httprequesthandler/IHTTPRequestHandler.h"
+#include "network/httprequesthandler/python/HTTPPythonRequest.h"
+
+class CHTTPPythonInvoker : public CPythonInvoker
+{
+public:
+  ~CHTTPPythonInvoker() override;
+
+  virtual HTTPPythonRequest* GetRequest() = 0;
+
+protected:
+  CHTTPPythonInvoker(ILanguageInvocationHandler* invocationHandler, HTTPPythonRequest* request);
+
+  // overrides of CPythonInvoker
+  void onAbort() override;
+  void onError(const std::string& exceptionType = "", const std::string& exceptionValue = "", const std::string& exceptionTraceback = "") override;
+
+  HTTPPythonRequest* m_request;
+  bool m_internalError;
+};
diff --git a/xbmc/network/httprequesthandler/python3/HTTPPythonRequest.h b/xbmc/network/httprequesthandler/python3/HTTPPythonRequest.h
new file mode 100644
index 000000000000..485c7382111f
--- /dev/null
+++ b/xbmc/network/httprequesthandler/python3/HTTPPythonRequest.h
@@ -0,0 +1,54 @@
+#pragma once
+/*
+ *      Copyright (C) 2015 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <stdint.h>
+
+#include <map>
+#include <string>
+
+#include "XBDateTime.h"
+#include "network/httprequesthandler/IHTTPRequestHandler.h"
+
+typedef struct HTTPPythonRequest
+{
+  struct MHD_Connection *connection;
+  std::string hostname;
+  uint16_t port;
+  std::string url;
+  std::string path;
+  std::string file;
+  HTTPMethod method;
+  std::string version;
+  std::multimap<std::string, std::string> headerValues;
+  std::map<std::string, std::string> getValues;
+  std::map<std::string, std::string> postValues;
+  std::string requestContent;
+  CDateTime requestTime;
+  CDateTime lastModifiedTime;
+
+  HTTPResponseType responseType;
+  int responseStatus;
+  std::string responseContentType;
+  std::string responseData;
+  size_t responseLength;
+  std::multimap<std::string, std::string> responseHeaders;
+  std::multimap<std::string, std::string> responseHeadersError;
+} HTTPPythonRequest;
\ No newline at end of file
diff --git a/xbmc/network/httprequesthandler/python3/HTTPPythonWsgiInvoker.cpp b/xbmc/network/httprequesthandler/python3/HTTPPythonWsgiInvoker.cpp
new file mode 100644
index 000000000000..ce8e5ecb8b69
--- /dev/null
+++ b/xbmc/network/httprequesthandler/python3/HTTPPythonWsgiInvoker.cpp
@@ -0,0 +1,453 @@
+/*
+ *      Copyright (C) 2015 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "HTTPPythonWsgiInvoker.h"
+
+#include <utility>
+
+#include "addons/Webinterface.h"
+#include "interfaces/legacy/wsgi/WsgiErrorStream.h"
+#include "interfaces/legacy/wsgi/WsgiInputStream.h"
+#include "interfaces/legacy/wsgi/WsgiResponse.h"
+#include "interfaces/python/swig.h"
+#include "URL.h"
+#include "utils/URIUtils.h"
+
+#define MODULE      "xbmc"
+
+#define RUNSCRIPT_PREAMBLE \
+  "" \
+  "import " MODULE "\n" \
+  "xbmc.abortRequested = False\n" \
+  "class xbmcout:\n" \
+  "  def __init__(self, loglevel=" MODULE ".LOGNOTICE):\n" \
+  "    self.ll=loglevel\n" \
+  "  def write(self, data):\n" \
+  "    " MODULE ".log(data,self.ll)\n" \
+  "  def close(self):\n" \
+  "    " MODULE ".log('.')\n" \
+  "  def flush(self):\n" \
+  "    " MODULE ".log('.')\n" \
+  "import sys\n" \
+  "sys.stdout = xbmcout()\n" \
+  "sys.stderr = xbmcout(" MODULE ".LOGERROR)\n" \
+  ""
+
+#define RUNSCRIPT_SETUPTOOLS_HACK \
+  "" \
+  "import imp,sys\n" \
+  "pkg_resources_code = \\\n" \
+  "\"\"\"\n" \
+  "def resource_filename(__name__,__path__):\n" \
+  "  return __path__\n" \
+  "\"\"\"\n" \
+  "pkg_resources = imp.new_module('pkg_resources')\n" \
+  "exec pkg_resources_code in pkg_resources.__dict__\n" \
+  "sys.modules['pkg_resources'] = pkg_resources\n" \
+  ""
+
+#define RUNSCRIPT_POSTSCRIPT \
+        MODULE ".log('-->HTTP Python WSGI Interpreter Initialized<--', " MODULE ".LOGNOTICE)\n" \
+        ""
+
+#if defined(TARGET_ANDROID)
+#define RUNSCRIPT \
+  RUNSCRIPT_PREAMBLE RUNSCRIPT_SETUPTOOLS_HACK RUNSCRIPT_POSTSCRIPT
+#else
+#define RUNSCRIPT \
+  RUNSCRIPT_PREAMBLE RUNSCRIPT_POSTSCRIPT
+#endif
+
+namespace PythonBindings {
+  void initModule_xbmc(void);
+  void initModule_xbmcwsgi(void);
+}
+
+using namespace PythonBindings;
+
+typedef struct
+{
+  const char *name;
+  CPythonInvoker::PythonModuleInitialization initialization;
+} PythonModule;
+
+static PythonModule PythonModules[] =
+{
+  { "xbmc",           initModule_xbmc },
+  { "xbmcwsgi",       initModule_xbmcwsgi }
+};
+
+#define PythonModulesSize sizeof(PythonModules) / sizeof(PythonModule)
+
+CHTTPPythonWsgiInvoker::CHTTPPythonWsgiInvoker(ILanguageInvocationHandler* invocationHandler, HTTPPythonRequest* request)
+  : CHTTPPythonInvoker(invocationHandler, request),
+    m_wsgiResponse(NULL)
+{ }
+
+CHTTPPythonWsgiInvoker::~CHTTPPythonWsgiInvoker()
+{
+  delete m_wsgiResponse;
+  m_wsgiResponse = NULL;
+}
+
+HTTPPythonRequest* CHTTPPythonWsgiInvoker::GetRequest()
+{
+  if (m_request == NULL || m_wsgiResponse == NULL)
+    return NULL;
+
+  if (m_internalError)
+    return m_request;
+
+  m_wsgiResponse->Finalize(m_request);
+  return m_request;
+}
+
+void CHTTPPythonWsgiInvoker::executeScript(void *fp, const std::string &script, void *module, void *moduleDict)
+{
+  if (m_request == NULL || m_addon == NULL || m_addon->Type() != ADDON::ADDON_WEB_INTERFACE ||
+      fp == NULL || script.empty() || module == NULL || moduleDict == NULL)
+    return;
+
+  ADDON::CWebinterface* webinterface = static_cast<ADDON::CWebinterface*>(m_addon.get());
+  if (webinterface->GetType() != ADDON::WebinterfaceTypeWsgi)
+  {
+    CLog::Log(LOGERROR, "CHTTPPythonWsgiInvoker: trying to execute a non-WSGI script at %s", script.c_str());
+    return;
+  }
+
+  PyObject* pyScript = NULL;
+  PyObject* pyModule = NULL;
+  PyObject* pyEntryPoint = NULL;
+  std::map<std::string, std::string> cgiEnvironment;
+  PyObject* pyEnviron = NULL;
+  PyObject* pyStart_response = NULL;
+  PyObject* pyArgs = NULL;
+  PyObject* pyResult = NULL;
+  PyObject* pyResultIterator = NULL;
+  PyObject* pyIterResult = NULL;
+
+  // get the script
+  std::string scriptName = URIUtils::GetFileName(script);
+  URIUtils::RemoveExtension(scriptName);
+  pyScript = PyUnicode_FromStringAndSize(scriptName.c_str(), scriptName.size());
+  if (pyScript == NULL)
+  {
+    CLog::Log(LOGERROR, "CHTTPPythonWsgiInvoker: failed to convert script \"%s\" to python string", script.c_str());
+    return;
+  }
+
+  // load the script
+  CLog::Log(LOGDEBUG, "CHTTPPythonWsgiInvoker: loading WSGI script \"%s\"", script.c_str());
+  pyModule = PyImport_Import(pyScript);
+  Py_DECREF(pyScript);
+  if (pyModule == NULL)
+  {
+    CLog::Log(LOGERROR, "CHTTPPythonWsgiInvoker: failed to load WSGI script \"%s\"", script.c_str());
+    return;
+  }
+
+  // get the entry point
+  const std::string& entryPoint = webinterface->EntryPoint();
+  CLog::Log(LOGDEBUG, "CHTTPPythonWsgiInvoker: loading entry point \"%s\" from WSGI script \"%s\"", entryPoint.c_str(), script.c_str());
+  pyEntryPoint = PyObject_GetAttrString(pyModule, entryPoint.c_str());
+  if (pyEntryPoint == NULL)
+  {
+    CLog::Log(LOGERROR, "CHTTPPythonWsgiInvoker: failed to entry point \"%s\" from WSGI script \"%s\"", entryPoint.c_str(), script.c_str());
+    goto cleanup;
+  }
+
+  // check if the loaded entry point is a callable function
+  if (!PyCallable_Check(pyEntryPoint))
+  {
+    CLog::Log(LOGERROR, "CHTTPPythonWsgiInvoker: defined entry point \"%s\" from WSGI script \"%s\" is not callable", entryPoint.c_str(), script.c_str());
+    goto cleanup;
+  }
+
+  // prepare the WsgiResponse object
+  m_wsgiResponse = new XBMCAddon::xbmcwsgi::WsgiResponse();
+  if (m_wsgiResponse == NULL)
+  {
+    CLog::Log(LOGERROR, "CHTTPPythonWsgiInvoker: failed to create WsgiResponse object for WSGI script \"%s\"", script.c_str());
+    goto cleanup;
+  }
+
+  try
+  {
+    // prepare the start_response callable
+    pyStart_response = PythonBindings::makePythonInstance(m_wsgiResponse, true);
+
+    // create the (CGI) environment dictionary
+    cgiEnvironment = createCgiEnvironment(m_request, m_addon);
+    // and turn it into a python dictionary
+    pyEnviron = PyDict_New();
+    for (std::map<std::string, std::string>::const_iterator cgiEnv = cgiEnvironment.begin(); cgiEnv != cgiEnvironment.end(); ++cgiEnv)
+    {
+      PyObject* pyEnvEntry = PyUnicode_FromStringAndSize(cgiEnv->second.c_str(), cgiEnv->second.size());
+      PyDict_SetItemString(pyEnviron, cgiEnv->first.c_str(), pyEnvEntry);
+      Py_DECREF(pyEnvEntry);
+    }
+
+    // add the WSGI-specific environment variables
+    addWsgiEnvironment(m_request, pyEnviron);
+  }
+  catch (const XBMCAddon::WrongTypeException& e)
+  {
+    CLog::Log(LOGERROR, "CHTTPPythonWsgiInvoker: failed to prepare WsgiResponse object for WSGI script \"%s\" with wrong type exception: %s", script.c_str(), e.GetMessage());
+    goto cleanup;
+  }
+  catch (const XbmcCommons::Exception& e)
+  {
+    CLog::Log(LOGERROR, "CHTTPPythonWsgiInvoker: failed to prepare WsgiResponse object for WSGI script \"%s\" with exception: %s", script.c_str(), e.GetMessage());
+    goto cleanup;
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "CHTTPPythonWsgiInvoker: failed to prepare WsgiResponse object for WSGI script \"%s\" with unknown exception", script.c_str());
+    goto cleanup;
+  }
+
+  // put together the arguments
+  pyArgs = PyTuple_Pack(2, pyEnviron, pyStart_response);
+  Py_DECREF(pyEnviron);
+  Py_DECREF(pyStart_response);
+
+  // call the given handler with the prepared arguments
+  pyResult = PyObject_CallObject(pyEntryPoint, pyArgs);
+  Py_DECREF(pyArgs);
+  if (pyResult == NULL)
+  {
+    CLog::Log(LOGERROR, "CHTTPPythonWsgiInvoker: no result for WSGI script \"%s\"", script.c_str());
+    goto cleanup;
+  }
+
+  // try to get an iterator from the result object
+  pyResultIterator = PyObject_GetIter(pyResult);
+  if (pyResultIterator == NULL || !PyIter_Check(pyResultIterator))
+  {
+    CLog::Log(LOGERROR, "CHTTPPythonWsgiInvoker: result of WSGI script \"%s\" is not iterable", script.c_str());
+    goto cleanup;
+  }
+
+  // go through all the iterables in the result and turn them into strings
+  while ((pyIterResult = PyIter_Next(pyResultIterator)) != NULL)
+  {
+    std::string result;
+    try
+    {
+      PythonBindings::PyXBMCGetUnicodeString(result, pyIterResult, false, "result", "handle_request");
+    }
+    catch (const XBMCAddon::WrongTypeException& e)
+    {
+      CLog::Log(LOGERROR, "CHTTPPythonWsgiInvoker: failed to parse result iterable object for WSGI script \"%s\" with wrong type exception: %s", script.c_str(), e.GetMessage());
+      goto cleanup;
+    }
+    catch (const XbmcCommons::Exception& e)
+    {
+      CLog::Log(LOGERROR, "CHTTPPythonWsgiInvoker: failed to parse result iterable object for WSGI script \"%s\" with exception: %s", script.c_str(), e.GetMessage());
+      goto cleanup;
+    }
+    catch (...)
+    {
+      CLog::Log(LOGERROR, "CHTTPPythonWsgiInvoker: failed to parse result iterable object for WSGI script \"%s\" with unknown exception", script.c_str());
+      goto cleanup;
+    }
+
+    // append the result string to the response
+    m_wsgiResponse->Append(result);
+  }
+
+cleanup:
+  if (pyIterResult != NULL)
+  {
+    Py_DECREF(pyIterResult);
+  }
+  if (pyResultIterator != NULL)
+  {
+    // Call optional close method on iterator
+    if (PyObject_HasAttrString(pyResultIterator, (char*)"close") == 1)
+    {
+      if (PyObject_CallMethod(pyResultIterator, (char*)"close", NULL) == NULL)
+        CLog::Log(LOGERROR, "CHTTPPythonWsgiInvoker: failed to close iterator object for WSGI script \"%s\"", script.c_str());
+    }
+    Py_DECREF(pyResultIterator);
+  }
+  if (pyResult != NULL)
+  {
+    Py_DECREF(pyResult);
+  }
+  if (pyEntryPoint != NULL)
+  {
+    Py_DECREF(pyEntryPoint);
+  }
+  if (pyModule != NULL)
+  {
+    Py_DECREF(pyModule);
+  }
+}
+
+std::map<std::string, CPythonInvoker::PythonModuleInitialization> CHTTPPythonWsgiInvoker::getModules() const
+{
+  static std::map<std::string, PythonModuleInitialization> modules;
+  if (modules.empty())
+  {
+    for (size_t i = 0; i < PythonModulesSize; i++)
+      modules.insert(std::make_pair(PythonModules[i].name, PythonModules[i].initialization));
+  }
+
+  return modules;
+}
+
+const char* CHTTPPythonWsgiInvoker::getInitializationScript() const
+{
+  return RUNSCRIPT;
+}
+
+std::map<std::string, std::string> CHTTPPythonWsgiInvoker::createCgiEnvironment(const HTTPPythonRequest* httpRequest, ADDON::AddonPtr addon)
+{
+  std::map<std::string, std::string> environment;
+
+  // REQUEST_METHOD
+  std::string requestMethod;
+  switch (httpRequest->method)
+  {
+  case HEAD:
+    requestMethod = "HEAD";
+    break;
+
+  case POST:
+    requestMethod = "POST";
+    break;
+
+  case GET:
+  default:
+    requestMethod = "GET";
+    break;
+  }
+  environment.insert(std::make_pair("REQUEST_METHOD", requestMethod));
+
+  // SCRIPT_NAME
+  std::string scriptName = std::dynamic_pointer_cast<ADDON::CWebinterface>(addon)->GetBaseLocation();
+  environment.insert(std::make_pair("SCRIPT_NAME", scriptName));
+
+  // PATH_INFO
+  std::string pathInfo = httpRequest->path.substr(scriptName.size());
+  environment.insert(std::make_pair("PATH_INFO", pathInfo));
+
+  // QUERY_STRING
+  CURL url(httpRequest->url);
+  environment.insert(std::make_pair("QUERY_STRING", url.GetOptions()));
+
+  // CONTENT_TYPE
+  std::string headerValue;
+  std::multimap<std::string, std::string>::const_iterator headerIt = httpRequest->headerValues.find(MHD_HTTP_HEADER_CONTENT_TYPE);
+  if (headerIt != httpRequest->headerValues.end())
+    headerValue = headerIt->second;
+  environment.insert(std::make_pair("CONTENT_TYPE", headerValue));
+
+  // CONTENT_LENGTH
+  headerValue.clear();
+  headerIt = httpRequest->headerValues.find(MHD_HTTP_HEADER_CONTENT_LENGTH);
+  if (headerIt != httpRequest->headerValues.end())
+    headerValue = headerIt->second;
+  environment.insert(std::make_pair("CONTENT_LENGTH", headerValue));
+
+  // SERVER_NAME
+  environment.insert(std::make_pair("SERVER_NAME", httpRequest->hostname));
+
+  // SERVER_PORT
+  environment.insert(std::make_pair("SERVER_PORT", StringUtils::Format("%hu", httpRequest->port)));
+
+  // SERVER_PROTOCOL
+  environment.insert(std::make_pair("SERVER_PROTOCOL", httpRequest->version));
+
+  // HTTP_<HEADER_NAME>
+  for (headerIt = httpRequest->headerValues.begin(); headerIt != httpRequest->headerValues.end(); ++headerIt)
+  {
+    std::string headerName = headerIt->first;
+    StringUtils::ToUpper(headerName);
+    environment.insert(std::make_pair("HTTP_" + headerName, headerIt->second));
+  }
+
+  return environment;
+}
+
+void CHTTPPythonWsgiInvoker::addWsgiEnvironment(HTTPPythonRequest* request, void* environment)
+{
+  if (environment == nullptr)
+    return;
+
+  PyObject* pyEnviron = reinterpret_cast<PyObject*>(environment);
+  if (pyEnviron == nullptr)
+    return;
+
+  // WSGI-defined variables
+  {
+    // wsgi.version
+    PyObject* pyValue = Py_BuildValue("(ii)", 1, 0);
+    PyDict_SetItemString(pyEnviron, "wsgi.version", pyValue);
+    Py_DECREF(pyValue);
+  }
+  {
+    // wsgi.url_scheme
+    PyObject* pyValue = PyUnicode_FromStringAndSize("http", 4);
+    PyDict_SetItemString(pyEnviron, "wsgi.url_scheme", pyValue);
+    Py_DECREF(pyValue);
+  }
+  {
+    // wsgi.input
+    XBMCAddon::xbmcwsgi::WsgiInputStream* wsgiInputStream = new XBMCAddon::xbmcwsgi::WsgiInputStream();
+    if (request != NULL)
+      wsgiInputStream->SetRequest(request);
+
+    PythonBindings::prepareForReturn(wsgiInputStream);
+    PyObject* pyWsgiInputStream = PythonBindings::makePythonInstance(wsgiInputStream, false);
+    PyDict_SetItemString(pyEnviron, "wsgi.input", pyWsgiInputStream);
+    Py_DECREF(pyWsgiInputStream);
+  }
+  {
+    // wsgi.errors
+    XBMCAddon::xbmcwsgi::WsgiErrorStream* wsgiErrorStream = new XBMCAddon::xbmcwsgi::WsgiErrorStream();
+    if (request != NULL)
+      wsgiErrorStream->SetRequest(request);
+
+    PythonBindings::prepareForReturn(wsgiErrorStream);
+    PyObject* pyWsgiErrorStream = PythonBindings::makePythonInstance(wsgiErrorStream, false);
+    PyDict_SetItemString(pyEnviron, "wsgi.errors", pyWsgiErrorStream);
+    Py_DECREF(pyWsgiErrorStream);
+  }
+  {
+    // wsgi.multithread
+    PyObject* pyValue = Py_BuildValue("b", false);
+    PyDict_SetItemString(pyEnviron, "wsgi.multithread", pyValue);
+    Py_DECREF(pyValue);
+  }
+  {
+    // wsgi.multiprocess
+    PyObject* pyValue = Py_BuildValue("b", false);
+    PyDict_SetItemString(pyEnviron, "wsgi.multiprocess", pyValue);
+    Py_DECREF(pyValue);
+  }
+  {
+    // wsgi.run_once
+    PyObject* pyValue = Py_BuildValue("b", true);
+    PyDict_SetItemString(pyEnviron, "wsgi.run_once", pyValue);
+    Py_DECREF(pyValue);
+  }
+}
diff --git a/xbmc/network/httprequesthandler/python3/HTTPPythonWsgiInvoker.h b/xbmc/network/httprequesthandler/python3/HTTPPythonWsgiInvoker.h
new file mode 100644
index 000000000000..6231d9644062
--- /dev/null
+++ b/xbmc/network/httprequesthandler/python3/HTTPPythonWsgiInvoker.h
@@ -0,0 +1,58 @@
+#pragma once
+/*
+*      Copyright (C) 2015 Team XBMC
+*      http://xbmc.org
+*
+*  This Program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License as published by
+*  the Free Software Foundation; either version 2, or (at your option)
+*  any later version.
+*
+*  This Program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with XBMC; see the file COPYING.  If not, see
+*  <http://www.gnu.org/licenses/>.
+*
+*/
+
+#include <map>
+#include <string>
+
+#include "interfaces/python/PythonInvoker.h"
+#include "network/httprequesthandler/IHTTPRequestHandler.h"
+#include "network/httprequesthandler/python/HTTPPythonInvoker.h"
+#include "network/httprequesthandler/python/HTTPPythonRequest.h"
+
+namespace XBMCAddon
+{
+  namespace xbmcwsgi
+  {
+    class WsgiResponse;
+  }
+}
+
+class CHTTPPythonWsgiInvoker : public CHTTPPythonInvoker
+{
+public:
+  CHTTPPythonWsgiInvoker(ILanguageInvocationHandler* invocationHandler, HTTPPythonRequest* request);
+  ~CHTTPPythonWsgiInvoker() override;
+
+  // implementations of CHTTPPythonInvoker
+  HTTPPythonRequest* GetRequest() override;
+
+protected:
+  // overrides of CPythonInvoker
+  void executeScript(void *fp, const std::string &script, void *module, void *moduleDict) override;
+  std::map<std::string, PythonModuleInitialization> getModules() const override;
+  const char* getInitializationScript() const override;
+
+private:
+  static std::map<std::string, std::string> createCgiEnvironment(const HTTPPythonRequest* httpRequest, ADDON::AddonPtr addon);
+  static void addWsgiEnvironment(HTTPPythonRequest* request, void* environment);
+
+  XBMCAddon::xbmcwsgi::WsgiResponse* m_wsgiResponse;
+};

From 476b30054e914d48784efc22e7a3e3714aee2c21 Mon Sep 17 00:00:00 2001
From: Arpit Nandwani <arpit.nandwani@gmail.com>
Date: Wed, 19 Jul 2017 19:36:03 +0530
Subject: [PATCH 02/25] Updated the GIL acquisition and release statements

---
 xbmc/interfaces/python3/PythonInvoker.cpp |  9 ++++-----
 xbmc/interfaces/python3/XBPython.cpp      | 18 +++++++-----------
 2 files changed, 11 insertions(+), 16 deletions(-)

diff --git a/xbmc/interfaces/python3/PythonInvoker.cpp b/xbmc/interfaces/python3/PythonInvoker.cpp
index 324ce424e59b..ef165c4cce0e 100644
--- a/xbmc/interfaces/python3/PythonInvoker.cpp
+++ b/xbmc/interfaces/python3/PythonInvoker.cpp
@@ -168,7 +168,8 @@ bool CPythonInvoker::execute(const std::string &script, const std::vector<std::s
   CLog::Log(LOGDEBUG, "CPythonInvoker(%d, %s): start processing", GetId(), m_sourceFile.c_str());
 
   // get the global lock
-  PyEval_AcquireLock();
+  extern PyThreadState* savestate;
+  PyEval_RestoreThread(savestate);
   PyThreadState* state = Py_NewInterpreter();
   if (state == NULL)
   {
@@ -264,8 +265,7 @@ bool CPythonInvoker::execute(const std::string &script, const std::vector<std::s
     stopping = m_stop;
   }
 
-  PyEval_AcquireLock();
-  PyThreadState_Swap(state);
+  PyEval_AcquireThread(state);
 
   bool failed = false;
   std::string exceptionType, exceptionValue, exceptionTraceback;
@@ -404,8 +404,7 @@ bool CPythonInvoker::execute(const std::string &script, const std::vector<std::s
     m_threadState = NULL;
   }
 
-  PyEval_AcquireLock();
-  PyThreadState_Swap(state);
+  PyEval_AcquireThread(state);
 
   onDeinitialization();
 
diff --git a/xbmc/interfaces/python3/XBPython.cpp b/xbmc/interfaces/python3/XBPython.cpp
index 6227f261e24d..fcd73164a5c4 100644
--- a/xbmc/interfaces/python3/XBPython.cpp
+++ b/xbmc/interfaces/python3/XBPython.cpp
@@ -45,7 +45,7 @@
 #include "interfaces/legacy/AddonUtils.h"
 #include "interfaces/python/AddonPythonInvoker.h"
 #include "interfaces/python/PythonInvoker.h"
-
+PyThreadState* savestate;
 using namespace ANNOUNCEMENT;
 
 XBPython::XBPython()
@@ -459,8 +459,7 @@ void XBPython::Finalize()
     m_mainThreadState = NULL; // clear the main thread state before releasing the lock
     {
       CSingleExit exit(m_critSection);
-      PyEval_AcquireLock();
-      PyThreadState_Swap(curTs);
+	  PyEval_AcquireThread(curTs);
 
       Py_Finalize();
       PyEval_ReleaseLock();
@@ -593,24 +592,21 @@ bool XBPython::OnScriptInitialized(ILanguageInvoker *invoker)
     CEnvironment::putenv(buf);
 #endif
 
-    if (PyEval_ThreadsInitialized())
-      PyEval_AcquireLock();
-    else
-      PyEval_InitThreads();
-
     Py_Initialize();
-    PyEval_ReleaseLock();
 
     // If this is not the first time we initialize Python, the interpreter
     // lock already exists and we need to lock it as PyEval_InitThreads
     // would not do that in that case.
-    PyEval_AcquireLock();
     char* python_argv[1] = { (char*)"" };
     PySys_SetArgv(1, (wchar_t **)python_argv);
+    if (PyEval_ThreadsInitialized())
+      PyEval_AcquireLock();
+    else
+      PyEval_InitThreads();
 
     if (!(m_mainThreadState = PyThreadState_Get()))
       CLog::Log(LOGERROR, "Python threadstate is NULL.");
-    PyEval_ReleaseLock();
+	savestate = PyEval_SaveThread();
 
     m_bInitialized = true;
   }

From 50b183714e971b7f069116c5735f24961845960f Mon Sep 17 00:00:00 2001
From: Arpit Nandwani <arpit.nandwani@gmail.com>
Date: Wed, 19 Jul 2017 19:47:05 +0530
Subject: [PATCH 03/25] Updated Module Initialization

Updated module initialization from init<module> to PyInit_<module> and added the new modules to built-in library through PyImport_AppendInitTab
---
 xbmc/interfaces/python3/AddonPythonInvoker.cpp  | 28 +++++++++++++++----------
 xbmc/interfaces/python3/PythonInvoker.cpp       |  4 ++--
 xbmc/interfaces/python3/PythonInvoker.h         |  2 ++
 xbmc/interfaces/python3/PythonSwig.cpp.template | 25 ++++++++++++----------
 xbmc/interfaces/swig/CMakeLists.txt             | 19 +++++++----------
 5 files changed, 42 insertions(+), 36 deletions(-)

diff --git a/xbmc/interfaces/python3/AddonPythonInvoker.cpp b/xbmc/interfaces/python3/AddonPythonInvoker.cpp
index 92110a92b1cc..37ba6c0b202b 100644
--- a/xbmc/interfaces/python3/AddonPythonInvoker.cpp
+++ b/xbmc/interfaces/python3/AddonPythonInvoker.cpp
@@ -77,11 +77,11 @@
 #endif
 
 namespace PythonBindings {
-  void initModule_xbmcgui(void);
-  void initModule_xbmc(void);
-  void initModule_xbmcplugin(void);
-  void initModule_xbmcaddon(void);
-  void initModule_xbmcvfs(void);
+  PyObject *PyInit_Module_xbmcgui(void);
+  PyObject *PyInit_Module_xbmc(void);
+  PyObject *PyInit_Module_xbmcplugin(void);
+  PyObject *PyInit_Module_xbmcaddon(void);
+  PyObject *PyInit_Module_xbmcvfs(void);
 }
 
 using namespace PythonBindings;
@@ -94,18 +94,24 @@ typedef struct
 
 static PythonModule PythonModules[] =
   {
-    { "xbmcgui",    initModule_xbmcgui    },
-    { "xbmc",       initModule_xbmc       },
-    { "xbmcplugin", initModule_xbmcplugin },
-    { "xbmcaddon",  initModule_xbmcaddon  },
-    { "xbmcvfs",    initModule_xbmcvfs    }
+    { "xbmcgui",    PyInit_Module_xbmcgui    },
+    { "xbmc",       PyInit_Module_xbmc       },
+    { "xbmcplugin", PyInit_Module_xbmcplugin },
+    { "xbmcaddon",  PyInit_Module_xbmcaddon  },
+    { "xbmcvfs",    PyInit_Module_xbmcvfs    }
   };
 
 #define PythonModulesSize sizeof(PythonModules) / sizeof(PythonModule)
 
 CAddonPythonInvoker::CAddonPythonInvoker(ILanguageInvocationHandler *invocationHandler)
   : CPythonInvoker(invocationHandler)
-{ }
+{
+    PyImport_AppendInittab("xbmcgui",    PyInit_Module_xbmcgui);
+    PyImport_AppendInittab("xbmc",       PyInit_Module_xbmc);
+    PyImport_AppendInittab("xbmcplugin", PyInit_Module_xbmcplugin);
+    PyImport_AppendInittab("xbmcaddon",  PyInit_Module_xbmcaddon);
+    PyImport_AppendInittab("xbmcvfs",    PyInit_Module_xbmcvfs);
+}
 
 CAddonPythonInvoker::~CAddonPythonInvoker() = default;
 
diff --git a/xbmc/interfaces/python3/PythonInvoker.cpp b/xbmc/interfaces/python3/PythonInvoker.cpp
index ef165c4cce0e..189846feff01 100644
--- a/xbmc/interfaces/python3/PythonInvoker.cpp
+++ b/xbmc/interfaces/python3/PythonInvoker.cpp
@@ -632,8 +632,8 @@ bool CPythonInvoker::initializeModule(PythonModuleInitialization module)
   if (module == NULL)
     return false;
 
-  module();
-  return true;
+  return module() != nullptr;
+
 }
 
 void CPythonInvoker::getAddonModuleDeps(const ADDON::AddonPtr& addon, std::set<std::string>& paths)
diff --git a/xbmc/interfaces/python3/PythonInvoker.h b/xbmc/interfaces/python3/PythonInvoker.h
index f461355f6fdf..86142ecbe83c 100644
--- a/xbmc/interfaces/python3/PythonInvoker.h
+++ b/xbmc/interfaces/python3/PythonInvoker.h
@@ -27,6 +27,8 @@
 #include "threads/CriticalSection.h"
 #include "threads/Event.h"
 
+typedef struct _object PyObject;
+
 class CPythonInvoker : public ILanguageInvoker
 {
 public:
diff --git a/xbmc/interfaces/python3/PythonSwig.cpp.template b/xbmc/interfaces/python3/PythonSwig.cpp.template
index 1b2c9fcc3289..345a31c7638d 100644
--- a/xbmc/interfaces/python3/PythonSwig.cpp.template
+++ b/xbmc/interfaces/python3/PythonSwig.cpp.template
@@ -910,7 +910,16 @@ namespace PythonBindings
     }
   }
 
-  void initModule_${module.@name}()
+  static struct PyModuleDef createModule
+  {
+      PyModuleDef_HEAD_INIT,
+      (char*)"${module.@name}",
+      "",
+      -1,
+      ${module.@name}_methods
+  };
+
+  PyObject *PyInit_Module_${module.@name}()
   {
     initTypes();
 
@@ -920,16 +929,9 @@ namespace PythonBindings
 <% classNameAsVariables.each { %>
     Py_INCREF(&(Ty${it}_Type.pythonType));<%
    }%>
-    static struct PyModuleDef nameAsVariable
-    {
-        PyModuleDef_HEAD_INIT,
-        (char*)"${module.@name}",
-        "",
-        -1,
-        ${module.@name}_methods
-    };
-    module = PyModule_Create(&nameAsVariable);
-    if (module == NULL) return;
+
+    module = PyModule_Create(&createModule);
+    if (module == NULL) return NULL;
 
 <% classes.each { clazz -> %>
     PyModule_AddObject(module, (char*)"${clazz.@sym_name}", (PyObject*)(&(Ty${PythonTools.getClassNameAsVariable(clazz)}_Type.pythonType)));<%
@@ -949,6 +951,7 @@ namespace PythonBindings
         'PyModule_AddIntConstant' : 'PyModule_AddStringConstant' %>
    ${pyCall}(module,"${it.@sym_name}",${it.@value}); <%
   } %>
+  return module;
   }
 
 } // end PythonBindings namespace for python type definitions
diff --git a/xbmc/interfaces/swig/CMakeLists.txt b/xbmc/interfaces/swig/CMakeLists.txt
index 9c7a424a15c7..b05c848b2281 100644
--- a/xbmc/interfaces/swig/CMakeLists.txt
+++ b/xbmc/interfaces/swig/CMakeLists.txt
@@ -10,14 +10,12 @@ function(generate_file file)
     set(devnull "nul")
   endif()
 
-  set(CPP_FILE ${file}.cpp)
-  add_custom_command(OUTPUT ${CPP_FILE}
-                     COMMAND ${SWIG_EXECUTABLE}
-                     ARGS -w401 -c++ -o ${file}.xml -xml -I${CMAKE_SOURCE_DIR}/xbmc -xmllang python ${CMAKE_CURRENT_SOURCE_DIR}/../swig/${file}
-                     COMMAND ${Java_JAVA_EXECUTABLE}
-                     ARGS -cp "${classpath}" groovy.ui.GroovyMain ${CMAKE_SOURCE_DIR}/tools/codegenerator/Generator.groovy ${file}.xml ${CMAKE_CURRENT_SOURCE_DIR}/../python/PythonSwig.cpp.template ${file}.cpp > ${devnull}
-                     DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/../swig/${file} ${CMAKE_CURRENT_SOURCE_DIR}/../python/PythonSwig.cpp.template)
-  set(SOURCES ${SOURCES} "${CPP_FILE}" PARENT_SCOPE)
+	set(CPP_FILE ${file}.cpp)
+execute_process(
+				COMMAND ${SWIG_EXECUTABLE} -w401 -c++ -o ${CMAKE_CURRENT_BINARY_DIR}/${file}.xml -xml -I${CMAKE_SOURCE_DIR}/xbmc -xmllang python ${CMAKE_CURRENT_SOURCE_DIR}/../swig/${file}
+				COMMAND ${Java_JAVA_EXECUTABLE} -cp "${classpath}" groovy.ui.GroovyMain ${CMAKE_SOURCE_DIR}/tools/codegenerator/Generator.groovy ${CMAKE_CURRENT_BINARY_DIR}/${file}.xml ${CMAKE_CURRENT_SOURCE_DIR}/../python/PythonSwig.cpp.template ${CMAKE_CURRENT_BINARY_DIR}/${file}.cpp
+				)
+	set(SOURCES ${SOURCES} "${CMAKE_CURRENT_BINARY_DIR}/${CPP_FILE}" PARENT_SCOPE)
 endfunction()
 
 find_package(Java COMPONENTS Runtime REQUIRED)
@@ -40,7 +38,4 @@ foreach(INPUT IN LISTS INPUTS)
   list(APPEND GEN_SRCS ${CMAKE_CURRENT_BINARY_DIR}/${INPUT}.cpp)
 endforeach()
 
-add_library(python_binding STATIC ${SOURCES})
-set_target_properties(python_binding PROPERTIES POSITION_INDEPENDENT_CODE TRUE
-                                                FOLDER "Build Utilities")
-set(core_DEPENDS python_binding ${core_DEPENDS} CACHE STRING "" FORCE)
\ No newline at end of file
+core_add_library(python_binding)

From f7421125d8ae5d9136c02a429c1e8a11c9852aef Mon Sep 17 00:00:00 2001
From: Arpit Nandwani <arpit.nandwani@gmail.com>
Date: Wed, 19 Jul 2017 19:52:23 +0530
Subject: [PATCH 04/25] Charset Conversion From char To wchar_t

---
 xbmc/interfaces/python3/PythonInvoker.cpp | 45 +++++++++++++++++++++----------
 xbmc/interfaces/python3/XBPython.cpp      |  4 +--
 xbmc/interfaces/swig/CMakeLists.txt       | 19 ++++++++-----
 3 files changed, 45 insertions(+), 23 deletions(-)

diff --git a/xbmc/interfaces/python3/PythonInvoker.cpp b/xbmc/interfaces/python3/PythonInvoker.cpp
index 189846feff01..59db0052989f 100644
--- a/xbmc/interfaces/python3/PythonInvoker.cpp
+++ b/xbmc/interfaces/python3/PythonInvoker.cpp
@@ -41,9 +41,7 @@
 #include "interfaces/python/swig.h"
 #include "interfaces/python/XBPython.h"
 #include "threads/SingleLock.h"
-#if defined(TARGET_WINDOWS)
 #include "utils/CharsetConverter.h"
-#endif // defined(TARGET_WINDOWS)
 #include "utils/log.h"
 #include "utils/StringUtils.h"
 #include "utils/URIUtils.h"
@@ -97,23 +95,23 @@ static const std::string getListOfAddonClassesAsString(XBMCAddon::AddonClass::Re
   return message;
 }
 
-static std::vector<std::vector<char>> storeArgumentsCCompatible(std::vector<std::string> const & input)
+static std::vector<std::vector<wchar_t>> storeArgumentsCCompatible(std::vector<std::wstring> const & input)
 {
-  std::vector<std::vector<char>> output;
+  std::vector<std::vector<wchar_t>> output;
   std::transform(input.begin(), input.end(), std::back_inserter(output),
-                [](std::string const & i) { return std::vector<char>(i.c_str(), i.c_str() + i.length() + 1); });
+                [](std::wstring const & i) { return std::vector<wchar_t>(i.c_str(), i.c_str() + i.length() + 1); });
 
   if (output.empty())
-    output.push_back(std::vector<char>(1u, '\0'));
+    output.push_back(std::vector<wchar_t>(1u, '\0'));
 
   return output;
 }
 
-static std::vector<char *> getCPointersToArguments(std::vector<std::vector<char>> & input)
+static std::vector<wchar_t *> getCPointersToArguments(std::vector<std::vector<wchar_t>> & input)
 {
-  std::vector<char *> output;
+  std::vector<wchar_t *> output;
   std::transform(input.begin(), input.end(), std::back_inserter(output),
-                [](std::vector<char> & i) { return &i[0]; });
+                [](std::vector<wchar_t> & i) { return &i[0]; });
   return output;
 }
 
@@ -157,13 +155,25 @@ bool CPythonInvoker::Execute(const std::string &script, const std::vector<std::s
 
 bool CPythonInvoker::execute(const std::string &script, const std::vector<std::string> &arguments)
 {
+  std::vector<std::wstring> w_arguments;
+  for (auto argument : arguments)
+  {
+    std::wstring w_argument;
+    g_charsetConverter.utf8ToW(argument, w_argument);
+    w_arguments.push_back(w_argument);
+  }
+  return execute(script, w_arguments);
+}
+
+bool CPythonInvoker::execute(const std::string &script, const std::vector<std::wstring> &arguments)
+{
   // copy the code/script into a local string buffer
   m_sourceFile = script;
 
   // copy the arguments into a local buffer
   unsigned int argc = arguments.size();
-  std::vector<std::vector<char>> argvStorage = storeArgumentsCCompatible(arguments);
-  std::vector<char *> argv = getCPointersToArguments(argvStorage);
+  std::vector<std::vector<wchar_t>> argvStorage = storeArgumentsCCompatible(arguments);
+  std::vector<wchar_t *> argv = getCPointersToArguments(argvStorage);
 
   CLog::Log(LOGDEBUG, "CPythonInvoker(%d, %s): start processing", GetId(), m_sourceFile.c_str());
 
@@ -234,12 +244,16 @@ bool CPythonInvoker::execute(const std::string &script, const std::vector<std::s
     }
   }
   else
-    addNativePath((char *)Py_GetPath());
+  {
+      std::string GetPath;
+      g_charsetConverter.wToUTF8(Py_GetPath(), GetPath);
+      addNativePath(GetPath);
+  }
 
   Py_DECREF(sysMod); // release ref to sysMod
 
   // set current directory and python's path.
-  PySys_SetArgv(argc, (wchar_t **)(&argv[0]));
+  PySys_SetArgv(argc, &argv[0]);
 
 #ifdef TARGET_WINDOWS
   std::string pyPathUtf8;
@@ -248,7 +262,10 @@ bool CPythonInvoker::execute(const std::string &script, const std::vector<std::s
 #else // ! TARGET_WINDOWS
   CLog::Log(LOGDEBUG, "CPythonInvoker(%d, %s): setting the Python path to %s", GetId(), m_sourceFile.c_str(), m_pythonPath.c_str());
 #endif // ! TARGET_WINDOWS
-  PySys_SetPath((wchar_t *)m_pythonPath.c_str());
+
+  std::wstring pypath;
+  g_charsetConverter.utf8ToW(m_pythonPath, pypath);
+  PySys_SetPath(pypath.c_str());
 
   CLog::Log(LOGDEBUG, "CPythonInvoker(%d, %s): entering source directory %s", GetId(), m_sourceFile.c_str(), scriptDir.c_str());
   PyObject* module = PyImport_AddModule((char*)"__main__");
diff --git a/xbmc/interfaces/python3/XBPython.cpp b/xbmc/interfaces/python3/XBPython.cpp
index fcd73164a5c4..4cafce84cb90 100644
--- a/xbmc/interfaces/python3/XBPython.cpp
+++ b/xbmc/interfaces/python3/XBPython.cpp
@@ -597,12 +597,12 @@ bool XBPython::OnScriptInitialized(ILanguageInvoker *invoker)
     // If this is not the first time we initialize Python, the interpreter
     // lock already exists and we need to lock it as PyEval_InitThreads
     // would not do that in that case.
-    char* python_argv[1] = { (char*)"" };
-    PySys_SetArgv(1, (wchar_t **)python_argv);
     if (PyEval_ThreadsInitialized())
       PyEval_AcquireLock();
     else
       PyEval_InitThreads();
+    wchar_t* python_argv[1] = { L"" };
+    PySys_SetArgv(1, python_argv);
 
     if (!(m_mainThreadState = PyThreadState_Get()))
       CLog::Log(LOGERROR, "Python threadstate is NULL.");
diff --git a/xbmc/interfaces/swig/CMakeLists.txt b/xbmc/interfaces/swig/CMakeLists.txt
index b05c848b2281..9c7a424a15c7 100644
--- a/xbmc/interfaces/swig/CMakeLists.txt
+++ b/xbmc/interfaces/swig/CMakeLists.txt
@@ -10,12 +10,14 @@ function(generate_file file)
     set(devnull "nul")
   endif()
 
-	set(CPP_FILE ${file}.cpp)
-execute_process(
-				COMMAND ${SWIG_EXECUTABLE} -w401 -c++ -o ${CMAKE_CURRENT_BINARY_DIR}/${file}.xml -xml -I${CMAKE_SOURCE_DIR}/xbmc -xmllang python ${CMAKE_CURRENT_SOURCE_DIR}/../swig/${file}
-				COMMAND ${Java_JAVA_EXECUTABLE} -cp "${classpath}" groovy.ui.GroovyMain ${CMAKE_SOURCE_DIR}/tools/codegenerator/Generator.groovy ${CMAKE_CURRENT_BINARY_DIR}/${file}.xml ${CMAKE_CURRENT_SOURCE_DIR}/../python/PythonSwig.cpp.template ${CMAKE_CURRENT_BINARY_DIR}/${file}.cpp
-				)
-	set(SOURCES ${SOURCES} "${CMAKE_CURRENT_BINARY_DIR}/${CPP_FILE}" PARENT_SCOPE)
+  set(CPP_FILE ${file}.cpp)
+  add_custom_command(OUTPUT ${CPP_FILE}
+                     COMMAND ${SWIG_EXECUTABLE}
+                     ARGS -w401 -c++ -o ${file}.xml -xml -I${CMAKE_SOURCE_DIR}/xbmc -xmllang python ${CMAKE_CURRENT_SOURCE_DIR}/../swig/${file}
+                     COMMAND ${Java_JAVA_EXECUTABLE}
+                     ARGS -cp "${classpath}" groovy.ui.GroovyMain ${CMAKE_SOURCE_DIR}/tools/codegenerator/Generator.groovy ${file}.xml ${CMAKE_CURRENT_SOURCE_DIR}/../python/PythonSwig.cpp.template ${file}.cpp > ${devnull}
+                     DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/../swig/${file} ${CMAKE_CURRENT_SOURCE_DIR}/../python/PythonSwig.cpp.template)
+  set(SOURCES ${SOURCES} "${CPP_FILE}" PARENT_SCOPE)
 endfunction()
 
 find_package(Java COMPONENTS Runtime REQUIRED)
@@ -38,4 +40,7 @@ foreach(INPUT IN LISTS INPUTS)
   list(APPEND GEN_SRCS ${CMAKE_CURRENT_BINARY_DIR}/${INPUT}.cpp)
 endforeach()
 
-core_add_library(python_binding)
+add_library(python_binding STATIC ${SOURCES})
+set_target_properties(python_binding PROPERTIES POSITION_INDEPENDENT_CODE TRUE
+                                                FOLDER "Build Utilities")
+set(core_DEPENDS python_binding ${core_DEPENDS} CACHE STRING "" FORCE)
\ No newline at end of file

From af1427714220a8a362578200abcaac073a6e958d Mon Sep 17 00:00:00 2001
From: Arpit Nandwani <arpit.nandwani@gmail.com>
Date: Wed, 19 Jul 2017 19:57:16 +0530
Subject: [PATCH 05/25] Converted Virtual to Pure Virtual Functions

---
 xbmc/interfaces/python3/PythonInvoker.cpp | 11 -----------
 xbmc/interfaces/python3/PythonInvoker.h   |  4 ++--
 2 files changed, 2 insertions(+), 13 deletions(-)

diff --git a/xbmc/interfaces/python3/PythonInvoker.cpp b/xbmc/interfaces/python3/PythonInvoker.cpp
index 59db0052989f..7dba001efc15 100644
--- a/xbmc/interfaces/python3/PythonInvoker.cpp
+++ b/xbmc/interfaces/python3/PythonInvoker.cpp
@@ -561,12 +561,6 @@ void CPythonInvoker::onExecutionFailed()
   ILanguageInvoker::onExecutionFailed();
 }
 
-std::map<std::string, CPythonInvoker::PythonModuleInitialization> CPythonInvoker::getModules() const
-{
-  static std::map<std::string, PythonModuleInitialization> modules;
-  return modules;
-}
-
 void CPythonInvoker::onInitialization()
 {
   XBMC_TRACE;
@@ -630,11 +624,6 @@ void CPythonInvoker::onError(const std::string &exceptionType /* = "" */, const
   }
 }
 
-const char* CPythonInvoker::getInitializationScript() const
-{
-  return NULL;
-}
-
 void CPythonInvoker::initializeModules(const std::map<std::string, PythonModuleInitialization> &modules)
 {
   for (std::map<std::string, PythonModuleInitialization>::const_iterator module = modules.begin(); module != modules.end(); ++module)
diff --git a/xbmc/interfaces/python3/PythonInvoker.h b/xbmc/interfaces/python3/PythonInvoker.h
index 86142ecbe83c..fbdc4f5a1f81 100644
--- a/xbmc/interfaces/python3/PythonInvoker.h
+++ b/xbmc/interfaces/python3/PythonInvoker.h
@@ -48,8 +48,8 @@ class CPythonInvoker : public ILanguageInvoker
   void onExecutionFailed() override;
 
   // custom virtual methods
-  virtual std::map<std::string, PythonModuleInitialization> getModules() const;
-  virtual const char* getInitializationScript() const;
+  virtual std::map<std::string, PythonModuleInitialization> getModules() const = 0;
+  virtual const char* getInitializationScript() const = 0;
   virtual void onInitialization();
   // actually a PyObject* but don't wanna draw Python.h include into the header
   virtual void onPythonModuleInitialization(void* moduleDict);

From 89cfcc71e7283112022dddd8da1c4c269f76150e Mon Sep 17 00:00:00 2001
From: Arpit Nandwani <arpit.nandwani@gmail.com>
Date: Wed, 19 Jul 2017 19:59:10 +0530
Subject: [PATCH 06/25] Replaced py3c dependency with a file function

---
 xbmc/interfaces/python3/PythonInvoker.cpp | 26 +++++++++++++++++++++++++-
 xbmc/interfaces/python3/PythonInvoker.h   |  1 +
 2 files changed, 26 insertions(+), 1 deletion(-)

diff --git a/xbmc/interfaces/python3/PythonInvoker.cpp b/xbmc/interfaces/python3/PythonInvoker.cpp
index 7dba001efc15..2aaef370e000 100644
--- a/xbmc/interfaces/python3/PythonInvoker.cpp
+++ b/xbmc/interfaces/python3/PythonInvoker.cpp
@@ -307,7 +307,7 @@ bool CPythonInvoker::execute(const std::string &script, const std::vector<std::w
     ioMod = PyImport_ImportModule("io");
     openedFile = PyObject_CallMethod(ioMod, "open", "ss", (char *)nativeFilename.c_str(), "r");
     Py_DECREF(ioMod);
-    FILE *fp = py3c_PyFile_AsFileWithMode(openedFile, (char *)"r");
+    FILE *fp = PyFile_AsFileWithMode(openedFile, (char *)"r");
 
       if (fp != NULL)
       {
@@ -463,6 +463,30 @@ void CPythonInvoker::executeScript(void *fp, const std::string &script, void *mo
   PyRun_FileExFlags(static_cast<FILE*>(fp), script.c_str(), m_Py_file_input, static_cast<PyObject*>(moduleDict), static_cast<PyObject*>(moduleDict), 1, NULL);
 }
 
+FILE* CPythonInvoker::PyFile_AsFileWithMode(PyObject *py_file, const char *mode)
+{
+    FILE *f;
+    PyObject *ret;
+    int fd;
+
+    ret = PyObject_CallMethod(py_file, "flush", "");
+    if (ret == NULL)
+        return NULL;
+    Py_DECREF(ret);
+
+    fd = PyObject_AsFileDescriptor(py_file);
+    if (fd == -1)
+        return NULL;
+
+    f = fdopen(fd, mode);
+    if (f == NULL) {
+        PyErr_SetFromErrno(PyExc_OSError);
+        return NULL;
+    }
+
+    return f;
+}
+
 bool CPythonInvoker::stop(bool abort)
 {
   CSingleLock lock(m_critical);
diff --git a/xbmc/interfaces/python3/PythonInvoker.h b/xbmc/interfaces/python3/PythonInvoker.h
index fbdc4f5a1f81..b3e1110fecc9 100644
--- a/xbmc/interfaces/python3/PythonInvoker.h
+++ b/xbmc/interfaces/python3/PythonInvoker.h
@@ -69,6 +69,7 @@ class CPythonInvoker : public ILanguageInvoker
   void addNativePath(const std::string& path); // add path in system/Python encoding
   void getAddonModuleDeps(const ADDON::AddonPtr& addon, std::set<std::string>& paths);
   bool execute(const std::string &script, const std::vector<std::wstring> &arguments);
+  FILE* PyFile_AsFileWithMode(PyObject *py_file, const char *mode);
 
   std::string m_pythonPath;
   void *m_threadState;

From 29c0e33eadc0462ac9f1b62d9fc409d613e9b94c Mon Sep 17 00:00:00 2001
From: Arpit Nandwani <arpit.nandwani@gmail.com>
Date: Wed, 19 Jul 2017 20:01:24 +0530
Subject: [PATCH 07/25] Made Tab Spacing Uniform

---
 xbmc/interfaces/python3/PythonInvoker.cpp | 25 ++++++++++++-------------
 1 file changed, 12 insertions(+), 13 deletions(-)

diff --git a/xbmc/interfaces/python3/PythonInvoker.cpp b/xbmc/interfaces/python3/PythonInvoker.cpp
index 2aaef370e000..2d6ffd7ebcb7 100644
--- a/xbmc/interfaces/python3/PythonInvoker.cpp
+++ b/xbmc/interfaces/python3/PythonInvoker.cpp
@@ -255,13 +255,13 @@ bool CPythonInvoker::execute(const std::string &script, const std::vector<std::w
   // set current directory and python's path.
   PySys_SetArgv(argc, &argv[0]);
 
-#ifdef TARGET_WINDOWS
+  #ifdef TARGET_WINDOWS
   std::string pyPathUtf8;
   g_charsetConverter.systemToUtf8(m_pythonPath, pyPathUtf8, false);
   CLog::Log(LOGDEBUG, "CPythonInvoker(%d, %s): setting the Python path to %s", GetId(), m_sourceFile.c_str(), pyPathUtf8.c_str());
-#else // ! TARGET_WINDOWS
+  #else // ! TARGET_WINDOWS
   CLog::Log(LOGDEBUG, "CPythonInvoker(%d, %s): setting the Python path to %s", GetId(), m_sourceFile.c_str(), m_pythonPath.c_str());
-#endif // ! TARGET_WINDOWS
+  #endif // ! TARGET_WINDOWS
 
   std::wstring pypath;
   g_charsetConverter.utf8ToW(m_pythonPath, pypath);
@@ -295,14 +295,13 @@ bool CPythonInvoker::execute(const std::string &script, const std::vector<std::w
       //  is linked against may not be the DLL that xbmc is linked against so
       //  passing a FILE* to python from an fopen has the potential to crash.
       std::string nativeFilename(realFilename); // filename in system encoding
-#ifdef TARGET_WINDOWS
-      if (!g_charsetConverter.utf8ToSystem(nativeFilename, true))
-      {
-        CLog::Log(LOGERROR, "CPythonInvoker(%d, %s): can't convert filename \"%s\" to system encoding", GetId(), m_sourceFile.c_str(), realFilename.c_str());
-        return false;
-      }
-#endif
-
+      #ifdef TARGET_WINDOWS
+        if (!g_charsetConverter.utf8ToSystem(nativeFilename, true))
+        {
+          CLog::Log(LOGERROR, "CPythonInvoker(%d, %s): can't convert filename \"%s\" to system encoding", GetId(), m_sourceFile.c_str(), realFilename.c_str());
+          return false;
+        }
+      #endif
     PyObject *ioMod, *openedFile;
     ioMod = PyImport_ImportModule("io");
     openedFile = PyObject_CallMethod(ioMod, "open", "ss", (char *)nativeFilename.c_str(), "r");
@@ -434,7 +433,7 @@ bool CPythonInvoker::execute(const std::string &script, const std::vector<std::w
   // to run the GC if that's the case.
   if (!m_stop && languageHook->HasRegisteredAddonClasses() && !systemExitThrown &&
       PyRun_SimpleString(GC_SCRIPT) == -1)
-    CLog::Log(LOGERROR, "CPythonInvoker(%d, %s): failed to run the gc to clean up after running prior to shutting down the Interpreter", GetId(), m_sourceFile.c_str());
+  CLog::Log(LOGERROR, "CPythonInvoker(%d, %s): failed to run the gc to clean up after running prior to shutting down the Interpreter", GetId(), m_sourceFile.c_str());
 
   Py_EndInterpreter(state);
 
@@ -442,7 +441,7 @@ bool CPythonInvoker::execute(const std::string &script, const std::vector<std::w
   if (languageHook->HasRegisteredAddonClasses())
     CLog::Log(LOGWARNING, "CPythonInvoker(%d, %s): the python script \"%s\" has left several "
       "classes in memory that we couldn't clean up. The classes include: %s",
-      GetId(), m_sourceFile.c_str(), m_sourceFile.c_str(), getListOfAddonClassesAsString(languageHook).c_str());
+    GetId(), m_sourceFile.c_str(), m_sourceFile.c_str(), getListOfAddonClassesAsString(languageHook).c_str());
 
   // unregister the language hook
   languageHook->UnregisterMe();

From 50378e4ca89e0bd74e1d18d85c37d6fe35b608f6 Mon Sep 17 00:00:00 2001
From: Arpit Nandwani <arpit.nandwani@gmail.com>
Date: Wed, 19 Jul 2017 21:42:08 +0530
Subject: [PATCH 08/25] Updated Python WSGI Invoker

---
 .../python3/HTTPPythonWsgiInvoker.cpp              | 23 +++++++++++++---------
 1 file changed, 14 insertions(+), 9 deletions(-)

diff --git a/xbmc/network/httprequesthandler/python3/HTTPPythonWsgiInvoker.cpp b/xbmc/network/httprequesthandler/python3/HTTPPythonWsgiInvoker.cpp
index ce8e5ecb8b69..f69a9ba876a0 100644
--- a/xbmc/network/httprequesthandler/python3/HTTPPythonWsgiInvoker.cpp
+++ b/xbmc/network/httprequesthandler/python3/HTTPPythonWsgiInvoker.cpp
@@ -18,6 +18,8 @@
  *
  */
 
+#include <Python.h>
+
 #include "HTTPPythonWsgiInvoker.h"
 
 #include <utility>
@@ -30,7 +32,7 @@
 #include "URL.h"
 #include "utils/URIUtils.h"
 
-#define MODULE      "xbmc"
+#define MODULE "xbmc"
 
 #define RUNSCRIPT_PREAMBLE \
   "" \
@@ -52,14 +54,14 @@
 
 #define RUNSCRIPT_SETUPTOOLS_HACK \
   "" \
-  "import imp,sys\n" \
+  "import types,sys\n" \
   "pkg_resources_code = \\\n" \
   "\"\"\"\n" \
   "def resource_filename(__name__,__path__):\n" \
   "  return __path__\n" \
   "\"\"\"\n" \
-  "pkg_resources = imp.new_module('pkg_resources')\n" \
-  "exec pkg_resources_code in pkg_resources.__dict__\n" \
+  "pkg_resources = types.ModuleType('pkg_resources')\n" \
+  "exec(pkg_resources_code, pkg_resources.__dict__)\n" \
   "sys.modules['pkg_resources'] = pkg_resources\n" \
   ""
 
@@ -76,8 +78,8 @@
 #endif
 
 namespace PythonBindings {
-  void initModule_xbmc(void);
-  void initModule_xbmcwsgi(void);
+  PyObject* PyInit_Module_xbmc(void);
+  PyObject* PyInit_Module_xbmcwsgi(void);
 }
 
 using namespace PythonBindings;
@@ -90,8 +92,8 @@ typedef struct
 
 static PythonModule PythonModules[] =
 {
-  { "xbmc",           initModule_xbmc },
-  { "xbmcwsgi",       initModule_xbmcwsgi }
+  { "xbmc",           PyInit_Module_xbmc },
+  { "xbmcwsgi",       PyInit_Module_xbmcwsgi }
 };
 
 #define PythonModulesSize sizeof(PythonModules) / sizeof(PythonModule)
@@ -99,7 +101,10 @@ static PythonModule PythonModules[] =
 CHTTPPythonWsgiInvoker::CHTTPPythonWsgiInvoker(ILanguageInvocationHandler* invocationHandler, HTTPPythonRequest* request)
   : CHTTPPythonInvoker(invocationHandler, request),
     m_wsgiResponse(NULL)
-{ }
+{
+    PyImport_AppendInittab("xbmc",     PyInit_Module_xbmc);
+    PyImport_AppendInittab("xbmcwsgi", PyInit_Module_xbmcwsgi);
+}
 
 CHTTPPythonWsgiInvoker::~CHTTPPythonWsgiInvoker()
 {

From 0a555495ee1fafd7045a1e65104bee143f39e485 Mon Sep 17 00:00:00 2001
From: Arpit Nandwani <arpit.nandwani@gmail.com>
Date: Sun, 20 Aug 2017 15:40:22 +0530
Subject: [PATCH 09/25] Replaced Python dir with Python3 dir

---
 cmake/treedata/optional/common/python.txt          |   1 -
 xbmc/interfaces/python/AddonPythonInvoker.cpp      |  36 +-
 xbmc/interfaces/python/LanguageHook.cpp            |   4 +-
 xbmc/interfaces/python/PythonInvoker.cpp           | 134 +--
 xbmc/interfaces/python/PythonInvoker.h             |  13 +-
 xbmc/interfaces/python/PythonSwig.cpp.template     |  55 +-
 xbmc/interfaces/python/XBPython.cpp                |  28 +-
 xbmc/interfaces/python/swig.cpp                    |  26 +-
 xbmc/interfaces/python/typemaps/python.buffer.intm |   8 +-
 .../interfaces/python/typemaps/python.string.outtm |   4 +-
 xbmc/interfaces/python3/AddonPythonInvoker.cpp     | 133 ---
 xbmc/interfaces/python3/AddonPythonInvoker.h       |  34 -
 xbmc/interfaces/python3/CMakeLists.txt             |  21 -
 xbmc/interfaces/python3/CallbackHandler.cpp        |  76 --
 xbmc/interfaces/python3/CallbackHandler.h          |  50 --
 .../interfaces/python3/ContextItemAddonInvoker.cpp |  53 --
 xbmc/interfaces/python3/ContextItemAddonInvoker.h  |  40 -
 xbmc/interfaces/python3/LanguageHook.cpp           | 210 -----
 xbmc/interfaces/python3/LanguageHook.h             | 101 ---
 xbmc/interfaces/python3/MethodType.groovy          |  26 -
 xbmc/interfaces/python3/PyContext.cpp              | 129 ---
 xbmc/interfaces/python3/PyContext.h                |  58 --
 xbmc/interfaces/python3/PythonInvoker.cpp          | 715 ---------------
 xbmc/interfaces/python3/PythonInvoker.h            |  80 --
 xbmc/interfaces/python3/PythonSwig.cpp.template    | 961 ---------------------
 xbmc/interfaces/python3/PythonTools.groovy         | 152 ----
 xbmc/interfaces/python3/XBPython.cpp               | 700 ---------------
 xbmc/interfaces/python3/XBPython.h                 | 137 ---
 xbmc/interfaces/python3/preamble.h                 |  27 -
 xbmc/interfaces/python3/pythreadstate.h            |  73 --
 xbmc/interfaces/python3/swig.cpp                   | 385 ---------
 xbmc/interfaces/python3/swig.h                     | 211 -----
 xbmc/interfaces/python3/test/CMakeLists.txt        |   5 -
 xbmc/interfaces/python3/test/TestSwig.cpp          |  33 -
 .../python3/typemaps/python.Alternative.intm       |  55 --
 .../python3/typemaps/python.Alternative.outtm      |  46 -
 xbmc/interfaces/python3/typemaps/python.Tuple.intm |  47 -
 .../interfaces/python3/typemaps/python.Tuple.outtm |  51 --
 .../interfaces/python3/typemaps/python.buffer.intm |  38 -
 .../python3/typemaps/python.buffer.outtm           |  23 -
 xbmc/interfaces/python3/typemaps/python.dict.intm  |  35 -
 xbmc/interfaces/python3/typemaps/python.map.intm   |  36 -
 .../python3/typemaps/python.smart_ptr.outtm        |  26 -
 .../python3/typemaps/python.string.outtm           |  23 -
 .../interfaces/python3/typemaps/python.vector.intm |  47 -
 .../python3/typemaps/python.vector.outtm           |  48 -
 .../python/HTTPPythonWsgiInvoker.cpp               |  29 +-
 .../httprequesthandler/python3/CMakeLists.txt      |  10 -
 .../python3/HTTPPythonInvoker.cpp                  |  84 --
 .../httprequesthandler/python3/HTTPPythonInvoker.h |  44 -
 .../httprequesthandler/python3/HTTPPythonRequest.h |  54 --
 .../python3/HTTPPythonWsgiInvoker.cpp              | 458 ----------
 .../python3/HTTPPythonWsgiInvoker.h                |  58 --
 53 files changed, 188 insertions(+), 5743 deletions(-)
 delete mode 100644 xbmc/interfaces/python3/AddonPythonInvoker.cpp
 delete mode 100644 xbmc/interfaces/python3/AddonPythonInvoker.h
 delete mode 100644 xbmc/interfaces/python3/CMakeLists.txt
 delete mode 100644 xbmc/interfaces/python3/CallbackHandler.cpp
 delete mode 100644 xbmc/interfaces/python3/CallbackHandler.h
 delete mode 100644 xbmc/interfaces/python3/ContextItemAddonInvoker.cpp
 delete mode 100644 xbmc/interfaces/python3/ContextItemAddonInvoker.h
 delete mode 100644 xbmc/interfaces/python3/LanguageHook.cpp
 delete mode 100644 xbmc/interfaces/python3/LanguageHook.h
 delete mode 100644 xbmc/interfaces/python3/MethodType.groovy
 delete mode 100644 xbmc/interfaces/python3/PyContext.cpp
 delete mode 100644 xbmc/interfaces/python3/PyContext.h
 delete mode 100644 xbmc/interfaces/python3/PythonInvoker.cpp
 delete mode 100644 xbmc/interfaces/python3/PythonInvoker.h
 delete mode 100644 xbmc/interfaces/python3/PythonSwig.cpp.template
 delete mode 100644 xbmc/interfaces/python3/PythonTools.groovy
 delete mode 100644 xbmc/interfaces/python3/XBPython.cpp
 delete mode 100644 xbmc/interfaces/python3/XBPython.h
 delete mode 100644 xbmc/interfaces/python3/preamble.h
 delete mode 100644 xbmc/interfaces/python3/pythreadstate.h
 delete mode 100644 xbmc/interfaces/python3/swig.cpp
 delete mode 100644 xbmc/interfaces/python3/swig.h
 delete mode 100644 xbmc/interfaces/python3/test/CMakeLists.txt
 delete mode 100644 xbmc/interfaces/python3/test/TestSwig.cpp
 delete mode 100644 xbmc/interfaces/python3/typemaps/python.Alternative.intm
 delete mode 100644 xbmc/interfaces/python3/typemaps/python.Alternative.outtm
 delete mode 100644 xbmc/interfaces/python3/typemaps/python.Tuple.intm
 delete mode 100644 xbmc/interfaces/python3/typemaps/python.Tuple.outtm
 delete mode 100644 xbmc/interfaces/python3/typemaps/python.buffer.intm
 delete mode 100644 xbmc/interfaces/python3/typemaps/python.buffer.outtm
 delete mode 100644 xbmc/interfaces/python3/typemaps/python.dict.intm
 delete mode 100644 xbmc/interfaces/python3/typemaps/python.map.intm
 delete mode 100644 xbmc/interfaces/python3/typemaps/python.smart_ptr.outtm
 delete mode 100644 xbmc/interfaces/python3/typemaps/python.string.outtm
 delete mode 100644 xbmc/interfaces/python3/typemaps/python.vector.intm
 delete mode 100644 xbmc/interfaces/python3/typemaps/python.vector.outtm
 delete mode 100644 xbmc/network/httprequesthandler/python3/CMakeLists.txt
 delete mode 100644 xbmc/network/httprequesthandler/python3/HTTPPythonInvoker.cpp
 delete mode 100644 xbmc/network/httprequesthandler/python3/HTTPPythonInvoker.h
 delete mode 100644 xbmc/network/httprequesthandler/python3/HTTPPythonRequest.h
 delete mode 100644 xbmc/network/httprequesthandler/python3/HTTPPythonWsgiInvoker.cpp
 delete mode 100644 xbmc/network/httprequesthandler/python3/HTTPPythonWsgiInvoker.h

diff --git a/cmake/treedata/optional/common/python.txt b/cmake/treedata/optional/common/python.txt
index 554c994719da..49604855c82c 100644
--- a/cmake/treedata/optional/common/python.txt
+++ b/cmake/treedata/optional/common/python.txt
@@ -1,5 +1,4 @@
 xbmc/interfaces/legacy interfaces/legacy # PYTHON
 xbmc/interfaces/legacy/wsgi interfaces/legacy/wsgi # PYTHON
 xbmc/interfaces/python interfaces/python # PYTHON
-xbmc/interfaces/python3 interfaces/python3 # PYTHON
 xbmc/interfaces/swig build/swig # PYTHON
diff --git a/xbmc/interfaces/python/AddonPythonInvoker.cpp b/xbmc/interfaces/python/AddonPythonInvoker.cpp
index a426fe3bc0b0..37ba6c0b202b 100644
--- a/xbmc/interfaces/python/AddonPythonInvoker.cpp
+++ b/xbmc/interfaces/python/AddonPythonInvoker.cpp
@@ -49,19 +49,19 @@
 
 #define RUNSCRIPT_SETUPTOOLS_HACK \
   "" \
-  "import imp,sys\n" \
+  "import types,sys\n" \
   "pkg_resources_code = \\\n" \
   "\"\"\"\n" \
   "def resource_filename(__name__,__path__):\n" \
   "  return __path__\n" \
   "\"\"\"\n" \
-  "pkg_resources = imp.new_module('pkg_resources')\n" \
-  "exec pkg_resources_code in pkg_resources.__dict__\n" \
+  "pkg_resources = types.ModuleType('pkg_resources')\n" \
+  "exec(pkg_resources_code, pkg_resources.__dict__)\n" \
   "sys.modules['pkg_resources'] = pkg_resources\n" \
   ""
 
 #define RUNSCRIPT_POSTSCRIPT \
-        "print '-->Python Interpreter Initialized<--'\n" \
+        "print ('-->Python Interpreter Initialized<--')\n" \
         ""
 
 #if defined(TARGET_ANDROID)
@@ -77,11 +77,11 @@
 #endif
 
 namespace PythonBindings {
-  void initModule_xbmcgui(void);
-  void initModule_xbmc(void);
-  void initModule_xbmcplugin(void);
-  void initModule_xbmcaddon(void);
-  void initModule_xbmcvfs(void);
+  PyObject *PyInit_Module_xbmcgui(void);
+  PyObject *PyInit_Module_xbmc(void);
+  PyObject *PyInit_Module_xbmcplugin(void);
+  PyObject *PyInit_Module_xbmcaddon(void);
+  PyObject *PyInit_Module_xbmcvfs(void);
 }
 
 using namespace PythonBindings;
@@ -94,18 +94,24 @@ typedef struct
 
 static PythonModule PythonModules[] =
   {
-    { "xbmcgui",    initModule_xbmcgui    },
-    { "xbmc",       initModule_xbmc       },
-    { "xbmcplugin", initModule_xbmcplugin },
-    { "xbmcaddon",  initModule_xbmcaddon  },
-    { "xbmcvfs",    initModule_xbmcvfs    }
+    { "xbmcgui",    PyInit_Module_xbmcgui    },
+    { "xbmc",       PyInit_Module_xbmc       },
+    { "xbmcplugin", PyInit_Module_xbmcplugin },
+    { "xbmcaddon",  PyInit_Module_xbmcaddon  },
+    { "xbmcvfs",    PyInit_Module_xbmcvfs    }
   };
 
 #define PythonModulesSize sizeof(PythonModules) / sizeof(PythonModule)
 
 CAddonPythonInvoker::CAddonPythonInvoker(ILanguageInvocationHandler *invocationHandler)
   : CPythonInvoker(invocationHandler)
-{ }
+{
+    PyImport_AppendInittab("xbmcgui",    PyInit_Module_xbmcgui);
+    PyImport_AppendInittab("xbmc",       PyInit_Module_xbmc);
+    PyImport_AppendInittab("xbmcplugin", PyInit_Module_xbmcplugin);
+    PyImport_AppendInittab("xbmcaddon",  PyInit_Module_xbmcaddon);
+    PyImport_AppendInittab("xbmcvfs",    PyInit_Module_xbmcvfs);
+}
 
 CAddonPythonInvoker::~CAddonPythonInvoker() = default;
 
diff --git a/xbmc/interfaces/python/LanguageHook.cpp b/xbmc/interfaces/python/LanguageHook.cpp
index d93e62fc3524..7e18e363be7c 100644
--- a/xbmc/interfaces/python/LanguageHook.cpp
+++ b/xbmc/interfaces/python/LanguageHook.cpp
@@ -137,7 +137,7 @@ namespace XBMCAddon
       // from the global dictionary
       PyObject* pyid = PyDict_GetItemString(global_dict, "__xbmcaddonid__");
       if (pyid)
-        return PyString_AsString(pyid);
+        return PyUnicode_AsUTF8(pyid);
       return "";
     }
 
@@ -152,7 +152,7 @@ namespace XBMCAddon
       // from the global dictionary
       PyObject* pyversion = PyDict_GetItemString(global_dict, "__xbmcapiversion__");
       if (pyversion)
-        return PyString_AsString(pyversion);
+        return PyUnicode_AsUTF8(pyversion);
       return "";
     }
 
diff --git a/xbmc/interfaces/python/PythonInvoker.cpp b/xbmc/interfaces/python/PythonInvoker.cpp
index 758dbac9a3e7..2d6ffd7ebcb7 100644
--- a/xbmc/interfaces/python/PythonInvoker.cpp
+++ b/xbmc/interfaces/python/PythonInvoker.cpp
@@ -41,9 +41,7 @@
 #include "interfaces/python/swig.h"
 #include "interfaces/python/XBPython.h"
 #include "threads/SingleLock.h"
-#if defined(TARGET_WINDOWS)
 #include "utils/CharsetConverter.h"
-#endif // defined(TARGET_WINDOWS)
 #include "utils/log.h"
 #include "utils/StringUtils.h"
 #include "utils/URIUtils.h"
@@ -97,23 +95,23 @@ static const std::string getListOfAddonClassesAsString(XBMCAddon::AddonClass::Re
   return message;
 }
 
-static std::vector<std::vector<char>> storeArgumentsCCompatible(std::vector<std::string> const & input)
+static std::vector<std::vector<wchar_t>> storeArgumentsCCompatible(std::vector<std::wstring> const & input)
 {
-  std::vector<std::vector<char>> output;
+  std::vector<std::vector<wchar_t>> output;
   std::transform(input.begin(), input.end(), std::back_inserter(output),
-                [](std::string const & i) { return std::vector<char>(i.c_str(), i.c_str() + i.length() + 1); });
+                [](std::wstring const & i) { return std::vector<wchar_t>(i.c_str(), i.c_str() + i.length() + 1); });
 
   if (output.empty())
-    output.push_back(std::vector<char>(1u, '\0'));
+    output.push_back(std::vector<wchar_t>(1u, '\0'));
 
   return output;
 }
 
-static std::vector<char *> getCPointersToArguments(std::vector<std::vector<char>> & input)
+static std::vector<wchar_t *> getCPointersToArguments(std::vector<std::vector<wchar_t>> & input)
 {
-  std::vector<char *> output;
-  std::transform(input.begin(), input.end(), std::back_inserter(output), 
-                [](std::vector<char> & i) { return &i[0]; });
+  std::vector<wchar_t *> output;
+  std::transform(input.begin(), input.end(), std::back_inserter(output),
+                [](std::vector<wchar_t> & i) { return &i[0]; });
   return output;
 }
 
@@ -157,18 +155,31 @@ bool CPythonInvoker::Execute(const std::string &script, const std::vector<std::s
 
 bool CPythonInvoker::execute(const std::string &script, const std::vector<std::string> &arguments)
 {
+  std::vector<std::wstring> w_arguments;
+  for (auto argument : arguments)
+  {
+    std::wstring w_argument;
+    g_charsetConverter.utf8ToW(argument, w_argument);
+    w_arguments.push_back(w_argument);
+  }
+  return execute(script, w_arguments);
+}
+
+bool CPythonInvoker::execute(const std::string &script, const std::vector<std::wstring> &arguments)
+{
   // copy the code/script into a local string buffer
   m_sourceFile = script;
 
   // copy the arguments into a local buffer
   unsigned int argc = arguments.size();
-  std::vector<std::vector<char>> argvStorage = storeArgumentsCCompatible(arguments);
-  std::vector<char *> argv = getCPointersToArguments(argvStorage);
+  std::vector<std::vector<wchar_t>> argvStorage = storeArgumentsCCompatible(arguments);
+  std::vector<wchar_t *> argv = getCPointersToArguments(argvStorage);
 
   CLog::Log(LOGDEBUG, "CPythonInvoker(%d, %s): start processing", GetId(), m_sourceFile.c_str());
 
   // get the global lock
-  PyEval_AcquireLock();
+  extern PyThreadState* savestate;
+  PyEval_RestoreThread(savestate);
   PyThreadState* state = Py_NewInterpreter();
   if (state == NULL)
   {
@@ -228,26 +239,33 @@ bool CPythonInvoker::execute(const std::string &script, const std::vector<std::s
     for (int i = 0; i < PyList_Size(pathObj); i++)
     {
       PyObject *e = PyList_GetItem(pathObj, i); // borrowed ref, no need to delete
-      if (e != NULL && PyString_Check(e))
-        addNativePath(PyString_AsString(e)); // returns internal data, don't delete or modify
+      if (e != NULL && PyUnicode_Check(e))
+        addNativePath(PyUnicode_AsUTF8(e)); // returns internal data, don't delete or modify
     }
   }
   else
-    addNativePath(Py_GetPath());
+  {
+      std::string GetPath;
+      g_charsetConverter.wToUTF8(Py_GetPath(), GetPath);
+      addNativePath(GetPath);
+  }
 
   Py_DECREF(sysMod); // release ref to sysMod
 
   // set current directory and python's path.
   PySys_SetArgv(argc, &argv[0]);
 
-#ifdef TARGET_WINDOWS
+  #ifdef TARGET_WINDOWS
   std::string pyPathUtf8;
   g_charsetConverter.systemToUtf8(m_pythonPath, pyPathUtf8, false);
   CLog::Log(LOGDEBUG, "CPythonInvoker(%d, %s): setting the Python path to %s", GetId(), m_sourceFile.c_str(), pyPathUtf8.c_str());
-#else // ! TARGET_WINDOWS
+  #else // ! TARGET_WINDOWS
   CLog::Log(LOGDEBUG, "CPythonInvoker(%d, %s): setting the Python path to %s", GetId(), m_sourceFile.c_str(), m_pythonPath.c_str());
-#endif // ! TARGET_WINDOWS
-  PySys_SetPath((char *)m_pythonPath.c_str());
+  #endif // ! TARGET_WINDOWS
+
+  std::wstring pypath;
+  g_charsetConverter.utf8ToW(m_pythonPath, pypath);
+  PySys_SetPath(pypath.c_str());
 
   CLog::Log(LOGDEBUG, "CPythonInvoker(%d, %s): entering source directory %s", GetId(), m_sourceFile.c_str(), scriptDir.c_str());
   PyObject* module = PyImport_AddModule((char*)"__main__");
@@ -264,8 +282,7 @@ bool CPythonInvoker::execute(const std::string &script, const std::vector<std::s
     stopping = m_stop;
   }
 
-  PyEval_AcquireLock();
-  PyThreadState_Swap(state);
+  PyEval_AcquireThread(state);
 
   bool failed = false;
   std::string exceptionType, exceptionValue, exceptionTraceback;
@@ -278,19 +295,22 @@ bool CPythonInvoker::execute(const std::string &script, const std::vector<std::s
       //  is linked against may not be the DLL that xbmc is linked against so
       //  passing a FILE* to python from an fopen has the potential to crash.
       std::string nativeFilename(realFilename); // filename in system encoding
-#ifdef TARGET_WINDOWS
-      if (!g_charsetConverter.utf8ToSystem(nativeFilename, true))
-      {
-        CLog::Log(LOGERROR, "CPythonInvoker(%d, %s): can't convert filename \"%s\" to system encoding", GetId(), m_sourceFile.c_str(), realFilename.c_str());
-        return false;
-      }
-#endif
-      PyObject* file = PyFile_FromString((char *)nativeFilename.c_str(), (char*)"r");
-      FILE *fp = PyFile_AsFile(file);
+      #ifdef TARGET_WINDOWS
+        if (!g_charsetConverter.utf8ToSystem(nativeFilename, true))
+        {
+          CLog::Log(LOGERROR, "CPythonInvoker(%d, %s): can't convert filename \"%s\" to system encoding", GetId(), m_sourceFile.c_str(), realFilename.c_str());
+          return false;
+        }
+      #endif
+    PyObject *ioMod, *openedFile;
+    ioMod = PyImport_ImportModule("io");
+    openedFile = PyObject_CallMethod(ioMod, "open", "ss", (char *)nativeFilename.c_str(), "r");
+    Py_DECREF(ioMod);
+    FILE *fp = PyFile_AsFileWithMode(openedFile, (char *)"r");
 
       if (fp != NULL)
       {
-        PyObject *f = PyString_FromString(nativeFilename.c_str());
+        PyObject *f = PyUnicode_FromString(nativeFilename.c_str());
         PyDict_SetItemString(moduleDict, "__file__", f);
 
         onPythonModuleInitialization(moduleDict);
@@ -400,8 +420,7 @@ bool CPythonInvoker::execute(const std::string &script, const std::vector<std::s
     m_threadState = NULL;
   }
 
-  PyEval_AcquireLock();
-  PyThreadState_Swap(state);
+  PyEval_AcquireThread(state);
 
   onDeinitialization();
 
@@ -414,7 +433,7 @@ bool CPythonInvoker::execute(const std::string &script, const std::vector<std::s
   // to run the GC if that's the case.
   if (!m_stop && languageHook->HasRegisteredAddonClasses() && !systemExitThrown &&
       PyRun_SimpleString(GC_SCRIPT) == -1)
-    CLog::Log(LOGERROR, "CPythonInvoker(%d, %s): failed to run the gc to clean up after running prior to shutting down the Interpreter", GetId(), m_sourceFile.c_str());
+  CLog::Log(LOGERROR, "CPythonInvoker(%d, %s): failed to run the gc to clean up after running prior to shutting down the Interpreter", GetId(), m_sourceFile.c_str());
 
   Py_EndInterpreter(state);
 
@@ -422,7 +441,7 @@ bool CPythonInvoker::execute(const std::string &script, const std::vector<std::s
   if (languageHook->HasRegisteredAddonClasses())
     CLog::Log(LOGWARNING, "CPythonInvoker(%d, %s): the python script \"%s\" has left several "
       "classes in memory that we couldn't clean up. The classes include: %s",
-      GetId(), m_sourceFile.c_str(), m_sourceFile.c_str(), getListOfAddonClassesAsString(languageHook).c_str());
+    GetId(), m_sourceFile.c_str(), m_sourceFile.c_str(), getListOfAddonClassesAsString(languageHook).c_str());
 
   // unregister the language hook
   languageHook->UnregisterMe();
@@ -443,6 +462,30 @@ void CPythonInvoker::executeScript(void *fp, const std::string &script, void *mo
   PyRun_FileExFlags(static_cast<FILE*>(fp), script.c_str(), m_Py_file_input, static_cast<PyObject*>(moduleDict), static_cast<PyObject*>(moduleDict), 1, NULL);
 }
 
+FILE* CPythonInvoker::PyFile_AsFileWithMode(PyObject *py_file, const char *mode)
+{
+    FILE *f;
+    PyObject *ret;
+    int fd;
+
+    ret = PyObject_CallMethod(py_file, "flush", "");
+    if (ret == NULL)
+        return NULL;
+    Py_DECREF(ret);
+
+    fd = PyObject_AsFileDescriptor(py_file);
+    if (fd == -1)
+        return NULL;
+
+    f = fdopen(fd, mode);
+    if (f == NULL) {
+        PyErr_SetFromErrno(PyExc_OSError);
+        return NULL;
+    }
+
+    return f;
+}
+
 bool CPythonInvoker::stop(bool abort)
 {
   CSingleLock lock(m_critical);
@@ -541,12 +584,6 @@ void CPythonInvoker::onExecutionFailed()
   ILanguageInvoker::onExecutionFailed();
 }
 
-std::map<std::string, CPythonInvoker::PythonModuleInitialization> CPythonInvoker::getModules() const
-{
-  static std::map<std::string, PythonModuleInitialization> modules;
-  return modules;
-}
-
 void CPythonInvoker::onInitialization()
 {
   XBMC_TRACE;
@@ -572,11 +609,11 @@ void CPythonInvoker::onPythonModuleInitialization(void* moduleDict)
 
   PyObject *moduleDictionary = (PyObject *)moduleDict;
 
-  PyObject *pyaddonid = PyString_FromString(m_addon->ID().c_str());
+  PyObject *pyaddonid = PyUnicode_FromString(m_addon->ID().c_str());
   PyDict_SetItemString(moduleDictionary, "__xbmcaddonid__", pyaddonid);
 
   ADDON::AddonVersion version = m_addon->GetDependencyVersion("xbmc.python");
-  PyObject *pyxbmcapiversion = PyString_FromString(version.asString().c_str());
+  PyObject *pyxbmcapiversion = PyUnicode_FromString(version.asString().c_str());
   PyDict_SetItemString(moduleDictionary, "__xbmcapiversion__", pyxbmcapiversion);
 
   PyObject *pyinvokerid = PyLong_FromLong(GetId());
@@ -610,11 +647,6 @@ void CPythonInvoker::onError(const std::string &exceptionType /* = "" */, const
   }
 }
 
-const char* CPythonInvoker::getInitializationScript() const
-{
-  return NULL;
-}
-
 void CPythonInvoker::initializeModules(const std::map<std::string, PythonModuleInitialization> &modules)
 {
   for (std::map<std::string, PythonModuleInitialization>::const_iterator module = modules.begin(); module != modules.end(); ++module)
@@ -629,8 +661,8 @@ bool CPythonInvoker::initializeModule(PythonModuleInitialization module)
   if (module == NULL)
     return false;
 
-  module();
-  return true;
+  return module() != nullptr;
+
 }
 
 void CPythonInvoker::getAddonModuleDeps(const ADDON::AddonPtr& addon, std::set<std::string>& paths)
diff --git a/xbmc/interfaces/python/PythonInvoker.h b/xbmc/interfaces/python/PythonInvoker.h
index e8ad2565c2d3..b3e1110fecc9 100644
--- a/xbmc/interfaces/python/PythonInvoker.h
+++ b/xbmc/interfaces/python/PythonInvoker.h
@@ -27,6 +27,8 @@
 #include "threads/CriticalSection.h"
 #include "threads/Event.h"
 
+typedef struct _object PyObject;
+
 class CPythonInvoker : public ILanguageInvoker
 {
 public:
@@ -34,11 +36,10 @@ class CPythonInvoker : public ILanguageInvoker
   ~CPythonInvoker() override;
 
   bool Execute(const std::string &script, const std::vector<std::string> &arguments = std::vector<std::string>()) override;
-
   bool IsStopping() const override { return m_stop || ILanguageInvoker::IsStopping(); }
 
-  typedef void (*PythonModuleInitialization)();
-  
+  typedef PyObject* (*PythonModuleInitialization)();
+
 protected:
   // implementation of ILanguageInvoker
   bool execute(const std::string &script, const std::vector<std::string> &arguments) override;
@@ -47,8 +48,8 @@ class CPythonInvoker : public ILanguageInvoker
   void onExecutionFailed() override;
 
   // custom virtual methods
-  virtual std::map<std::string, PythonModuleInitialization> getModules() const;
-  virtual const char* getInitializationScript() const;
+  virtual std::map<std::string, PythonModuleInitialization> getModules() const = 0;
+  virtual const char* getInitializationScript() const = 0;
   virtual void onInitialization();
   // actually a PyObject* but don't wanna draw Python.h include into the header
   virtual void onPythonModuleInitialization(void* moduleDict);
@@ -67,6 +68,8 @@ class CPythonInvoker : public ILanguageInvoker
   void addPath(const std::string& path); // add path in UTF-8 encoding
   void addNativePath(const std::string& path); // add path in system/Python encoding
   void getAddonModuleDeps(const ADDON::AddonPtr& addon, std::set<std::string>& paths);
+  bool execute(const std::string &script, const std::vector<std::wstring> &arguments);
+  FILE* PyFile_AsFileWithMode(PyObject *py_file, const char *mode);
 
   std::string m_pythonPath;
   void *m_threadState;
diff --git a/xbmc/interfaces/python/PythonSwig.cpp.template b/xbmc/interfaces/python/PythonSwig.cpp.template
index f473eb55aa37..ea44bf0bfb96 100644
--- a/xbmc/interfaces/python/PythonSwig.cpp.template
+++ b/xbmc/interfaces/python/PythonSwig.cpp.template
@@ -57,15 +57,15 @@ Helper.setup(this,classes,
      * of the native call to be returned to the python caller.
      */
     [ 'void' : 'Py_INCREF(Py_None);\n    ${result} = Py_None;',
-      'long': '${result} = PyInt_FromLong(${api});',
-      'unsigned long': '${result} = PyInt_FromLong(${api});',
+      'long': '${result} = PyLong_FromLong(${api});',
+      'unsigned long': '${result} = PyLong_FromLong(${api});',
       'bool': '${result} = Py_BuildValue((char*)"b", ${api});',
       'long long': '${result} = Py_BuildValue((char*)"L", ${api});',
       'int': '${result} = Py_BuildValue((char*)"i", ${api});',
       'double': '${result} = PyFloat_FromDouble(${api});',
       'float': '${result} = Py_BuildValue((char*)"f", ${api});',
       'std::string' : new File('typemaps/python.string.outtm'),
-      'p.q(const).char' : '${result} = PyString_FromString(${api});',
+      'p.q(const).char' : '${result} = PyUnicode_FromString(${api});',
       (Pattern.compile('''(p.){0,1}XbmcCommons::Buffer''')) : new File('typemaps/python.buffer.outtm'),
       (Pattern.compile('''std::shared_ptr<\\(.*\\)>''')) : new File('typemaps/python.smart_ptr.outtm'),
       (Pattern.compile('''std::unique_ptr<\\(.*\\)>''')) : new File('typemaps/python.smart_ptr.outtm'),
@@ -90,15 +90,15 @@ Helper.setup(this,classes,
       (Pattern.compile('''(p.){0,1}std::map<\\(.*\\)>''')) : new File('typemaps/python.map.intm'),
       (Pattern.compile('''(r.){0,1}XBMCAddon::Dictionary<\\(.*\\)>''')) : new File('typemaps/python.dict.intm'),
       (Pattern.compile('''p.void''')) : '${api} = (void*)${slarg};',
-      'bool' : '${api} = (PyInt_AsLong(${slarg}) == 0L ? false : true);',
-      'long' : '${api} = PyInt_AsLong(${slarg});',
+      'bool' : '${api} = (PyLong_AsLong(${slarg}) == 0L ? false : true);',
+      'long' : '${api} = PyLong_AsLong(${slarg});',
       'unsigned long' : '${api} = PyLong_AsUnsignedLong(${slarg});',
       'long long' : '${api} = PyLong_AsLongLong(${slarg});',
       'unsigned long long' : '${api} = PyLong_AsUnsignedLongLong(${slarg});',
-      'int' : '${api} = (int)PyInt_AsLong(${slarg});',
+      'int' : '${api} = (int)PyLong_AsLong(${slarg});',
       'double' : '${api} = PyFloat_AsDouble(${slarg});',
       'float' : '${api} = (float)PyFloat_AsDouble(${slarg});',
-      'XBMCAddon::StringOrInt' : 'if (${slarg}) PyXBMCGetUnicodeString(${api},${slarg},PyInt_Check(${slarg}) || PyLong_Check(${slarg}) || PyFloat_Check(${slarg}),"${api}","${method.@name}");'
+      'XBMCAddon::StringOrInt' : 'if (${slarg}) PyXBMCGetUnicodeString(${api},${slarg},PyLong_Check(${slarg}) || PyLong_Check(${slarg}) || PyFloat_Check(${slarg}),"${api}","${method.@name}");'
     ], '${api} = (${swigTypeParser.SwigType_str(ltype)})retrieveApiInstance(${slarg},"${ltype}","${helper.findNamespace(method)}","${helper.callingName(method)}");')
 // ---------------------------------------------------------
 
@@ -149,8 +149,8 @@ void doMethod(Node method, MethodType methodType)
 <%  }
   }
 %>
-  static <% if(methodType == MethodType.destructor) { %>void<% } else { %>PyObject*<% } %> ${module.@name}_${PythonTools.getPyMethodName(method,methodType)} (<%= ((clazz == null) ? "PyObject" : 
-                   (constructor ? "PyTypeObject" : 'PyHolder')) %>* ${constructor ? 'pytype' : 'self'} <% 
+  static <% if(methodType == MethodType.destructor) { %>void<% } else { %>PyObject*<% } %> ${module.@name}_${PythonTools.getPyMethodName(method,methodType)} (<%= ((clazz == null) ? "PyObject" :
+                   (constructor ? "PyTypeObject" : 'PyHolder')) %>* ${constructor ? 'pytype' : 'self'} <%
                    if (doAsMappingIndex) { %>, PyObject* py${params[0].@name}<% }
                    else if (methodType != MethodType.destructor) { %> , PyObject *args, PyObject *kwds <%} %> )
   {
@@ -273,7 +273,7 @@ void doMethod(Node method, MethodType methodType)
 
     return result; <% } 
     else { %>
-    self->ob_type->tp_free((PyObject*)self); 
+    (((PyObject*)(self))->ob_type)->tp_free((PyObject*)self);
     <%
     }
     %>
@@ -664,22 +664,13 @@ void doClassMethodInfo(Node clazz, List initTypeCalls)
     pythonType.tp_name = (char*)"${module.@name}.${clazz.@sym_name}";
     pythonType.tp_basicsize = sizeof(PyHolder);
     pythonType.tp_dealloc = (destructor)${module.@name}_${classNameAsVariable}_Dealloc; <%
-  if (doComparator) { %>
-    pythonType.tp_compare=${module.@name}_${classNameAsVariable}_cmp;<%
-  }
+
   if (clazz.@feature_python_rcmp) { %>
     pythonType.tp_richcompare=(richcmpfunc)${module.@name}_${classNameAsVariable}_rcmp;<%
   } %>
 
-<%
-  if (clazz.@feature_iterator) { %>
-    pythonType.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_ITER;
-<%
-  }
-  else { %>
     pythonType.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE;
-<%
-  } %>
+
     pythonType.tp_doc = ${Helper.hasDoc(clazz) ? (classNameAsVariable + '__doc__') : 'NULL' };
     pythonType.tp_methods = ${classNameAsVariable}_methods; <%
   if (properties.size() > 0) { %>
@@ -919,7 +910,16 @@ namespace PythonBindings
     }
   }
 
-  void initModule_${module.@name}()
+  static struct PyModuleDef createModule
+  {
+      PyModuleDef_HEAD_INIT,
+      (char*)"${module.@name}",
+      "",
+      -1,
+      ${module.@name}_methods
+  };
+
+  PyObject *PyInit_Module_${module.@name}()
   {
     initTypes();
 
@@ -930,8 +930,8 @@ namespace PythonBindings
     Py_INCREF(&(Ty${it}_Type.pythonType));<%
    }%>
 
-    module = Py_InitModule((char*)"${module.@name}", ${module.@name}_methods);
-    if (module == NULL) return;
+    module = PyModule_Create(&createModule);
+    if (module == NULL) return NULL;
 
 <% classes.each { clazz -> %>
     PyModule_AddObject(module, (char*)"${clazz.@sym_name}", (PyObject*)(&(Ty${PythonTools.getClassNameAsVariable(clazz)}_Type.pythonType)));<%
@@ -945,12 +945,13 @@ namespace PythonBindings
    PyModule_AddStringConstant(module, (char*)"__platform__", (char*)"ALL");
 
    // need to handle constants
-<% module.depthFirst().findAll( { it.name() == 'constant'} ).each { 
-     String pyCall = 
-        (it.@type == 'int' || it.@type == 'long' || it.@type == 'unsigned int' || it.@type == 'unsigned long' || it.@type == 'bool') ? 
+<% module.depthFirst().findAll( { it.name() == 'constant'} ).each {
+     String pyCall =
+        (it.@type == 'int' || it.@type == 'long' || it.@type == 'unsigned int' || it.@type == 'unsigned long' || it.@type == 'bool') ?
         'PyModule_AddIntConstant' : 'PyModule_AddStringConstant' %>
    ${pyCall}(module,"${it.@sym_name}",${it.@value}); <%
   } %>
+  return module;
   }
 
 } // end PythonBindings namespace for python type definitions
diff --git a/xbmc/interfaces/python/XBPython.cpp b/xbmc/interfaces/python/XBPython.cpp
index a7cf6ec26205..4cafce84cb90 100644
--- a/xbmc/interfaces/python/XBPython.cpp
+++ b/xbmc/interfaces/python/XBPython.cpp
@@ -45,7 +45,7 @@
 #include "interfaces/legacy/AddonUtils.h"
 #include "interfaces/python/AddonPythonInvoker.h"
 #include "interfaces/python/PythonInvoker.h"
-
+PyThreadState* savestate;
 using namespace ANNOUNCEMENT;
 
 XBPython::XBPython()
@@ -459,8 +459,7 @@ void XBPython::Finalize()
     m_mainThreadState = NULL; // clear the main thread state before releasing the lock
     {
       CSingleExit exit(m_critSection);
-      PyEval_AcquireLock();
-      PyThreadState_Swap(curTs);
+	  PyEval_AcquireThread(curTs);
 
       Py_Finalize();
       PyEval_ReleaseLock();
@@ -476,7 +475,7 @@ void XBPython::Finalize()
 #endif
 #if defined(TARGET_POSIX) && !defined(TARGET_DARWIN) && !defined(TARGET_FREEBSD)
     // we can't release it on windows, as this is done in UnloadPythonDlls() for win32 (see above).
-    // The implementation for linux needs looking at - UnloadPythonDlls() currently only searches for "python26.dll"
+    // The implementation for linux needs looking at - UnloadPythonDlls() currently only searches for "python36.dll"
     // The implementation for osx can never unload the python dylib.
     DllLoaderContainer::ReleaseModule(m_pDll);
 #endif
@@ -545,7 +544,7 @@ bool XBPython::OnScriptInitialized(ILanguageInvoker *invoker)
 #ifndef TARGET_POSIX
     if (!FileExist("special://xbmc/system/python/DLLs/_socket.pyd") ||
       !FileExist("special://xbmc/system/python/DLLs/_ssl.pyd") ||
-      !FileExist("special://xbmc/system/python/DLLs/bz2.pyd") ||
+      !FileExist("special://xbmc/system/python/DLLs/_bz2.pyd") ||
       !FileExist("special://xbmc/system/python/DLLs/pyexpat.pyd") ||
       !FileExist("special://xbmc/system/python/DLLs/select.pyd") ||
       !FileExist("special://xbmc/system/python/DLLs/unicodedata.pyd"))
@@ -572,8 +571,8 @@ bool XBPython::OnScriptInitialized(ILanguageInvoker *invoker)
     // check if we are running as real xbmc.app or just binary
     if (!CUtil::GetFrameworksPath(true).empty())
     {
-      // using external python, it's build looking for xxx/lib/python2.6
-      // so point it to frameworks which is where python2.6 is located
+      // using external python, it's build looking for xxx/lib/python3.6
+      // so point it to frameworks which is where python3.6 is located
       setenv("PYTHONHOME", CSpecialProtocol::TranslatePath("special://frameworks").c_str(), 1);
       setenv("PYTHONPATH", CSpecialProtocol::TranslatePath("special://frameworks").c_str(), 1);
       CLog::Log(LOGDEBUG, "PYTHONHOME -> %s", CSpecialProtocol::TranslatePath("special://frameworks").c_str());
@@ -593,24 +592,21 @@ bool XBPython::OnScriptInitialized(ILanguageInvoker *invoker)
     CEnvironment::putenv(buf);
 #endif
 
-    if (PyEval_ThreadsInitialized())
-      PyEval_AcquireLock();
-    else
-      PyEval_InitThreads();
-
     Py_Initialize();
-    PyEval_ReleaseLock();
 
     // If this is not the first time we initialize Python, the interpreter
     // lock already exists and we need to lock it as PyEval_InitThreads
     // would not do that in that case.
-    PyEval_AcquireLock();
-    char* python_argv[1] = { (char*)"" };
+    if (PyEval_ThreadsInitialized())
+      PyEval_AcquireLock();
+    else
+      PyEval_InitThreads();
+    wchar_t* python_argv[1] = { L"" };
     PySys_SetArgv(1, python_argv);
 
     if (!(m_mainThreadState = PyThreadState_Get()))
       CLog::Log(LOGERROR, "Python threadstate is NULL.");
-    PyEval_ReleaseLock();
+	savestate = PyEval_SaveThread();
 
     m_bInitialized = true;
   }
diff --git a/xbmc/interfaces/python/swig.cpp b/xbmc/interfaces/python/swig.cpp
index 77a5ae5346eb..142c7eb3865b 100644
--- a/xbmc/interfaces/python/swig.cpp
+++ b/xbmc/interfaces/python/swig.cpp
@@ -29,7 +29,7 @@ namespace PythonBindings
 {
   TypeInfo::TypeInfo(const std::type_info& ti) : swigType(NULL), parentType(NULL), typeIndex(ti)
   {
-    static PyTypeObject py_type_object_header = { PyObject_HEAD_INIT(NULL) 0};
+    static PyTypeObject py_type_object_header = { PyVarObject_HEAD_INIT(NULL, 0)};
     static int size = (long*)&(py_type_object_header.tp_name) - (long*)&py_type_object_header;
     memcpy(&(this->pythonType), &py_type_object_header, size);
   }
@@ -63,18 +63,14 @@ namespace PythonBindings
       // Python unicode objects are UCS2 or UCS4 depending on compilation
       // options, wchar_t is 16-bit or 32-bit depending on platform.
       // Avoid the complexity by just letting python convert the string.
-      PyObject *utf8_pyString = PyUnicode_AsUTF8String(pObject);
 
-      if (utf8_pyString)
-      {
-        buf = PyString_AsString(utf8_pyString);
-        Py_DECREF(utf8_pyString);
-        return;
-      }
+      buf = PyUnicode_AsUTF8(pObject);
+      return;
     }
-    if (PyString_Check(pObject))
+
+    if (PyBytes_Check(pObject))    // If pobject is of type Bytes
     {
-      buf = PyString_AsString(pObject);
+      buf = PyBytes_AsString(pObject);
       return;
     }
 
@@ -180,16 +176,16 @@ namespace PythonBindings
     exceptionValue.clear();
     exceptionTraceback.clear();
 
-    if (exc_type != NULL && (pystring = PyObject_Str(exc_type)) != NULL && PyString_Check(pystring))
+    if (exc_type != NULL && (pystring = PyObject_Str(exc_type)) != NULL && PyUnicode_Check(pystring))
     {
-      char *str = PyString_AsString(pystring);
+      char *str = PyUnicode_AsUTF8(pystring);
       if (str != NULL)
         exceptionType = str;
 
       pystring = PyObject_Str(exc_value);
       if (pystring != NULL)
       {
-        str = PyString_AsString(pystring);
+        str = PyUnicode_AsUTF8(pystring);
         exceptionValue = str;
       }
 
@@ -202,7 +198,7 @@ namespace PythonBindings
 
         if (tbList)
         {
-          PyObject *emptyString = PyString_FromString("");
+          PyObject *emptyString = PyUnicode_FromString("");
           char method[] = "join";
           char format[] = "O";
           PyObject *strRetval = PyObject_CallMethod(emptyString, method, format, tbList);
@@ -210,7 +206,7 @@ namespace PythonBindings
 
           if (strRetval)
           {
-            str = PyString_AsString(strRetval);
+            str = PyUnicode_AsUTF8(strRetval);
             if (str != NULL)
               exceptionTraceback = str;
             Py_DECREF(strRetval);
diff --git a/xbmc/interfaces/python/typemaps/python.buffer.intm b/xbmc/interfaces/python/typemaps/python.buffer.intm
index c4b9b2c3a4d5..89b387c5cc2f 100644
--- a/xbmc/interfaces/python/typemaps/python.buffer.intm
+++ b/xbmc/interfaces/python/typemaps/python.buffer.intm
@@ -19,10 +19,10 @@
  *
  */
 %>
-    if (PyString_Check(${slarg}))
+    if (PyUnicode_Check(${slarg}))
     {
-      const char* str = PyString_AsString(${slarg});
-      size_t size = (size_t)PyString_Size(${slarg});
+      const char* str = PyUnicode_AsUTF8(${slarg});
+      size_t size = (size_t)PyUnicode_GetLength(${slarg});
       ${api}.allocate(size);
       ${api}.put(str,size);
       ${api}.flip(); // prepare the buffer for reading from
@@ -35,4 +35,4 @@
       ${api}.flip(); // prepare the buffer for reading from
     }
     else
-      throw XBMCAddon::WrongTypeException("argument \"%s\" for \"%s\" must be a string or a bytearray", "${api}", "${method.@name}");
\ No newline at end of file
+      throw XBMCAddon::WrongTypeException("argument \"%s\" for \"%s\" must be a string or a bytearray", "${api}", "${method.@name}");
diff --git a/xbmc/interfaces/python/typemaps/python.string.outtm b/xbmc/interfaces/python/typemaps/python.string.outtm
index 6b92a53054c8..ebb2a1235355 100644
--- a/xbmc/interfaces/python/typemaps/python.string.outtm
+++ b/xbmc/interfaces/python/typemaps/python.string.outtm
@@ -18,6 +18,6 @@
  *  <http://www.gnu.org/licenses/>.
  *
  */
-%>${result} = <% 
+%>${result} = <%
   if(method.@feature_python_coerceToUnicode) { %>PyUnicode_DecodeUTF8(${api}.c_str(),${api}.size(),"replace");<% }
-  else { %>PyString_FromStringAndSize(${api}.c_str(), ${api}.length());<% } %>
\ No newline at end of file
+  else { %>PyUnicode_FromStringAndSize(${api}.c_str(), ${api}.length());<% } %>
diff --git a/xbmc/interfaces/python3/AddonPythonInvoker.cpp b/xbmc/interfaces/python3/AddonPythonInvoker.cpp
deleted file mode 100644
index 37ba6c0b202b..000000000000
--- a/xbmc/interfaces/python3/AddonPythonInvoker.cpp
+++ /dev/null
@@ -1,133 +0,0 @@
-/*
- *      Copyright (C) 2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-// python.h should always be included first before any other includes
-#include <Python.h>
-#include <osdefs.h>
-
-#include "system.h"
-#include "AddonPythonInvoker.h"
-
-#include <utility>
-
-#define MODULE "xbmc"
-
-#define RUNSCRIPT_PREAMBLE \
-        "" \
-        "import " MODULE "\n" \
-        "xbmc.abortRequested = False\n" \
-        "class xbmcout:\n" \
-        "  def __init__(self, loglevel=" MODULE ".LOGDEBUG):\n" \
-        "    self.ll=loglevel\n" \
-        "  def write(self, data):\n" \
-        "    " MODULE ".log(data,self.ll)\n" \
-        "  def close(self):\n" \
-        "    " MODULE ".log('.')\n" \
-        "  def flush(self):\n" \
-        "    " MODULE ".log('.')\n" \
-        "import sys\n" \
-        "sys.stdout = xbmcout()\n" \
-        "sys.stderr = xbmcout(" MODULE ".LOGERROR)\n" \
-        ""
-
-#define RUNSCRIPT_SETUPTOOLS_HACK \
-  "" \
-  "import types,sys\n" \
-  "pkg_resources_code = \\\n" \
-  "\"\"\"\n" \
-  "def resource_filename(__name__,__path__):\n" \
-  "  return __path__\n" \
-  "\"\"\"\n" \
-  "pkg_resources = types.ModuleType('pkg_resources')\n" \
-  "exec(pkg_resources_code, pkg_resources.__dict__)\n" \
-  "sys.modules['pkg_resources'] = pkg_resources\n" \
-  ""
-
-#define RUNSCRIPT_POSTSCRIPT \
-        "print ('-->Python Interpreter Initialized<--')\n" \
-        ""
-
-#if defined(TARGET_ANDROID)
-
-#define RUNSCRIPT_COMPLIANT \
-  RUNSCRIPT_PREAMBLE RUNSCRIPT_SETUPTOOLS_HACK RUNSCRIPT_POSTSCRIPT
-
-#else
-
-#define RUNSCRIPT_COMPLIANT \
-  RUNSCRIPT_PREAMBLE RUNSCRIPT_POSTSCRIPT
-
-#endif
-
-namespace PythonBindings {
-  PyObject *PyInit_Module_xbmcgui(void);
-  PyObject *PyInit_Module_xbmc(void);
-  PyObject *PyInit_Module_xbmcplugin(void);
-  PyObject *PyInit_Module_xbmcaddon(void);
-  PyObject *PyInit_Module_xbmcvfs(void);
-}
-
-using namespace PythonBindings;
-
-typedef struct
-{
-  const char *name;
-  CPythonInvoker::PythonModuleInitialization initialization;
-} PythonModule;
-
-static PythonModule PythonModules[] =
-  {
-    { "xbmcgui",    PyInit_Module_xbmcgui    },
-    { "xbmc",       PyInit_Module_xbmc       },
-    { "xbmcplugin", PyInit_Module_xbmcplugin },
-    { "xbmcaddon",  PyInit_Module_xbmcaddon  },
-    { "xbmcvfs",    PyInit_Module_xbmcvfs    }
-  };
-
-#define PythonModulesSize sizeof(PythonModules) / sizeof(PythonModule)
-
-CAddonPythonInvoker::CAddonPythonInvoker(ILanguageInvocationHandler *invocationHandler)
-  : CPythonInvoker(invocationHandler)
-{
-    PyImport_AppendInittab("xbmcgui",    PyInit_Module_xbmcgui);
-    PyImport_AppendInittab("xbmc",       PyInit_Module_xbmc);
-    PyImport_AppendInittab("xbmcplugin", PyInit_Module_xbmcplugin);
-    PyImport_AppendInittab("xbmcaddon",  PyInit_Module_xbmcaddon);
-    PyImport_AppendInittab("xbmcvfs",    PyInit_Module_xbmcvfs);
-}
-
-CAddonPythonInvoker::~CAddonPythonInvoker() = default;
-
-std::map<std::string, CPythonInvoker::PythonModuleInitialization> CAddonPythonInvoker::getModules() const
-{
-  static std::map<std::string, PythonModuleInitialization> modules;
-  if (modules.empty())
-  {
-    for (size_t i = 0; i < PythonModulesSize; i++)
-      modules.insert(std::make_pair(PythonModules[i].name, PythonModules[i].initialization));
-  }
-
-  return modules;
-}
-
-const char* CAddonPythonInvoker::getInitializationScript() const
-{
-  return RUNSCRIPT_COMPLIANT;
-}
diff --git a/xbmc/interfaces/python3/AddonPythonInvoker.h b/xbmc/interfaces/python3/AddonPythonInvoker.h
deleted file mode 100644
index 1bc10183f199..000000000000
--- a/xbmc/interfaces/python3/AddonPythonInvoker.h
+++ /dev/null
@@ -1,34 +0,0 @@
-#pragma once
-/*
- *      Copyright (C) 2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#include "interfaces/python/PythonInvoker.h"
-
-class CAddonPythonInvoker : public CPythonInvoker
-{
-public:
-  explicit CAddonPythonInvoker(ILanguageInvocationHandler *invocationHandler);
-  ~CAddonPythonInvoker() override;
-
-protected:
-  // overrides of CPythonInvoker
-  std::map<std::string, PythonModuleInitialization> getModules() const override;
-  const char* getInitializationScript() const override;
-};
diff --git a/xbmc/interfaces/python3/CMakeLists.txt b/xbmc/interfaces/python3/CMakeLists.txt
deleted file mode 100644
index 061cc2b77f86..000000000000
--- a/xbmc/interfaces/python3/CMakeLists.txt
+++ /dev/null
@@ -1,21 +0,0 @@
-set(SOURCES AddonPythonInvoker.cpp
-            CallbackHandler.cpp
-            ContextItemAddonInvoker.cpp
-            LanguageHook.cpp
-            PythonInvoker.cpp
-            XBPython.cpp
-            swig.cpp
-            PyContext.cpp)
-
-set(HEADERS AddonPythonInvoker.h
-            CallbackHandler.h
-            ContextItemAddonInvoker.h
-            LanguageHook.h
-            preamble.h
-            PyContext.h
-            PythonInvoker.h
-            pythreadstate.h
-            swig.h
-            XBPython.h)
-
-core_add_library(python_interface)
diff --git a/xbmc/interfaces/python3/CallbackHandler.cpp b/xbmc/interfaces/python3/CallbackHandler.cpp
deleted file mode 100644
index e0cf64b40163..000000000000
--- a/xbmc/interfaces/python3/CallbackHandler.cpp
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#include "CallbackHandler.h"
-#include "LanguageHook.h"
-
-namespace XBMCAddon
-{
-  namespace Python
-  {
-    /**
-     * We are ASS-U-MEing that this construction is happening
-     *  within the context of a Python call. This way we can
-     *  store off the PyThreadState to later verify that we're
-     *  handling callbacks in the appropriate thread.
-     */
-    PythonCallbackHandler::PythonCallbackHandler()
-    {
-      XBMC_TRACE;
-      objectThreadState = PyThreadState_Get();
-    }
-
-    /**
-     * Now we are answering the question as to whether or not we are in the
-     *  PyThreadState that we were in when we started.
-     */
-    bool PythonCallbackHandler::isStateOk(AddonClass* obj)
-    {
-      XBMC_TRACE;
-      PyThreadState* state = PyThreadState_Get();
-      if (objectThreadState == state)
-      {
-        // make sure the interpreter is still active.
-        AddonClass::Ref<XBMCAddon::Python::PythonLanguageHook> lh(XBMCAddon::Python::PythonLanguageHook::GetIfExists(state->interp));
-        if (lh.isNotNull() && lh->HasRegisteredAddonClassInstance(obj) && lh.get() == obj->GetLanguageHook())
-          return true;
-      }
-      return false;
-    }
-
-    /**
-     * For this method we expect the PyThreadState to be passed as the user
-     *  data for the check.
-     *
-     * @todo This is a stupid way to get this information back to the handler.
-     *  there should be a more language neutral means.
-     */
-    bool PythonCallbackHandler::shouldRemoveCallback(AddonClass* obj, void* threadState)
-    {
-      XBMC_TRACE;
-      if (threadState == objectThreadState)
-        return true;
-
-      // we also want to remove the callback if the language hook no longer exists.
-      //   this is a belt-and-suspenders cleanup mechanism
-      return ! XBMCAddon::Python::PythonLanguageHook::IsAddonClassInstanceRegistered(obj);
-    }
-  }
-}
diff --git a/xbmc/interfaces/python3/CallbackHandler.h b/xbmc/interfaces/python3/CallbackHandler.h
deleted file mode 100644
index 5934d9005d92..000000000000
--- a/xbmc/interfaces/python3/CallbackHandler.h
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#include <Python.h>
-
-#include "interfaces/legacy/CallbackHandler.h"
-
-namespace XBMCAddon
-{
-  namespace Python
-  {
-    /**
-     * This class represents a specialization of the callback handler
-     *  that specifically checks to see if we're in an OK thread state
-     *  based on Python specifics.
-     */
-    class PythonCallbackHandler : public RetardedAsyncCallbackHandler
-    {
-      PyThreadState* objectThreadState;
-    public:
-
-      /**
-       * We are ASS-U-MEing that this construction is happening
-       *  within the context of a Python call. This way we can
-       *  store off the PyThreadState to later verify that we're
-       *  handling callbacks in the appropriate thread.
-       */
-      PythonCallbackHandler();
-      bool isStateOk(AddonClass* obj) override;
-      bool shouldRemoveCallback(AddonClass* obj, void* threadState) override;
-    };
-  }
-}
diff --git a/xbmc/interfaces/python3/ContextItemAddonInvoker.cpp b/xbmc/interfaces/python3/ContextItemAddonInvoker.cpp
deleted file mode 100644
index d7987c63d7b9..000000000000
--- a/xbmc/interfaces/python3/ContextItemAddonInvoker.cpp
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- *      Copyright (C) 2015 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-// python.h should always be included first before any other includes
-#include <Python.h>
-#include <osdefs.h>
-
-#include "system.h"
-#include "ContextItemAddonInvoker.h"
-#include "utils/log.h"
-#include "interfaces/python/swig.h"
-
-
-CContextItemAddonInvoker::CContextItemAddonInvoker(
-    ILanguageInvocationHandler *invocationHandler,
-    const CFileItemPtr& item)
-  : CAddonPythonInvoker(invocationHandler), m_item(CFileItemPtr(new CFileItem(*item.get())))
-{
-}
-
-CContextItemAddonInvoker::~CContextItemAddonInvoker() = default;
-
-void CContextItemAddonInvoker::onPythonModuleInitialization(void* moduleDict)
-{
-  CAddonPythonInvoker::onPythonModuleInitialization(moduleDict);
-  if (m_item)
-  {
-    XBMCAddon::xbmcgui::ListItem* arg = new XBMCAddon::xbmcgui::ListItem(m_item);
-    PyObject* pyItem = PythonBindings::makePythonInstance(arg, true);
-    if (pyItem == Py_None || PySys_SetObject((char*)"listitem", pyItem) == -1)
-    {
-      CLog::Log(LOGERROR, "CPythonInvoker(%d, %s): Failed to set sys parameter", GetId(), m_sourceFile.c_str());
-      //FIXME: we should really abort execution
-    }
-  }
-}
diff --git a/xbmc/interfaces/python3/ContextItemAddonInvoker.h b/xbmc/interfaces/python3/ContextItemAddonInvoker.h
deleted file mode 100644
index 312353f2e63f..000000000000
--- a/xbmc/interfaces/python3/ContextItemAddonInvoker.h
+++ /dev/null
@@ -1,40 +0,0 @@
-#pragma once
-/*
- *      Copyright (C) 2015 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#include <memory>
-#include "interfaces/python/AddonPythonInvoker.h"
-
-class CFileItem;
-typedef std::shared_ptr<CFileItem> CFileItemPtr;
-
-class CContextItemAddonInvoker : public CAddonPythonInvoker
-{
-public:
-  explicit CContextItemAddonInvoker(ILanguageInvocationHandler *invocationHandler,
-                                    const CFileItemPtr& item);
-  ~CContextItemAddonInvoker() override;
-
-protected:
-  void onPythonModuleInitialization(void* moduleDict) override;
-
-private:
-  const CFileItemPtr m_item;
-};
diff --git a/xbmc/interfaces/python3/LanguageHook.cpp b/xbmc/interfaces/python3/LanguageHook.cpp
deleted file mode 100644
index 32219fd3379c..000000000000
--- a/xbmc/interfaces/python3/LanguageHook.cpp
+++ /dev/null
@@ -1,210 +0,0 @@
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-
-#include "LanguageHook.h"
-#include "CallbackHandler.h"
-#include "XBPython.h"
-
-#include "interfaces/legacy/AddonUtils.h"
-#include "PyContext.h"
-
-namespace XBMCAddon
-{
-  namespace Python
-  {
-    static AddonClass::Ref<PythonLanguageHook> instance;
-
-    static CCriticalSection hooksMutex;
-    static std::map<PyInterpreterState*,AddonClass::Ref<PythonLanguageHook> > hooks;
-
-    // vtab instantiation
-    PythonLanguageHook::~PythonLanguageHook()
-    {
-      XBMC_TRACE;
-      XBMCAddon::LanguageHook::deallocating();
-    }
-
-    void PythonLanguageHook::MakePendingCalls()
-    {
-      XBMC_TRACE;
-      PythonCallbackHandler::makePendingCalls();
-    }
-
-    void PythonLanguageHook::DelayedCallOpen()
-    {
-      XBMC_TRACE;
-      PyGILLock::releaseGil();
-    }
-
-    void PythonLanguageHook::DelayedCallClose()
-    {
-      XBMC_TRACE;
-      PyGILLock::acquireGil();
-    }
-
-    void PythonLanguageHook::RegisterMe()
-    {
-      XBMC_TRACE;
-      CSingleLock lock(hooksMutex);
-      hooks[m_interp] = AddonClass::Ref<PythonLanguageHook>(this);
-    }
-
-    void PythonLanguageHook::UnregisterMe()
-    {
-      XBMC_TRACE;
-      CSingleLock lock(hooksMutex);
-      hooks.erase(m_interp);
-    }
-
-    static AddonClass::Ref<XBMCAddon::Python::PythonLanguageHook> g_languageHook;
-
-    // Ok ... we're going to get it even if it doesn't exist. If it doesn't exist then
-    // we're going to assume we're not in control of the interpreter. This (apparently)
-    // can be the case. E.g. Libspotify manages to call into a script using a ctypes
-    // extension but under the control of an Interpreter we know nothing about. In
-    // cases like this we're going to use a global interpreter
-    AddonClass::Ref<PythonLanguageHook> PythonLanguageHook::GetIfExists(PyInterpreterState* interp)
-    {
-      XBMC_TRACE;
-      CSingleLock lock(hooksMutex);
-      std::map<PyInterpreterState*,AddonClass::Ref<PythonLanguageHook> >::iterator iter = hooks.find(interp);
-      if (iter != hooks.end())
-        return AddonClass::Ref<PythonLanguageHook>(iter->second);
-
-      // if we got here then we need to use the global one.
-      if (g_languageHook.isNull())
-        g_languageHook = new XBMCAddon::Python::PythonLanguageHook();
-
-      return g_languageHook;
-    }
-
-    bool PythonLanguageHook::IsAddonClassInstanceRegistered(AddonClass* obj)
-    {
-      for (std::map<PyInterpreterState*,AddonClass::Ref<PythonLanguageHook> >::iterator iter = hooks.begin();
-           iter != hooks.end(); ++iter)
-      {
-        if ((iter->second)->HasRegisteredAddonClassInstance(obj))
-          return true;
-      }
-      return false;
-    }
-
-    /**
-     * PythonCallbackHandler expects to be instantiated PER AddonClass instance
-     *  that is to be used as a callback. This is why this cannot be instantiated
-     *  once.
-     *
-     * There is an expectation that this method is called from the Python thread
-     *  that instantiated an AddonClass that has the potential for a callback.
-     *
-     * See RetardedAsyncCallbackHandler for more details.
-     * See PythonCallbackHandler for more details
-     * See PythonCallbackHandler::PythonCallbackHandler for more details
-     */
-    XBMCAddon::CallbackHandler* PythonLanguageHook::GetCallbackHandler()
-    {
-      XBMC_TRACE;
-      return new PythonCallbackHandler();
-    }
-
-    String PythonLanguageHook::GetAddonId()
-    {
-      XBMC_TRACE;
-
-      // Get a reference to the main module
-      // and global dictionary
-      PyObject* main_module = PyImport_AddModule((char*)"__main__");
-      PyObject* global_dict = PyModule_GetDict(main_module);
-      // Extract a reference to the function "func_name"
-      // from the global dictionary
-      PyObject* pyid = PyDict_GetItemString(global_dict, "__xbmcaddonid__");
-      if (pyid)
-        return PyUnicode_AsUTF8(pyid);
-      return "";
-    }
-
-    String PythonLanguageHook::GetAddonVersion()
-    {
-      XBMC_TRACE;
-      // Get a reference to the main module
-      // and global dictionary
-      PyObject* main_module = PyImport_AddModule((char*)"__main__");
-      PyObject* global_dict = PyModule_GetDict(main_module);
-      // Extract a reference to the function "func_name"
-      // from the global dictionary
-      PyObject* pyversion = PyDict_GetItemString(global_dict, "__xbmcapiversion__");
-      if (pyversion)
-        return PyUnicode_AsUTF8(pyversion);
-      return "";
-    }
-
-    long PythonLanguageHook::GetInvokerId()
-    {
-      XBMC_TRACE;
-
-      // Get a reference to the main module
-      // and global dictionary
-      PyObject* main_module = PyImport_AddModule((char*)"__main__");
-      PyObject* global_dict = PyModule_GetDict(main_module);
-      // Extract a reference to the function "func_name"
-      // from the global dictionary
-      PyObject* pyid = PyDict_GetItemString(global_dict, "__xbmcinvokerid__");
-      if (pyid)
-        return PyLong_AsLong(pyid);
-      return -1;
-    }
-
-
-    void PythonLanguageHook::RegisterPlayerCallback(IPlayerCallback* player) { XBMC_TRACE; g_pythonParser.RegisterPythonPlayerCallBack(player); }
-    void PythonLanguageHook::UnregisterPlayerCallback(IPlayerCallback* player) { XBMC_TRACE; g_pythonParser.UnregisterPythonPlayerCallBack(player); }
-    void PythonLanguageHook::RegisterMonitorCallback(XBMCAddon::xbmc::Monitor* monitor) { XBMC_TRACE; g_pythonParser.RegisterPythonMonitorCallBack(monitor); }
-    void PythonLanguageHook::UnregisterMonitorCallback(XBMCAddon::xbmc::Monitor* monitor) { XBMC_TRACE; g_pythonParser.UnregisterPythonMonitorCallBack(monitor); }
-
-    bool PythonLanguageHook::WaitForEvent(CEvent& hEvent, unsigned int milliseconds)
-    {
-      XBMC_TRACE;
-      return g_pythonParser.WaitForEvent(hEvent,milliseconds);
-    }
-
-    void PythonLanguageHook::RegisterAddonClassInstance(AddonClass* obj)
-    {
-      XBMC_TRACE;
-      CSingleLock l(*this);
-      obj->Acquire();
-      currentObjects.insert(obj);
-    }
-
-    void PythonLanguageHook::UnregisterAddonClassInstance(AddonClass* obj)
-    {
-      XBMC_TRACE;
-      CSingleLock l(*this);
-      if (currentObjects.erase(obj) > 0)
-        obj->Release();
-    }
-
-    bool PythonLanguageHook::HasRegisteredAddonClassInstance(AddonClass* obj)
-    {
-      XBMC_TRACE;
-      CSingleLock l(*this);
-      return currentObjects.find(obj) != currentObjects.end();
-    }
-  }
-}
diff --git a/xbmc/interfaces/python3/LanguageHook.h b/xbmc/interfaces/python3/LanguageHook.h
deleted file mode 100644
index 07847992bad0..000000000000
--- a/xbmc/interfaces/python3/LanguageHook.h
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#pragma once
-
-#include <Python.h>
-
-#include "interfaces/legacy/LanguageHook.h"
-#include "threads/Event.h"
-
-#include <set>
-#include <map>
-
-namespace XBMCAddon
-{
-  namespace Python
-  {
-    struct MutableInteger;
-
-    /**
-     * This class supplies the python specific functionality for
-     *  plugging into the API. It's got a static only implementation
-     *  and uses the singleton pattern for access.
-     */
-    class PythonLanguageHook : public XBMCAddon::LanguageHook
-    {
-      PyInterpreterState* m_interp;
-      CCriticalSection crit;
-      std::set<AddonClass*> currentObjects;
-
-      // This constructor is only used to instantiate the global LanguageHook
-      inline PythonLanguageHook() : m_interp(NULL)  {  }
-
-    public:
-
-      inline explicit PythonLanguageHook(PyInterpreterState* interp) : m_interp(interp)  {  }
-      ~PythonLanguageHook() override;
-
-      void DelayedCallOpen() override;
-      void DelayedCallClose() override;
-      void MakePendingCalls() override;
-      
-      /**
-       * PythonCallbackHandler expects to be instantiated PER AddonClass instance
-       *  that is to be used as a callback. This is why this cannot be instantiated
-       *  once.
-       *
-       * There is an expectation that this method is called from the Python thread
-       *  that instantiated an AddonClass that has the potential for a callback.
-       *
-       * See RetardedAsyncCallbackHandler for more details.
-       * See PythonCallbackHandler for more details
-       * See PythonCallbackHandler::PythonCallbackHandler for more details
-       */
-      XBMCAddon::CallbackHandler* GetCallbackHandler() override;
-
-      String GetAddonId() override;
-      String GetAddonVersion() override;
-      long GetInvokerId() override;
-
-      void RegisterPlayerCallback(IPlayerCallback* player) override;
-      void UnregisterPlayerCallback(IPlayerCallback* player) override;
-      void RegisterMonitorCallback(XBMCAddon::xbmc::Monitor* monitor) override;
-      void UnregisterMonitorCallback(XBMCAddon::xbmc::Monitor* monitor) override;
-      bool WaitForEvent(CEvent& hEvent, unsigned int milliseconds) override;
-
-      static AddonClass::Ref<PythonLanguageHook> GetIfExists(PyInterpreterState* interp);
-      static bool IsAddonClassInstanceRegistered(AddonClass* obj);
-
-      void RegisterAddonClassInstance(AddonClass* obj);
-      void UnregisterAddonClassInstance(AddonClass* obj);
-      bool HasRegisteredAddonClassInstance(AddonClass* obj);
-      inline bool HasRegisteredAddonClasses() { CSingleLock l(*this); return !currentObjects.empty(); }
-
-      // You should hold the lock on the LanguageHook itself if you're
-      // going to do anything with the set that gets returned.
-      inline std::set<AddonClass*>& GetRegisteredAddonClasses() { return currentObjects; }
-
-      void UnregisterMe();
-      void RegisterMe();
-    };
-  }
-}
-
diff --git a/xbmc/interfaces/python3/MethodType.groovy b/xbmc/interfaces/python3/MethodType.groovy
deleted file mode 100644
index 7739e90b53e0..000000000000
--- a/xbmc/interfaces/python3/MethodType.groovy
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-public enum MethodType
-{
-  constructor, destructor, method
-}
-
-
diff --git a/xbmc/interfaces/python3/PyContext.cpp b/xbmc/interfaces/python3/PyContext.cpp
deleted file mode 100644
index 7ae67d0d39da..000000000000
--- a/xbmc/interfaces/python3/PyContext.cpp
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#include <Python.h>
-
-#include "PyContext.h"
-#include "threads/ThreadLocal.h"
-#include "utils/log.h"
-
-namespace XBMCAddon
-{
-  namespace Python
-  {
-    struct PyContextState
-    {
-      inline explicit PyContextState(bool pcreatedByGilRelease = false) :
-        value(0), state(NULL), gilReleasedDepth(0), createdByGilRelease(pcreatedByGilRelease) {}
-
-      int value;
-      PyThreadState* state;
-      int gilReleasedDepth;
-      bool createdByGilRelease;
-    };
-
-    static XbmcThreads::ThreadLocal<PyContextState> tlsPyContextState;
-
-    void* PyContext::enterContext()
-    {
-      PyContextState* cur = tlsPyContextState.get();
-      if (cur == NULL)
-      {
-        cur = new PyContextState();
-        tlsPyContextState.set(cur);
-      }
-
-      // increment the count
-      cur->value++;
-
-      return cur;
-    }
-
-    void PyContext::leaveContext()
-    {
-      // here we ASSUME that the constructor was called.
-      PyContextState* cur = tlsPyContextState.get();
-      cur->value--;
-      int curlevel = cur->value;
-
-      // this is a hack but ...
-      if (curlevel < 0)
-      {
-        CLog::Log(LOGERROR, "FATAL: PyContext closed more than opened");
-        curlevel = cur->value = 0;
-      }
-
-      if (curlevel == 0)
-      {
-        // clear the tlsPyContextState
-        tlsPyContextState.set(NULL);
-        delete cur;
-      }
-    }
-
-    void PyGILLock::releaseGil()
-    {
-      PyContextState* cur = tlsPyContextState.get();
-
-      // This means we're not within the python context, but
-      // because we may be in a thread spawned by python itself,
-      // we need to handle this.
-      if (!cur)
-      {
-        cur = static_cast<PyContextState*>(PyContext::enterContext());
-        cur->createdByGilRelease = true;
-      }
-
-      if (cur->gilReleasedDepth == 0) // true if we are at the outermost
-      {
-        PyThreadState* _save;
-        // this macro sets _save
-        {
-          Py_UNBLOCK_THREADS
-        }
-        cur->state = _save;
-      }
-      cur->gilReleasedDepth++; // the first time this goes to 1
-    }
-
-    void PyGILLock::acquireGil()
-    {
-      PyContextState* cur = tlsPyContextState.get(); 
-
-      // it's not possible for cur to be NULL (and if it is, we want to fail anyway).
-
-      // decrement the depth and make sure we're in the right place.
-      cur->gilReleasedDepth--;
-      if (cur->gilReleasedDepth == 0) // are we back to zero?
-      {
-        PyThreadState* _save = cur->state;
-        // This macros uses _save
-        {
-          Py_BLOCK_THREADS
-        }
-        cur->state = NULL; // clear the state to indicate we've reacquired the gil
-
-        // we clear it only if we created it on this level.
-        if (cur->createdByGilRelease)
-          PyContext::leaveContext();
-      }
-    }
-  }
-}
diff --git a/xbmc/interfaces/python3/PyContext.h b/xbmc/interfaces/python3/PyContext.h
deleted file mode 100644
index 1c74156d7541..000000000000
--- a/xbmc/interfaces/python3/PyContext.h
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-namespace XBMCAddon
-{
-  namespace Python
-  {
-    class PyGILLock;
-
-    /**
-     * These classes should NOT be used with 'new'. They are expected to reside 
-     *  as stack instances and they act as "Guard" classes that track the
-     *  current context.
-     */
-    class PyContext
-    {
-    protected:
-      friend class PyGILLock;
-      static void* enterContext();
-      static void leaveContext();
-    public:
-
-      inline PyContext() { enterContext(); }
-      inline ~PyContext() { leaveContext(); }
-    };
-
-    /**
-     * This class supports recursive locking of the GIL. It assumes that
-     * all Python GIL manipulation is done through this class so that it 
-     * can monitor the current owner.
-     */
-    class PyGILLock
-    {
-    public:
-      static void releaseGil();
-      static void acquireGil();
-
-      inline PyGILLock() { releaseGil(); }
-      inline ~PyGILLock() { acquireGil(); }
-    };
-  }
-}
diff --git a/xbmc/interfaces/python3/PythonInvoker.cpp b/xbmc/interfaces/python3/PythonInvoker.cpp
deleted file mode 100644
index 2d6ffd7ebcb7..000000000000
--- a/xbmc/interfaces/python3/PythonInvoker.cpp
+++ /dev/null
@@ -1,715 +0,0 @@
-/*
- *      Copyright (C) 2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-// python.h should always be included first before any other includes
-#include <Python.h>
-#include <iterator>
-#include <osdefs.h>
-
-#include "system.h"
-#include "PythonInvoker.h"
-#include "Application.h"
-#include "messaging/ApplicationMessenger.h"
-#include "addons/AddonManager.h"
-#include "dialogs/GUIDialogKaiToast.h"
-#include "filesystem/File.h"
-#include "filesystem/SpecialProtocol.h"
-#include "guilib/GraphicContext.h"
-#include "guilib/GUIWindowManager.h"
-#include "guilib/LocalizeStrings.h"
-#include "interfaces/legacy/Addon.h"
-#include "interfaces/python/LanguageHook.h"
-#include "interfaces/python/PyContext.h"
-#include "interfaces/python/pythreadstate.h"
-#include "interfaces/python/swig.h"
-#include "interfaces/python/XBPython.h"
-#include "threads/SingleLock.h"
-#include "utils/CharsetConverter.h"
-#include "utils/log.h"
-#include "utils/StringUtils.h"
-#include "utils/URIUtils.h"
-#ifdef TARGET_POSIX
-#include "linux/XTimeUtils.h"
-#endif
-
-#ifdef TARGET_WINDOWS
-extern "C" FILE *fopen_utf8(const char *_Filename, const char *_Mode);
-#else
-#define fopen_utf8 fopen
-#endif
-
-#define GC_SCRIPT \
-  "import gc\n" \
-  "gc.collect(2)\n"
-
-#define PY_PATH_SEP DELIM
-
-// Time before ill-behaved scripts are terminated
-#define PYTHON_SCRIPT_TIMEOUT 5000 // ms
-
-using namespace XFILE;
-using namespace KODI::MESSAGING;
-
-extern "C"
-{
-  int xbp_chdir(const char *dirname);
-  char* dll_getenv(const char* szKey);
-}
-
-#define PythonModulesSize sizeof(PythonModules) / sizeof(PythonModule)
-
-CCriticalSection CPythonInvoker::s_critical;
-
-static const std::string getListOfAddonClassesAsString(XBMCAddon::AddonClass::Ref<XBMCAddon::Python::PythonLanguageHook>& languageHook)
-{
-  std::string message;
-  CSingleLock l(*(languageHook.get()));
-  std::set<XBMCAddon::AddonClass*>& acs = languageHook->GetRegisteredAddonClasses();
-  bool firstTime = true;
-  for (std::set<XBMCAddon::AddonClass*>::iterator iter = acs.begin(); iter != acs.end(); ++iter)
-  {
-    if (!firstTime)
-      message += ",";
-    else
-      firstTime = false;
-    message += (*iter)->GetClassname();
-  }
-
-  return message;
-}
-
-static std::vector<std::vector<wchar_t>> storeArgumentsCCompatible(std::vector<std::wstring> const & input)
-{
-  std::vector<std::vector<wchar_t>> output;
-  std::transform(input.begin(), input.end(), std::back_inserter(output),
-                [](std::wstring const & i) { return std::vector<wchar_t>(i.c_str(), i.c_str() + i.length() + 1); });
-
-  if (output.empty())
-    output.push_back(std::vector<wchar_t>(1u, '\0'));
-
-  return output;
-}
-
-static std::vector<wchar_t *> getCPointersToArguments(std::vector<std::vector<wchar_t>> & input)
-{
-  std::vector<wchar_t *> output;
-  std::transform(input.begin(), input.end(), std::back_inserter(output),
-                [](std::vector<wchar_t> & i) { return &i[0]; });
-  return output;
-}
-
-CPythonInvoker::CPythonInvoker(ILanguageInvocationHandler *invocationHandler)
-  : ILanguageInvoker(invocationHandler),
-    m_threadState(NULL), m_stop(false)
-{ }
-
-CPythonInvoker::~CPythonInvoker()
-{
-  // nothing to do for the default invoker used for registration with the
-  // CScriptInvocationManager
-  if (GetId() < 0)
-    return;
-
-  if (GetState() < InvokerStateDone)
-    CLog::Log(LOGDEBUG, "CPythonInvoker(%d): waiting for python thread \"%s\" to stop",
-      GetId(), (!m_sourceFile.empty() ? m_sourceFile.c_str() : "unknown script"));
-  Stop(true);
-  pulseGlobalEvent();
-
-  onExecutionFinalized();
-}
-
-bool CPythonInvoker::Execute(const std::string &script, const std::vector<std::string> &arguments /* = std::vector<std::string>() */)
-{
-  if (script.empty())
-    return false;
-
-  if (!CFile::Exists(script))
-  {
-    CLog::Log(LOGERROR, "CPythonInvoker(%d): python script \"%s\" does not exist", GetId(), CSpecialProtocol::TranslatePath(script).c_str());
-    return false;
-  }
-
-  if (!onExecutionInitialized())
-    return false;
-
-  return ILanguageInvoker::Execute(script, arguments);
-}
-
-bool CPythonInvoker::execute(const std::string &script, const std::vector<std::string> &arguments)
-{
-  std::vector<std::wstring> w_arguments;
-  for (auto argument : arguments)
-  {
-    std::wstring w_argument;
-    g_charsetConverter.utf8ToW(argument, w_argument);
-    w_arguments.push_back(w_argument);
-  }
-  return execute(script, w_arguments);
-}
-
-bool CPythonInvoker::execute(const std::string &script, const std::vector<std::wstring> &arguments)
-{
-  // copy the code/script into a local string buffer
-  m_sourceFile = script;
-
-  // copy the arguments into a local buffer
-  unsigned int argc = arguments.size();
-  std::vector<std::vector<wchar_t>> argvStorage = storeArgumentsCCompatible(arguments);
-  std::vector<wchar_t *> argv = getCPointersToArguments(argvStorage);
-
-  CLog::Log(LOGDEBUG, "CPythonInvoker(%d, %s): start processing", GetId(), m_sourceFile.c_str());
-
-  // get the global lock
-  extern PyThreadState* savestate;
-  PyEval_RestoreThread(savestate);
-  PyThreadState* state = Py_NewInterpreter();
-  if (state == NULL)
-  {
-    PyEval_ReleaseLock();
-    CLog::Log(LOGERROR, "CPythonInvoker(%d, %s): FAILED to get thread state!", GetId(), m_sourceFile.c_str());
-    return false;
-  }
-  // swap in my thread state
-  PyThreadState_Swap(state);
-
-  XBMCAddon::AddonClass::Ref<XBMCAddon::Python::PythonLanguageHook> languageHook(new XBMCAddon::Python::PythonLanguageHook(state->interp));
-  languageHook->RegisterMe();
-
-  onInitialization();
-  setState(InvokerStateInitialized);
-
-  std::string realFilename(CSpecialProtocol::TranslatePath(m_sourceFile));
-  if (realFilename == m_sourceFile)
-    CLog::Log(LOGDEBUG, "CPythonInvoker(%d, %s): the source file to load is \"%s\"", GetId(), m_sourceFile.c_str(), m_sourceFile.c_str());
-  else
-    CLog::Log(LOGDEBUG, "CPythonInvoker(%d, %s): the source file to load is \"%s\" (\"%s\")", GetId(), m_sourceFile.c_str(), m_sourceFile.c_str(), realFilename.c_str());
-
-  // get path from script file name and add python path's
-  // this is used for python so it will search modules from script path first
-  std::string scriptDir = URIUtils::GetDirectory(realFilename);
-  URIUtils::RemoveSlashAtEnd(scriptDir);
-  addPath(scriptDir);
-
-  // add all addon module dependencies to path
-  if (m_addon)
-  {
-    std::set<std::string> paths;
-    getAddonModuleDeps(m_addon, paths);
-    for (std::set<std::string>::const_iterator it = paths.begin(); it != paths.end(); ++it)
-      addPath(*it);
-  }
-  else
-  { // for backwards compatibility.
-    // we don't have any addon so just add all addon modules installed
-    CLog::Log(LOGWARNING, "CPythonInvoker(%d): Script invoked without an addon. Adding all addon "
-        "modules installed to python path as fallback. This behaviour will be removed in future "
-        "version.", GetId());
-    ADDON::VECADDONS addons;
-    ADDON::CAddonMgr::GetInstance().GetAddons(addons, ADDON::ADDON_SCRIPT_MODULE);
-    for (unsigned int i = 0; i < addons.size(); ++i)
-      addPath(CSpecialProtocol::TranslatePath(addons[i]->LibPath()));
-  }
-
-  // we want to use sys.path so it includes site-packages
-  // if this fails, default to using Py_GetPath
-  PyObject *sysMod(PyImport_ImportModule((char*)"sys")); // must call Py_DECREF when finished
-  PyObject *sysModDict(PyModule_GetDict(sysMod)); // borrowed ref, no need to delete
-  PyObject *pathObj(PyDict_GetItemString(sysModDict, "path")); // borrowed ref, no need to delete
-
-  if (pathObj != NULL && PyList_Check(pathObj))
-  {
-    for (int i = 0; i < PyList_Size(pathObj); i++)
-    {
-      PyObject *e = PyList_GetItem(pathObj, i); // borrowed ref, no need to delete
-      if (e != NULL && PyUnicode_Check(e))
-        addNativePath(PyUnicode_AsUTF8(e)); // returns internal data, don't delete or modify
-    }
-  }
-  else
-  {
-      std::string GetPath;
-      g_charsetConverter.wToUTF8(Py_GetPath(), GetPath);
-      addNativePath(GetPath);
-  }
-
-  Py_DECREF(sysMod); // release ref to sysMod
-
-  // set current directory and python's path.
-  PySys_SetArgv(argc, &argv[0]);
-
-  #ifdef TARGET_WINDOWS
-  std::string pyPathUtf8;
-  g_charsetConverter.systemToUtf8(m_pythonPath, pyPathUtf8, false);
-  CLog::Log(LOGDEBUG, "CPythonInvoker(%d, %s): setting the Python path to %s", GetId(), m_sourceFile.c_str(), pyPathUtf8.c_str());
-  #else // ! TARGET_WINDOWS
-  CLog::Log(LOGDEBUG, "CPythonInvoker(%d, %s): setting the Python path to %s", GetId(), m_sourceFile.c_str(), m_pythonPath.c_str());
-  #endif // ! TARGET_WINDOWS
-
-  std::wstring pypath;
-  g_charsetConverter.utf8ToW(m_pythonPath, pypath);
-  PySys_SetPath(pypath.c_str());
-
-  CLog::Log(LOGDEBUG, "CPythonInvoker(%d, %s): entering source directory %s", GetId(), m_sourceFile.c_str(), scriptDir.c_str());
-  PyObject* module = PyImport_AddModule((char*)"__main__");
-  PyObject* moduleDict = PyModule_GetDict(module);
-
-  // when we are done initing we store thread state so we can be aborted
-  PyThreadState_Swap(NULL);
-  PyEval_ReleaseLock();
-
-  // we need to check if we was asked to abort before we had inited
-  bool stopping = false;
-  { CSingleLock lock(m_critical);
-    m_threadState = state;
-    stopping = m_stop;
-  }
-
-  PyEval_AcquireThread(state);
-
-  bool failed = false;
-  std::string exceptionType, exceptionValue, exceptionTraceback;
-  if (!stopping)
-  {
-    try
-    {
-      // run script from file
-      // We need to have python open the file because on Windows the DLL that python
-      //  is linked against may not be the DLL that xbmc is linked against so
-      //  passing a FILE* to python from an fopen has the potential to crash.
-      std::string nativeFilename(realFilename); // filename in system encoding
-      #ifdef TARGET_WINDOWS
-        if (!g_charsetConverter.utf8ToSystem(nativeFilename, true))
-        {
-          CLog::Log(LOGERROR, "CPythonInvoker(%d, %s): can't convert filename \"%s\" to system encoding", GetId(), m_sourceFile.c_str(), realFilename.c_str());
-          return false;
-        }
-      #endif
-    PyObject *ioMod, *openedFile;
-    ioMod = PyImport_ImportModule("io");
-    openedFile = PyObject_CallMethod(ioMod, "open", "ss", (char *)nativeFilename.c_str(), "r");
-    Py_DECREF(ioMod);
-    FILE *fp = PyFile_AsFileWithMode(openedFile, (char *)"r");
-
-      if (fp != NULL)
-      {
-        PyObject *f = PyUnicode_FromString(nativeFilename.c_str());
-        PyDict_SetItemString(moduleDict, "__file__", f);
-
-        onPythonModuleInitialization(moduleDict);
-
-        Py_DECREF(f);
-        setState(InvokerStateRunning);
-        XBMCAddon::Python::PyContext pycontext; // this is a guard class that marks this callstack as being in a python context
-        executeScript(fp, nativeFilename, module, moduleDict);
-      }
-      else
-        CLog::Log(LOGERROR, "CPythonInvoker(%d, %s): %s not found!", GetId(), m_sourceFile.c_str(), m_sourceFile.c_str());
-    }
-    catch (const XbmcCommons::Exception& e)
-    {
-      setState(InvokerStateFailed);
-      e.LogThrowMessage();
-      failed = true;
-    }
-    catch (...)
-    {
-      setState(InvokerStateFailed);
-      CLog::Log(LOGERROR, "CPythonInvoker(%d, %s): failure in script", GetId(), m_sourceFile.c_str());
-      failed = true;
-    }
-  }
-
-  bool systemExitThrown = false;
-  InvokerState stateToSet;
-  if (!failed && !PyErr_Occurred())
-  {
-    CLog::Log(LOGINFO, "CPythonInvoker(%d, %s): script successfully run", GetId(), m_sourceFile.c_str());
-    stateToSet = InvokerStateDone;
-    onSuccess();
-  }
-  else if (PyErr_ExceptionMatches(PyExc_SystemExit))
-  {
-    systemExitThrown = true;
-    CLog::Log(LOGINFO, "CPythonInvoker(%d, %s): script aborted", GetId(), m_sourceFile.c_str());
-    stateToSet = InvokerStateFailed;
-    onAbort();
-  }
-  else
-  {
-    stateToSet = InvokerStateFailed;
-
-    // if it failed with an exception we already logged the details
-    if (!failed)
-    {
-      PythonBindings::PythonToCppException *e = NULL;
-      if (PythonBindings::PythonToCppException::ParsePythonException(exceptionType, exceptionValue, exceptionTraceback))
-        e = new PythonBindings::PythonToCppException(exceptionType, exceptionValue, exceptionTraceback);
-      else
-        e = new PythonBindings::PythonToCppException();
-
-      e->LogThrowMessage();
-      delete e;
-    }
-
-    onError(exceptionType, exceptionValue, exceptionTraceback);
-  }
-
-  // no need to do anything else because the script has already stopped
-  if (failed)
-  {
-    setState(stateToSet);
-    return true;
-  }
-
-  PyObject *m = PyImport_AddModule((char*)"xbmc");
-  if (m == NULL || PyObject_SetAttrString(m, (char*)"abortRequested", PyBool_FromLong(1)))
-    CLog::Log(LOGERROR, "CPythonInvoker(%d, %s): failed to set abortRequested", GetId(), m_sourceFile.c_str());
-
-  // make sure all sub threads have finished
-  for (PyThreadState* s = state->interp->tstate_head, *old = NULL; s;)
-  {
-    if (s == state)
-    {
-      s = s->next;
-      continue;
-    }
-    if (old != s)
-    {
-      CLog::Log(LOGINFO, "CPythonInvoker(%d, %s): waiting on thread %" PRIu64, GetId(), m_sourceFile.c_str(), (uint64_t)s->thread_id);
-      old = s;
-    }
-
-    CPyThreadState pyState;
-    Sleep(100);
-    pyState.Restore();
-
-    s = state->interp->tstate_head;
-  }
-
-  // pending calls must be cleared out
-  XBMCAddon::RetardedAsyncCallbackHandler::clearPendingCalls(state);
-
-  PyThreadState_Swap(NULL);
-  PyEval_ReleaseLock();
-
-  // set stopped event - this allows ::stop to run and kill remaining threads
-  // this event has to be fired without holding m_critical
-  // also the GIL (PyEval_AcquireLock) must not be held
-  // if not obeyed there is still no deadlock because ::stop waits with timeout (smart one!)
-  m_stoppedEvent.Set();
-
-  { CSingleLock lock(m_critical);
-    m_threadState = NULL;
-  }
-
-  PyEval_AcquireThread(state);
-
-  onDeinitialization();
-
-  // run the gc before finishing
-  //
-  // if the script exited by throwing a SystemExit exception then going back
-  // into the interpreter causes this python bug to get hit:
-  //    http://bugs.python.org/issue10582
-  // and that causes major failures. So we are not going to go back in
-  // to run the GC if that's the case.
-  if (!m_stop && languageHook->HasRegisteredAddonClasses() && !systemExitThrown &&
-      PyRun_SimpleString(GC_SCRIPT) == -1)
-  CLog::Log(LOGERROR, "CPythonInvoker(%d, %s): failed to run the gc to clean up after running prior to shutting down the Interpreter", GetId(), m_sourceFile.c_str());
-
-  Py_EndInterpreter(state);
-
-  // If we still have objects left around, produce an error message detailing what's been left behind
-  if (languageHook->HasRegisteredAddonClasses())
-    CLog::Log(LOGWARNING, "CPythonInvoker(%d, %s): the python script \"%s\" has left several "
-      "classes in memory that we couldn't clean up. The classes include: %s",
-    GetId(), m_sourceFile.c_str(), m_sourceFile.c_str(), getListOfAddonClassesAsString(languageHook).c_str());
-
-  // unregister the language hook
-  languageHook->UnregisterMe();
-
-  PyEval_ReleaseLock();
-
-  setState(stateToSet);
-
-  return true;
-}
-
-void CPythonInvoker::executeScript(void *fp, const std::string &script, void *module, void *moduleDict)
-{
-  if (fp == NULL || script.empty() || module == NULL || moduleDict == NULL)
-    return;
-
-  int m_Py_file_input = Py_file_input;
-  PyRun_FileExFlags(static_cast<FILE*>(fp), script.c_str(), m_Py_file_input, static_cast<PyObject*>(moduleDict), static_cast<PyObject*>(moduleDict), 1, NULL);
-}
-
-FILE* CPythonInvoker::PyFile_AsFileWithMode(PyObject *py_file, const char *mode)
-{
-    FILE *f;
-    PyObject *ret;
-    int fd;
-
-    ret = PyObject_CallMethod(py_file, "flush", "");
-    if (ret == NULL)
-        return NULL;
-    Py_DECREF(ret);
-
-    fd = PyObject_AsFileDescriptor(py_file);
-    if (fd == -1)
-        return NULL;
-
-    f = fdopen(fd, mode);
-    if (f == NULL) {
-        PyErr_SetFromErrno(PyExc_OSError);
-        return NULL;
-    }
-
-    return f;
-}
-
-bool CPythonInvoker::stop(bool abort)
-{
-  CSingleLock lock(m_critical);
-  m_stop = true;
-
-  if (!IsRunning())
-    return false;
-
-  setState(InvokerStateStopping);
-
-  if (m_threadState != NULL)
-  {
-    PyEval_AcquireLock();
-    PyThreadState* old = PyThreadState_Swap((PyThreadState*)m_threadState);
-
-    //tell xbmc.Monitor to call onAbortRequested()
-    if (m_addon != NULL)
-      onAbortRequested();
-
-    PyObject *m;
-    m = PyImport_AddModule((char*)"xbmc");
-    if (m == NULL || PyObject_SetAttrString(m, (char*)"abortRequested", PyBool_FromLong(1)))
-      CLog::Log(LOGERROR, "CPythonInvoker(%d, %s): failed to set abortRequested", GetId(), m_sourceFile.c_str());
-
-    PyThreadState_Swap(old);
-    old = NULL;
-    PyEval_ReleaseLock();
-
-    XbmcThreads::EndTime timeout(PYTHON_SCRIPT_TIMEOUT);
-    while (!m_stoppedEvent.WaitMSec(15))
-    {
-      if (timeout.IsTimePast())
-      {
-        CLog::Log(LOGERROR, "CPythonInvoker(%d, %s): script didn't stop in %d seconds - let's kill it", GetId(), m_sourceFile.c_str(), PYTHON_SCRIPT_TIMEOUT / 1000);
-        break;
-      }
-
-      // We can't empty-spin in the main thread and expect scripts to be able to
-      // dismantle themselves. Python dialogs aren't normal XBMC dialogs, they rely
-      // on TMSG_GUI_PYTHON_DIALOG messages, so pump the message loop.
-      if (g_application.IsCurrentThread())
-      {
-        CApplicationMessenger::GetInstance().ProcessMessages();
-      }
-    }
-
-    // Useful for add-on performance metrics
-    if (!timeout.IsTimePast())
-      CLog::Log(LOGDEBUG, "CPythonInvoker(%d, %s): script termination took %dms", GetId(), m_sourceFile.c_str(), PYTHON_SCRIPT_TIMEOUT - timeout.MillisLeft());
-
-    // everything which didn't exit by now gets killed
-    {
-      // grabbing the PyLock while holding the m_critical is asking for a deadlock
-      CSingleExit ex2(m_critical);
-      PyEval_AcquireLock();
-    }
-
-    // Since we released the m_critical it's possible that the state is cleaned up
-    // so we need to recheck for m_threadState == NULL
-    if (m_threadState != NULL)
-    {
-      old = PyThreadState_Swap((PyThreadState*)m_threadState);
-      for (PyThreadState* state = ((PyThreadState*)m_threadState)->interp->tstate_head; state; state = state->next)
-      {
-        // Raise a SystemExit exception in python threads
-        Py_XDECREF(state->async_exc);
-        state->async_exc = PyExc_SystemExit;
-        Py_XINCREF(state->async_exc);
-      }
-
-      // If a dialog entered its doModal(), we need to wake it to see the exception
-      pulseGlobalEvent();
-    }
-
-    if (old != NULL)
-      PyThreadState_Swap(old);
-
-    lock.Leave();
-    PyEval_ReleaseLock();
-  }
-
-  return true;
-}
-
-void CPythonInvoker::onExecutionFailed()
-{
-  PyThreadState_Swap(NULL);
-  PyEval_ReleaseLock();
-
-  setState(InvokerStateFailed);
-  CLog::Log(LOGERROR, "CPythonInvoker(%d, %s): abnormally terminating python thread", GetId(), m_sourceFile.c_str());
-
-  CSingleLock lock(m_critical);
-  m_threadState = NULL;
-
-  ILanguageInvoker::onExecutionFailed();
-}
-
-void CPythonInvoker::onInitialization()
-{
-  XBMC_TRACE;
-  {
-    GilSafeSingleLock lock(s_critical);
-    initializeModules(getModules());
-  }
-
-  // get a possible initialization script
-  const char* runscript = getInitializationScript();
-  if (runscript!= NULL && strlen(runscript) > 0)
-  {
-    // redirecting default output to debug console
-    if (PyRun_SimpleString(runscript) == -1)
-      CLog::Log(LOGFATAL, "CPythonInvoker(%d, %s): initialize error", GetId(), m_sourceFile.c_str());
-  }
-}
-
-void CPythonInvoker::onPythonModuleInitialization(void* moduleDict)
-{
-  if (m_addon.get() == NULL || moduleDict == NULL)
-    return;
-
-  PyObject *moduleDictionary = (PyObject *)moduleDict;
-
-  PyObject *pyaddonid = PyUnicode_FromString(m_addon->ID().c_str());
-  PyDict_SetItemString(moduleDictionary, "__xbmcaddonid__", pyaddonid);
-
-  ADDON::AddonVersion version = m_addon->GetDependencyVersion("xbmc.python");
-  PyObject *pyxbmcapiversion = PyUnicode_FromString(version.asString().c_str());
-  PyDict_SetItemString(moduleDictionary, "__xbmcapiversion__", pyxbmcapiversion);
-
-  PyObject *pyinvokerid = PyLong_FromLong(GetId());
-  PyDict_SetItemString(moduleDictionary, "__xbmcinvokerid__", pyinvokerid);
-
-  CLog::Log(LOGDEBUG, "CPythonInvoker(%d, %s): instantiating addon using automatically obtained id of \"%s\" dependent on version %s of the xbmc.python api",
-            GetId(), m_sourceFile.c_str(), m_addon->ID().c_str(), version.asString().c_str());
-}
-
-void CPythonInvoker::onDeinitialization()
-{
-  XBMC_TRACE;
-}
-
-void CPythonInvoker::onError(const std::string &exceptionType /* = "" */, const std::string &exceptionValue /* = "" */, const std::string &exceptionTraceback /* = "" */)
-{
-  CPyThreadState releaseGil;
-  CSingleLock gc(g_graphicsContext);
-
-  CGUIDialogKaiToast *pDlgToast = g_windowManager.GetWindow<CGUIDialogKaiToast>(WINDOW_DIALOG_KAI_TOAST);
-  if (pDlgToast != NULL)
-  {
-    std::string message;
-    if (m_addon && !m_addon->Name().empty())
-      message = StringUtils::Format(g_localizeStrings.Get(2102).c_str(), m_addon->Name().c_str());
-    else if (m_sourceFile == CSpecialProtocol::TranslatePath("special://profile/autoexec.py"))
-      message = StringUtils::Format(g_localizeStrings.Get(2102).c_str(), "autoexec.py");
-    else
-       message = g_localizeStrings.Get(2103);
-    pDlgToast->QueueNotification(CGUIDialogKaiToast::Error, message, g_localizeStrings.Get(2104));
-  }
-}
-
-void CPythonInvoker::initializeModules(const std::map<std::string, PythonModuleInitialization> &modules)
-{
-  for (std::map<std::string, PythonModuleInitialization>::const_iterator module = modules.begin(); module != modules.end(); ++module)
-  {
-    if (!initializeModule(module->second))
-      CLog::Log(LOGWARNING, "CPythonInvoker(%d, %s): unable to initialize python module \"%s\"", GetId(), m_sourceFile.c_str(), module->first.c_str());
-  }
-}
-
-bool CPythonInvoker::initializeModule(PythonModuleInitialization module)
-{
-  if (module == NULL)
-    return false;
-
-  return module() != nullptr;
-
-}
-
-void CPythonInvoker::getAddonModuleDeps(const ADDON::AddonPtr& addon, std::set<std::string>& paths)
-{
-  ADDON::ADDONDEPS deps = addon->GetDeps();
-  for (ADDON::ADDONDEPS::const_iterator it = deps.begin(); it != deps.end(); ++it)
-  {
-    //Check if dependency is a module addon
-    ADDON::AddonPtr dependency;
-    if (ADDON::CAddonMgr::GetInstance().GetAddon(it->first, dependency, ADDON::ADDON_SCRIPT_MODULE))
-    {
-      std::string path = CSpecialProtocol::TranslatePath(dependency->LibPath());
-      if (paths.find(path) == paths.end())
-      {
-        // add it and its dependencies
-        paths.insert(path);
-        getAddonModuleDeps(dependency, paths);
-      }
-    }
-  }
-}
-
-void CPythonInvoker::addPath(const std::string& path)
-{
-#if defined(TARGET_WINDOWS)
-  if (path.empty())
-    return;
-
-  std::string nativePath(path);
-  if (!g_charsetConverter.utf8ToSystem(nativePath, true))
-  {
-    CLog::Log(LOGERROR, "%s: can't convert UTF-8 path \"%s\" to system encoding", __FUNCTION__, path.c_str());
-    return;
-  }
-  addNativePath(nativePath);
-#else
-  addNativePath(path);
-#endif // defined(TARGET_WINDOWS)
-}
-
-void CPythonInvoker::addNativePath(const std::string& path)
-{
-  if (path.empty())
-    return;
-
-  if (!m_pythonPath.empty())
-    m_pythonPath += PY_PATH_SEP;
-
-  m_pythonPath += path;
-}
diff --git a/xbmc/interfaces/python3/PythonInvoker.h b/xbmc/interfaces/python3/PythonInvoker.h
deleted file mode 100644
index b3e1110fecc9..000000000000
--- a/xbmc/interfaces/python3/PythonInvoker.h
+++ /dev/null
@@ -1,80 +0,0 @@
-#pragma once
-/*
- *      Copyright (C) 2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#include <map>
-#include <string>
-#include <vector>
-
-#include "interfaces/generic/ILanguageInvoker.h"
-#include "threads/CriticalSection.h"
-#include "threads/Event.h"
-
-typedef struct _object PyObject;
-
-class CPythonInvoker : public ILanguageInvoker
-{
-public:
-  explicit CPythonInvoker(ILanguageInvocationHandler *invocationHandler);
-  ~CPythonInvoker() override;
-
-  bool Execute(const std::string &script, const std::vector<std::string> &arguments = std::vector<std::string>()) override;
-  bool IsStopping() const override { return m_stop || ILanguageInvoker::IsStopping(); }
-
-  typedef PyObject* (*PythonModuleInitialization)();
-
-protected:
-  // implementation of ILanguageInvoker
-  bool execute(const std::string &script, const std::vector<std::string> &arguments) override;
-  virtual void executeScript(void *fp, const std::string &script, void *module, void *moduleDict);
-  bool stop(bool abort) override;
-  void onExecutionFailed() override;
-
-  // custom virtual methods
-  virtual std::map<std::string, PythonModuleInitialization> getModules() const = 0;
-  virtual const char* getInitializationScript() const = 0;
-  virtual void onInitialization();
-  // actually a PyObject* but don't wanna draw Python.h include into the header
-  virtual void onPythonModuleInitialization(void* moduleDict);
-  virtual void onDeinitialization();
-
-  virtual void onSuccess() { }
-  virtual void onAbort() { }
-  virtual void onError(const std::string &exceptionType = "", const std::string &exceptionValue = "", const std::string &exceptionTraceback = "");
-
-  std::string m_sourceFile;
-  CCriticalSection m_critical;
-
-private:
-  void initializeModules(const std::map<std::string, PythonModuleInitialization> &modules);
-  bool initializeModule(PythonModuleInitialization module);
-  void addPath(const std::string& path); // add path in UTF-8 encoding
-  void addNativePath(const std::string& path); // add path in system/Python encoding
-  void getAddonModuleDeps(const ADDON::AddonPtr& addon, std::set<std::string>& paths);
-  bool execute(const std::string &script, const std::vector<std::wstring> &arguments);
-  FILE* PyFile_AsFileWithMode(PyObject *py_file, const char *mode);
-
-  std::string m_pythonPath;
-  void *m_threadState;
-  bool m_stop;
-  CEvent m_stoppedEvent;
-
-  static CCriticalSection s_critical;
-};
diff --git a/xbmc/interfaces/python3/PythonSwig.cpp.template b/xbmc/interfaces/python3/PythonSwig.cpp.template
deleted file mode 100644
index 345a31c7638d..000000000000
--- a/xbmc/interfaces/python3/PythonSwig.cpp.template
+++ /dev/null
@@ -1,961 +0,0 @@
-<%
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-%>
-<%
-import Helper
-import SwigTypeParser
-import PythonTools
-
-import groovy.xml.XmlUtil
-import groovy.text.SimpleTemplateEngine
-import java.util.regex.Pattern
-
-/**
- * All of the method nodes and all of the class nodes are used several
- * times over, so they are pulled out once here.
- */
-
-// ---------------------------------------------------------
-// initialize the SwigTypeParser with the module's typetables
-module.findAll( { it.name() == 'typetab' } ).each {  SwigTypeParser.appendTypeTable(it) }
-// ---------------------------------------------------------
-
-// ---------------------------------------------------------
-// Flatten out all of the method/function nodes, whether inside
-//  classes or not, into 'methods'
-List methods = module.depthFirst().findAll { it.name() == 'function' || it.name() == 'constructor' || it.name() == 'destructor' }
-// ---------------------------------------------------------
-
-// ---------------------------------------------------------
-// Flatten out all of the class nodes into 'classes'
-List classes = module.depthFirst().findAll { it.name() == 'class' }
-// ---------------------------------------------------------
-
-// ---------------------------------------------------------
-// Initialize the Helper with the type conversions
-Helper.setup(this,classes,
-    /**
-     * This is meant to contain mini-templates for converting the return type
-     * of the native call to be returned to the python caller.
-     */
-    [ 'void' : 'Py_INCREF(Py_None);\n    ${result} = Py_None;',
-      'long': '${result} = PyLong_FromLong(${api});',
-      'unsigned long': '${result} = PyLong_FromLong(${api});',
-      'bool': '${result} = Py_BuildValue((char*)"b", ${api});',
-      'long long': '${result} = Py_BuildValue((char*)"L", ${api});',
-      'int': '${result} = Py_BuildValue((char*)"i", ${api});',
-      'double': '${result} = PyFloat_FromDouble(${api});',
-      'float': '${result} = Py_BuildValue((char*)"f", ${api});',
-      'std::string' : new File('typemaps/python.string.outtm'),
-      'p.q(const).char' : '${result} = PyUnicode_FromString(${api});',
-      (Pattern.compile('''(p.){0,1}XbmcCommons::Buffer''')) : new File('typemaps/python.buffer.outtm'),
-      (Pattern.compile('''std::shared_ptr<\\(.*\\)>''')) : new File('typemaps/python.smart_ptr.outtm'),
-      (Pattern.compile('''std::unique_ptr<\\(.*\\)>''')) : new File('typemaps/python.smart_ptr.outtm'),
-      (Pattern.compile('''(p.){0,1}std::vector<\\(.*\\)>''')) : new File('typemaps/python.vector.outtm'),
-      (Pattern.compile('''(p.){0,1}Tuple<\\(.*\\)>''')) : new File('typemaps/python.Tuple.outtm'),
-      (Pattern.compile('''(p.){0,1}Alternative<\\(.*\\)>''')) : new File('typemaps/python.Alternative.outtm')
-    ], '${result} = makePythonInstance(${api},true);',
-    /**
-     * This is meant to contain mini-templates for converting the parameter types
-     * of the native call to be converted from the python types provided by the caller.
-     *
-     * Note: if the type can be handled by PythonTools.ltypeToFormatChar then it wont
-     * appear here as it gets converted directly within the PyArg_ParseTupleAndKeywords
-     * call.
-     */
-    [
-      'std::string' : 'if (${slarg}) PyXBMCGetUnicodeString(${api},${slarg},false,"${api}","${method.@name}");',
-      (Pattern.compile('''(p.){0,1}std::vector<\\(.*\\)>''')) : new File('typemaps/python.vector.intm'),
-      (Pattern.compile('''(p.){0,1}Tuple(3){0,1}<\\(.*\\)>''')) : new File('typemaps/python.Tuple.intm'),
-      (Pattern.compile('''(p.){0,1}Alternative<\\(.*\\)>''')) : new File('typemaps/python.Alternative.intm'),
-      (Pattern.compile('''(r.){0,1}XbmcCommons::Buffer''')) : new File('typemaps/python.buffer.intm'),
-      (Pattern.compile('''(p.){0,1}std::map<\\(.*\\)>''')) : new File('typemaps/python.map.intm'),
-      (Pattern.compile('''(r.){0,1}XBMCAddon::Dictionary<\\(.*\\)>''')) : new File('typemaps/python.dict.intm'),
-      (Pattern.compile('''p.void''')) : '${api} = (void*)${slarg};',
-      'bool' : '${api} = (PyLong_AsLong(${slarg}) == 0L ? false : true);',
-      'long' : '${api} = PyLong_AsLong(${slarg});',
-      'unsigned long' : '${api} = PyLong_AsUnsignedLong(${slarg});',
-      'long long' : '${api} = PyLong_AsLongLong(${slarg});',
-      'unsigned long long' : '${api} = PyLong_AsUnsignedLongLong(${slarg});',
-      'int' : '${api} = (int)PyLong_AsLong(${slarg});',
-      'double' : '${api} = PyFloat_AsDouble(${slarg});',
-      'float' : '${api} = (float)PyFloat_AsDouble(${slarg});',
-      'XBMCAddon::StringOrInt' : 'if (${slarg}) PyXBMCGetUnicodeString(${api},${slarg},PyLong_Check(${slarg}) || PyLong_Check(${slarg}) || PyFloat_Check(${slarg}),"${api}","${method.@name}");'
-    ], '${api} = (${swigTypeParser.SwigType_str(ltype)})retrieveApiInstance(${slarg},"${ltype}","${helper.findNamespace(method)}","${helper.callingName(method)}");')
-// ---------------------------------------------------------
-
-/*******************************************************************************/
-/**
- * The doMethod will actually write out the CPython method call for
- *  the method/function represented by the provided Node ('method').
- */
-void doMethod(Node method, MethodType methodType)
-{
-  boolean isOperator = method.@name.startsWith("operator ")
-  boolean doAsMappingIndex = false
-  boolean doAsCallable = false
-
-  if (isOperator)
-  {
-    if("[]" == method.@name.substring(9))
-      doAsMappingIndex = true
-    else if("()" == method.@name.substring(9))
-      doAsCallable = true
-    else
-      return;
-  }
-
-  boolean constructor = methodType == MethodType.constructor
-
-  // if we're a constructor, but we're private, then we're outta here
-  if (constructor && method.@access != null && method.@access != "public")
-    return
-
-  boolean destructor = methodType == MethodType.destructor
-  List params = method?.parm
-  int numParams = params?.size()
-  String clazz = Helper.findFullClassName(method)
-  String returns = constructor ? 'p.' + clazz : (destructor ? 'void' : Helper.getReturnSwigType(method))
-  Node classnode = Helper.findClassNode(method)
-  String classNameAsVariable = clazz == null ? null : PythonTools.getClassNameAsVariable(classnode)
-  boolean useKeywordParsing = !('true' == classnode?.@feature_python_nokwds || 'true' == method?.@feature_python_nokwds)
-
-  // do the docs
-  if (!constructor && !destructor)
-  {
-    if (Helper.hasDoc(method))
-    {
-%>
-  PyDoc_STRVAR(${PythonTools.getPyMethodName(method,methodType)}__doc__,
-               ${PythonTools.makeDocString(method.doc[0])});
-<%  }
-  }
-%>
-  static <% if(methodType == MethodType.destructor) { %>void<% } else { %>PyObject*<% } %> ${module.@name}_${PythonTools.getPyMethodName(method,methodType)} (<%= ((clazz == null) ? "PyObject" :
-                   (constructor ? "PyTypeObject" : 'PyHolder')) %>* ${constructor ? 'pytype' : 'self'} <%
-                   if (doAsMappingIndex) { %>, PyObject* py${params[0].@name}<% }
-                   else if (methodType != MethodType.destructor) { %> , PyObject *args, PyObject *kwds <%} %> )
-  {
-    XBMC_TRACE;
-<%  if (numParams > 0)
-    {
-      if (useKeywordParsing && !doAsMappingIndex)
-      { %>
-    static const char *keywords[] = {<%
-          params.each { %>
-          "${it.@name}",<% } %>
-          NULL};
-<%    }
-      params.each {
-%>
-    ${SwigTypeParser.SwigType_str(SwigTypeParser.convertTypeToLTypeForParam(it.@type))} ${it.@name} ${it.@value != null ? ' = ' + it.@value : SwigTypeParser.SwigType_ispointer(it.@type) ? ' = nullptr' :  ''};<%
-        if (!PythonTools.parameterCanBeUsedDirectly(it) && !doAsMappingIndex)
-        { %>
-    PyObject* py${it.@name} = NULL;<%
-        }
-     }
-    if (!doAsMappingIndex)
-    { %>
-    if (!${useKeywordParsing ? 'PyArg_ParseTupleAndKeywords' : 'PyArg_ParseTuple'}(
-       args,
-       <% if (useKeywordParsing) { %>kwds,<% } %>
-       (char*)"<%= PythonTools.makeFormatStringFromParameters(method) %>",
-       <% if (useKeywordParsing) { %>(char**)keywords,<% } %><%    params.eachWithIndex { param,i -> %>
-         &${PythonTools.parameterCanBeUsedDirectly(param) ? '' : 'py'}${param.@name}${i < params.size() - 1 ? "," : ""}<% } %>
-       ))
-    {
-      return NULL;
-    }
-
-<%  }
-    }
-    // now actually invoke the method
-    if (returns != "void") { %>    ${SwigTypeParser.SwigType_lstr(returns)} apiResult;<%   }
-%>
-    try
-    {
-<%
-    // now do the input conversion if any are necessary
-    params.findAll({ !PythonTools.parameterCanBeUsedDirectly(it) || doAsMappingIndex }).each { %>      ${Helper.getInConversion(it.@type, it.@name, 'py' + it.@name, method)} <% println() }
-%>
-<%
-    // check to see if this method is a call to a virtual function on a director class.
-    boolean isDirectorCall = Helper.isDirector(method)
-    if (isDirectorCall)
-    {
-%>      // This is a director call coming from python so it explicitly calls the base class method.
-<%
-    }
-    // now do the method call itself
-    if (!destructor) {
-    if (constructor || !clazz) {  %>      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());<% println() }
-%>      <%
-    if (returns != "void") { %>apiResult = (${SwigTypeParser.SwigType_lstr(returns)})<% }
-    if (clazz && !constructor) {
-      %>((${clazz}*)retrieveApiInstance((PyObject*)self,&Ty${classNameAsVariable}_Type,"${Helper.callingName(method)}","${clazz}"))-> <%
-    }
-    if (constructor && classnode.@feature_director) {
-    %>(&(Ty${classNameAsVariable}_Type.pythonType) != pytype) ? new ${classNameAsVariable}_Director(<% params.eachWithIndex { param, i -> %> ${param.@name}${i < params.size() - 1 ? "," : ""} <% } %>) : <% }
-
-    // Here is the actual call ... if this is a Director we need to do an upCall (from Python)
-    if (isDirectorCall){ %>${clazz}::<% }
-    %>${Helper.callingName(method)}( <% params.eachWithIndex { param, i -> %> ${param.@name}${i < params.size() - 1 ? "," : ""} <% } %> );
-<%
-      if (constructor) {  %>      prepareForReturn(apiResult);<% }
-    } // close the 'if method is not a destructor'
-    else {  // it is a destructor
-%>
-      ${clazz}* theObj = (${clazz}*)retrieveApiInstance((PyObject*)self,&Ty${classNameAsVariable}_Type,"~${Helper.callingName(method)}","${clazz}");
-      cleanForDealloc(theObj);
-<%
-    }
-%>
-    }
-    catch (const XBMCAddon::WrongTypeException& e)
-    {
-      CLog::Log(LOGERROR,"EXCEPTION: %s",e.GetMessage());
-      PyErr_SetString(PyExc_TypeError, e.GetMessage()); <%
-      if (!destructor) {  %>
-      return NULL; <%
-      } %>
-    }
-    catch (const XbmcCommons::Exception& e)
-    {
-      CLog::Log(LOGERROR,"EXCEPTION: %s",e.GetMessage());
-      PyErr_SetString(PyExc_RuntimeError, e.GetMessage()); <%
-      if (!destructor) {  %>
-      return NULL; <%
-      } %>
-    }
-    catch (...)
-    {
-      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"${Helper.callingName(method)}\"");
-      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"${Helper.callingName(method)}\""); <%
-      if (!destructor) {  %>
-      return NULL; <%
-      } %>
-    }
-<%
-    if (!destructor) { %>
-    PyObject* result = Py_None;
-
-    // transform the result
-<%
-    if (constructor) {
-      %>    result = makePythonInstance(apiResult,pytype,false);<%
-    }
-    else {
-%>    ${Helper.getOutConversion(returns,'result',method)}<%
-    }
-    if (constructor && method.@feature_director) { %>
-    if (&(Ty${classNameAsVariable}_Type.pythonType) != pytype)
-      ((${classNameAsVariable}_Director*)apiResult)->setPyObjectForDirector(result);<%
-    }
- %>
-
-    return result; <% }
-    else { %>
-    (((PyObject*)(self))->ob_type)->tp_free((PyObject*)self);
-    <%
-    }
-    %>
-  } <%
-}
-/*******************************************************************************/
-
-/**
- * This method writes out the instance of a TypeInfo (which includes
- * The PyTypeObject as a member) for the class node provided.
- *
- * If classNameAsVariable is not null then the class name as a
- * variable will be appended to it.
- */
-void doClassTypeInfo(Node clazz, List classNameAsVariables = null)
-{
-  String classNameAsVariable = PythonTools.getClassNameAsVariable(clazz)
-  String fullClassName = Helper.findFullClassName(clazz)
-  classNameAsVariables?.add(classNameAsVariable)
-%>
-  //=========================================================================
-  // These variables will hold the Python Type information for ${fullClassName}
-  TypeInfo Ty${classNameAsVariable}_Type(typeid(${fullClassName}));<%
-%>
-  //=========================================================================
-<%
-}
-
-/**
- * This method will take the name of an API class from another module and
- *  create an external reference to its TypeInfo instance.
- */
-void doExternClassTypeInfo(String knownType)
-{
-  String classNameAsVariable = knownType.replaceAll('::','_')
-%>
-  //=========================================================================
-  // These variables define the type ${knownType} from another module
-  extern TypeInfo Ty${classNameAsVariable}_Type;
-  //=========================================================================
-<%
-}
-
-/*******************************************************************************/
-/**
- * This method takes the class node and outputs all of the python meta-data
- *  and class oddities (like comparators, as_mapping, etc.). These include:
- *
- * 1) comparator *_cmp python method as long as there's an operator==, an
- *    operator>, AND an operator<.
- * 2) it will create a python "as_mapping" method as long as there's both
- *    an operator[], AND a .size() method on the class.
- * 3) it will handle the explicitly defined rich compare (_rcmp) if the
- *    feature is included in the .i file using %feature("python:rcmp")
- * 4) The array of PyMethodDefs for the class definition
- * 5) It will handle public fields as if the were python properties by:
- *    a) Creating a get/set_member if there are read/write properties.
- *    b) Creating only a get if there are only read-only properties.
- * 6) It will write the init[Classname] method for the class which will
- *    initialize the TypeInfo and PyTypeObject structs.
- *
- * If initTypeCalls is not null then the method name for the generated init
- *  method (see #6 above) will be appended to it.
- */
-void doClassMethodInfo(Node clazz, List initTypeCalls)
-{
-  String classNameAsVariable = PythonTools.getClassNameAsVariable(clazz)
-  String fullClassName = Helper.findFullClassName(clazz)
-  String initTypeCall = "initPy${classNameAsVariable}_Type"
-  initTypeCalls?.add(initTypeCall)
-
-  // see if we have any valid (or invalid) operators
-  boolean doComparator = false
-  boolean doAsMapping = false
-  boolean hasEquivalenceOp = false
-  boolean hasLtOp = false
-  boolean hasGtOp = false
-  Node indexOp = null
-  Node callableOp = null
-  Node sizeNode = null
-
-  List normalMethods = clazz.function.findAll { !it.@name.startsWith("operator ") }
-  List operators =  clazz.function.findAll { it.@name.startsWith("operator ") }
-  List properties = clazz.variable.findAll { it.@access != null && it.@access == "public" }
-  List properties_set = properties.findAll { it.@feature_immutable == null || it.@feature_immutable == 0 }
-
-  operators.each {
-    // we have an operator. The only one we can handle is ==
-    if (it.@name.substring(9).startsWith("=="))
-      hasEquivalenceOp = true
-    else if (it.@name.substring(9) == "<")
-      hasLtOp = true
-    else if (it.@name.substring(9) == ">")
-      hasGtOp = true
-    else if (it.@name.substring(9) == "[]")
-      indexOp = it
-    else if (it.@name.substring(9) == "()")
-      callableOp = it
-    else
-      System.err.println ("Warning: class ${fullClassName} has an operator \"${it.@name}\" that is being ignored.");
-  }
-
-  if (hasGtOp || hasLtOp || hasEquivalenceOp)
-  {
-    if (!(hasLtOp && hasGtOp && hasEquivalenceOp))
-      System.err.println ("Warning: class ${fullClassName} has an inconsistent operator set. To get a comparator you must implement all 3 operators >,<,==.")
-    else
-      doComparator = true
-  }
-
-  if (indexOp)
-  {
-    sizeNode =  clazz.function.find { it.@name == "size" }
-    if (sizeNode)
-      doAsMapping = true
-    else
-      System.err.println ("Warning: class ${fullClassName} has an inconsistent operator set. To get a as_mapping you must implement 'size' as well as operator[]")
-  }
-
-  if (doComparator){
-%>
-  static int ${module.@name}_${classNameAsVariable}_cmp(PyObject* obj1, PyObject* obj2)
-  {
-    return PythonCompare<${fullClassName}>::compare(obj1,obj2,"p.${fullClassName}","${Helper.findNamespace(clazz)}","compare on ${fullClassName}");
-  }
-<%
-  }
-
-  if (doAsMapping)
-  {
-%>
-  static Py_ssize_t ${module.@name}_${classNameAsVariable}_size_(PyObject* self)
-  {
-    return (Py_ssize_t)((${fullClassName}*)retrieveApiInstance(self,&Ty${classNameAsVariable}_Type,"${Helper.callingName(indexOp)}","${fullClassName}"))-> size();
-  }
-
-  //=========================================================================
-  // tp_as_mapping struct for ${fullClassName}
-  //=========================================================================
-  PyMappingMethods ${module.@name}_${classNameAsVariable}_as_mapping = {
-    ${module.@name}_${classNameAsVariable}_size_,    /* inquiry mp_length;                  __len__ */
-    (PyCFunction)${module.@name}_${PythonTools.getPyMethodName(indexOp,MethodType.method)},   /* binaryfunc mp_subscript             __getitem__ */
-    0,                  /* objargproc mp_ass_subscript;     __setitem__ */
-  };
-<%
-  }
-
-  if (clazz.@feature_python_rcmp)
-  { %>
-  static PyObject* ${module.@name}_${classNameAsVariable}_rcmp(PyObject* obj1, PyObject *obj2, int method)
-  ${Helper.unescape(clazz.@feature_python_rcmp)}
-<%
-  }
-%>
-  //=========================================================================
-  // This section contains the initialization for the
-  // Python extension for the Api class ${fullClassName}
-  //=========================================================================
-  // All of the methods on this class
-  static PyMethodDef ${classNameAsVariable}_methods[] = { <%
-    normalMethods.each {  %>
-    {(char*)"${it.@sym_name}", (PyCFunction)${module.@name}_${PythonTools.getPyMethodName(it,MethodType.method)}, METH_VARARGS|METH_KEYWORDS, ${Helper.hasDoc(it) ? PythonTools.getPyMethodName(it,MethodType.method) + '__doc__' : 'NULL'} }, <% }
-
-    // now do all of the explicit feature:python:method's that may be in this class
-    List tmpl = []
-    tmpl.addAll(clazz.attributes().keySet())
-    List newMethodKeys = tmpl.findAll { it.startsWith('feature_python_method_') }
-    newMethodKeys.each { key ->
-      String featureEntry = clazz.attribute(key)
-      String methodName = key.substring('feature_python_method_'.length()) %>
-    {(char*)"${methodName}", (PyCFunction)${module.@name}_${PythonTools.getClassNameAsVariable(clazz)}_${methodName}, METH_VARARGS|METH_KEYWORDS, NULL},
-<%
-    }
-%>
-    {NULL, NULL, 0, NULL}
-  };
-
-<%
-  if (properties.size() > 0) {
-%>  static PyObject* ${classNameAsVariable}_getMember(PyHolder *self, void *name)
-  {
-    if (self == NULL)
-      return NULL;
-<%
-    String clazzName = Helper.findFullClassName(properties[0])
-%>
-    try
-    {
-      ${clazzName}* theObj = (${clazzName}*)retrieveApiInstance((PyObject*)self, &Ty${classNameAsVariable}_Type, "${classNameAsVariable}_getMember()", "${clazzName}");
-
-      PyObject* result = NULL;
-   <%
-  properties.each {
-     String returns = Helper.getPropertyReturnSwigType(it);
-%>   if (strcmp((char*)name, "${it.@sym_name}") == 0)
-      {
-        ${SwigTypeParser.SwigType_lstr(returns)} apiResult = (${SwigTypeParser.SwigType_lstr(returns)})theObj->${it.@sym_name};
-        ${Helper.getOutConversion(returns, 'result', it)}
-      }
-      else<%
-  } %>
-      {
-        Py_INCREF(Py_None);
-        return Py_None;
-      }
-
-      return result;
-    }
-    catch (const XBMCAddon::WrongTypeException& e)
-    {
-      CLog::Log(LOGERROR,"EXCEPTION: %s",e.GetMessage());
-      PyErr_SetString(PyExc_TypeError, e.GetMessage());
-      return NULL;
-    }
-    catch (const XbmcCommons::Exception& e)
-    {
-      CLog::Log(LOGERROR,"EXCEPTION: %s",e.GetMessage());
-      PyErr_SetString(PyExc_RuntimeError, e.GetMessage());
-      return NULL;
-    }
-    catch (...)
-    {
-      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"${classNameAsVariable}_getMember()\"");
-      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"${classNameAsVariable}_getMember()\"");
-      return NULL;
-    }
-
-    return NULL;
-  }
-
-<%
-    if (properties_set.size() > 0) {
-%>  int ${classNameAsVariable}_setMember(PyHolder *self, PyObject *value, void *name)
-  {
-    if (self == NULL)
-      return -1;
-
-    ${clazzName}* theObj = NULL;
-    try
-    {
-      theObj = (${clazzName}*)retrieveApiInstance((PyObject*)self, &Ty${classNameAsVariable}_Type, "${classNameAsVariable}_getMember()", "${clazzName}");
-    }
-    catch (const XBMCAddon::WrongTypeException& e)
-    {
-      CLog::Log(LOGERROR,"EXCEPTION: %s",e.GetMessage());
-      PyErr_SetString(PyExc_TypeError, e.GetMessage());
-      return -1;
-    }
-    catch (const XbmcCommons::Exception& e)
-    {
-      CLog::Log(LOGERROR,"EXCEPTION: %s",e.GetMessage());
-      PyErr_SetString(PyExc_RuntimeError, e.GetMessage());
-      return -1;
-    }
-    catch (...)
-    {
-      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"${classNameAsVariable}_getMember()\"");
-      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"${classNameAsVariable}_getMember()\"");
-      return -1;
-    }
-
-<%
-  properties_set.each {
-     String returns = Helper.getPropertyReturnSwigType(it);
-%>   if (strcmp((char*)name, "${it.@sym_name}") == 0)
-      {
-        ${SwigTypeParser.SwigType_lstr(returns)} tmp;
-        ${Helper.getInConversion(returns, 'tmp', 'value', it)}
-        if (PyErr_Occurred())
-          throw PythonBindings::PythonToCppException();
-
-        theObj->${it.@sym_name} = tmp;
-      }
-      else<%
-  } %>
-        return -1;
-
-    return 0;
-  } <%
-    }
-%>
-
-  // All of the methods on this class
-  static PyGetSetDef ${classNameAsVariable}_getsets[] = { <%
-    properties.each {  %>
-    {(char*)"${it.@sym_name}", (getter)${classNameAsVariable}_getMember, ${(it.@feature_immutable == null || it.@feature_immutable == 0) ? '(setter)' + classNameAsVariable + '_setMember' : 'NULL'}, (char*)${Helper.hasDoc(it) ? PythonTools.makeDocString(it.doc[0]) : 'NULL'}, (char*)"${it.@sym_name}" }, <% }
-%>
-    {NULL}
-  };
-<%
-  }
-
-  if ((clazz.@feature_iterator && clazz.@feature_iterator != '') ||
-      (clazz.@feature_iterable && clazz.@feature_iterable != '')) { %>
-  static PyObject* ${module.@name}_${classNameAsVariable}_iter(PyObject* self)
-  { <%
-    if (clazz.@feature_iterator) { %>
-    return self; <%
-    }
-    else { %>
-    PyObject* result = NULL;
-    try
-    {
-      ${clazz.@feature_iterable}* apiResult = ((${fullClassName}*)retrieveApiInstance(self,&Ty${classNameAsVariable}_Type,"${module.@name}_${classNameAsVariable}_iternext","${fullClassName}"))->begin();
-
-      ${Helper.getOutConversion('p.' + clazz.@feature_iterable,'result',clazz)}
-    }
-    catch (const XBMCAddon::WrongTypeException& e)
-    {
-      CLog::Log(LOGERROR,"EXCEPTION: %s",e.GetMessage());
-      PyErr_SetString(PyExc_TypeError, e.GetMessage());
-      return NULL;
-    }
-    catch (const XbmcCommons::Exception& e)
-    {
-      CLog::Log(LOGERROR,"EXCEPTION: %s",e.GetMessage());
-      PyErr_SetString(PyExc_RuntimeError, e.GetMessage());
-      return NULL;
-    }
-    catch (...)
-    {
-      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"${module.@name}_${classNameAsVariable}_iternext\"");
-      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"${module.@name}_${classNameAsVariable}_iternext\"");
-      return NULL;
-    }
-
-    return result; <%
-    } %>
-  }
-<%
-
-    if (clazz.@feature_iterator) { %>
-  static PyObject* ${module.@name}_${classNameAsVariable}_iternext(PyObject* self)
-  {
-    PyObject* result = NULL;
-    try
-    {
-      ${fullClassName}* iter = (${fullClassName}*)retrieveApiInstance(self,&Ty${classNameAsVariable}_Type,"${module.@name}_${classNameAsVariable}_iternext","${fullClassName}");
-
-      // check if we have reached the end
-      if (!iter->end())
-      {
-        ++(*iter);
-
-        ${clazz.@feature_iterator} apiResult = **iter;
-        ${Helper.getOutConversion(clazz.@feature_iterator,'result',clazz)}
-      }
-    }
-    catch (const XBMCAddon::WrongTypeException& e)
-    {
-      CLog::Log(LOGERROR,"EXCEPTION: %s",e.GetMessage());
-      PyErr_SetString(PyExc_TypeError, e.GetMessage());
-      return NULL;
-    }
-    catch (const XbmcCommons::Exception& e)
-    {
-      CLog::Log(LOGERROR,"EXCEPTION: %s",e.GetMessage());
-      PyErr_SetString(PyExc_RuntimeError, e.GetMessage());
-      return NULL;
-    }
-    catch (...)
-    {
-      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"${module.@name}_${classNameAsVariable}_iternext\"");
-      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"${module.@name}_${classNameAsVariable}_iternext\"");
-      return NULL;
-    }
-
-    return result;
-  }
-<%
-    }
-  }
-%>
-
-  // This method initializes the above mentioned Python Type structure
-  static void ${initTypeCall}()
-  {
-<%
-    if (Helper.hasDoc(clazz))
-    {
-%>
-    PyDoc_STRVAR(${classNameAsVariable}__doc__,
-                 ${PythonTools.makeDocString(clazz.doc[0])}
-                );
-<%  } %>
-
-    PyTypeObject& pythonType = Ty${classNameAsVariable}_Type.pythonType;
-    pythonType.tp_name = (char*)"${module.@name}.${clazz.@sym_name}";
-    pythonType.tp_basicsize = sizeof(PyHolder);
-    pythonType.tp_dealloc = (destructor)${module.@name}_${classNameAsVariable}_Dealloc; <%
-
-  if (clazz.@feature_python_rcmp) { %>
-    pythonType.tp_richcompare=(richcmpfunc)${module.@name}_${classNameAsVariable}_rcmp;<%
-  } %>
-
-    pythonType.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE;
-
-    pythonType.tp_doc = ${Helper.hasDoc(clazz) ? (classNameAsVariable + '__doc__') : 'NULL' };
-    pythonType.tp_methods = ${classNameAsVariable}_methods; <%
-  if (properties.size() > 0) { %>
-    pythonType.tp_getset = ${classNameAsVariable}_getsets;
-<%
-  }
-  if (callableOp) { %>
-    pythonType.tp_call = (ternaryfunc)${module.@name}_${PythonTools.getPyMethodName(callableOp,MethodType.method)};
-<%
-  }
-  if (doAsMapping) { %>
-    pythonType.tp_as_mapping = &${module.@name}_${classNameAsVariable}_as_mapping;
-<%
-  }
-
-  if (clazz.@feature_iterator) { %>
-    pythonType.tp_iter = (getiterfunc)${module.@name}_${classNameAsVariable}_iter;
-    pythonType.tp_iternext = (iternextfunc)${module.@name}_${classNameAsVariable}_iternext;
-<%
-  }
-  else if (clazz.@feature_iterable && clazz.@feature_iterable != '') { %>
-    pythonType.tp_iter = (getiterfunc)${module.@name}_${classNameAsVariable}_iter;
-<%
-  }
-
-  Node baseclass = PythonTools.findValidBaseClass(clazz, module)
-%>
-
-    pythonType.tp_base = ${baseclass ? ('&(Ty' + PythonTools.getClassNameAsVariable(baseclass) + '_Type.pythonType)') : "NULL"};
-    pythonType.tp_new = <% Helper.hasHiddenConstructor(clazz) ? print('NULL') : print("${module.@name}_${classNameAsVariable}_New") %>;
-
-    Ty${classNameAsVariable}_Type.swigType="p.${fullClassName}";<%
-  if (baseclass) { %>
-    Ty${classNameAsVariable}_Type.parentType=&Ty${PythonTools.getClassNameAsVariable(baseclass)}_Type;
-<%}
-
-  if (!Helper.hasHiddenConstructor(clazz)) { %>
-    registerAddonClassTypeInformation(&Ty${classNameAsVariable}_Type);
-<%} %>
-  }
-  //=========================================================================
-<%
-}
-/*******************************************************************************/
-
-
-List getAllVirtualMethods(Node clazz)
-{
-  List ret = []
-  ret.addAll(clazz.findAll({ it.name() == 'function' && it.@storage && it.@storage == 'virtual' }))
-  if (clazz.baselist) {
-    if (clazz.baselist[0].base) clazz.baselist[0].base.each {
-        Node baseclassnode = Helper.findClassNodeByName(module,it.@name,clazz)
-        if (baseclassnode && baseclassnode.@feature_director) ret.addAll(getAllVirtualMethods(baseclassnode))
-      }
-  }
-  return ret;
-}
-
-%>
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with Kodi; see the file COPYING.  If not, write to
- *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
- *  http://www.gnu.org/copyleft/gpl.html
- *
- */
-
-// ************************************************************************
-// This file was generated by xbmc compile process. DO NOT EDIT!!
-//  It was created by running the code generator on the spec file for
-//  the module "${module.@name}" on the template file PythonSwig.template.cpp
-// ************************************************************************
-
-<%
-Helper.getInsertNodes(module, 'begin').each { %>${Helper.unescape(it)}<% }
-%>
-
-#include <Python.h>
-#include <string>
-#include "interfaces/python/LanguageHook.h"
-#include "interfaces/python/swig.h"
-#include "interfaces/python/PyContext.h"
-
-<%
-Helper.getInsertNodes(module, 'header').each { %>${Helper.unescape(it)}<% }
-%>
-
-namespace PythonBindings
-{
-<%
-  // initTypeCalls is the
-  List initTypeCalls = []
-  List classNameAsVariables = []
-
-  classes.each { clazz -> doClassTypeInfo(clazz, classNameAsVariables) }
-
-  // make sure known api types are declared as externs
-
-  // first, find all of the declared known api types
-  Set<String> knownApiTypes = new HashSet<String>()
-  module.depthFirst().each
-  {
-    String attr = it.attribute('feature_knownapitypes')
-    if (attr != null)
-    {
-      attr.trim().split(',').each { knownApiTypes.add(it) }
-    }
-  }
-
-  // now declare an extern for each one
-  knownApiTypes.each { doExternClassTypeInfo(it) }
-
-%>
-
-<%
-//=========================================================================
-// Do the directors. For every class that can be extended in python, we
-// need to create a Director instance with bridging calls. This chunk of
-// code will generate those classes.
-  classes.findAll({ it.@feature_director != null }).each { clazz ->
-    // find the constructor for this class
-    constructor = clazz.constructor[0]
-%>
-  //=========================================================================
-  // This class is the Director for ${Helper.findFullClassName(clazz)}.
-  // It provides the "reverse bridge" from C++ to Python to support
-  // cross-language polymorphism.
-  //=========================================================================
-  class ${PythonTools.getClassNameAsVariable(clazz)}_Director : public Director, public ${clazz.@name}
-  {
-    public:
-<%
-      if (constructor)
-      {%>
-      inline ${PythonTools.getClassNameAsVariable(clazz)}_Director(<%
-        List params = constructor?.parm
-        params.eachWithIndex { param, i -> %>${SwigTypeParser.SwigType_str(param.@type)} ${param.@name}${i < params.size() - 1 ? "," : ""} <% }
-        %>) : ${Helper.findFullClassName(constructor)}(<%
-        params.eachWithIndex { param, i -> %> ${param.@name}${i < params.size() - 1 ? "," : ""} <% } %>) { } <%
-      }
-%>
-<%
-      getAllVirtualMethods(clazz).each
-      { %>
-      virtual ${SwigTypeParser.SwigType_str(Helper.getReturnSwigType(it))} ${Helper.callingName(it)}( <%
-    List params = it?.parm
-    String paramFormatStr = ''
-    params.each { paramFormatStr += 'O' }
-    params.eachWithIndex { param, i -> %> ${SwigTypeParser.SwigType_str(param.@type)} ${param.@name}${i < params.size() - 1 ? "," : ""} <% }
-    %> )
-      { <%
-        params.each
-        { param ->
-          %>
-        PyObject* py${param.@name} = NULL;
-        ${Helper.getOutConversion(param.@type,'result',it,['result' : 'py' + param.@name, 'api' : param.@name])}<%
-        }
-%>
-        XBMCAddon::Python::PyContext pyContext;
-        PyObject_CallMethod(self,(char*)"${Helper.callingName(it)}",(char*)"(${paramFormatStr})"<%
-          params.each {
-             %>, py${it.@name} <%
-          }
-        %>);
-        if (PyErr_Occurred())
-          throw PythonBindings::PythonToCppException();
-      }
-<%    }
-
-%>
-  };
-<%
-  }
-//=========================================================================
-
-  // types used as method parameter or return values need to be declared
-  // as extern if they are unknown types.
-  methods.each { if (it.name() != 'destructor') { doMethod(it, (it.name() == 'constructor' ? MethodType.constructor : MethodType.method)); println(); } }
-  classes.each { clazz -> doMethod(clazz, MethodType.destructor) }
-
-  // now find any methods that have been added explicitly
-  classes.each { node ->
-    List tmpl = []
-    tmpl.addAll(node.attributes().keySet())
-    List newMethodKeys = tmpl.findAll { it.startsWith('feature_python_method_') }
-    newMethodKeys.each { key ->
-      String featureEntry = node.attribute(key)
-      String methodName = key.substring('feature_python_method_'.length()) %>
-  static PyObject* ${module.@name}_${PythonTools.getClassNameAsVariable(node)}_${methodName}(PyObject* self, PyObject *args, PyObject *kwds)
-  ${Helper.unescape(featureEntry)}
-<%
-    }
-  }
-
-  classes.each { clazz -> doClassMethodInfo(clazz, initTypeCalls) }
-
-%>
-
-  static PyMethodDef ${module.@name}_methods[] = { <%
-    module.depthFirst().findAll({ it.name() == 'function' && Helper.parents(it, { Node lnode -> lnode.name() == 'class'}).size() == 0 }).each {  %>
-    {(char*)"${it.@sym_name}", (PyCFunction)${module.@name}_${PythonTools.getPyMethodName(it,MethodType.method)}, METH_VARARGS|METH_KEYWORDS, ${Helper.hasDoc(it) ? PythonTools.getPyMethodName(it,MethodType.method) + '__doc__' : 'NULL'} }, <% }
-%>
-    {NULL, NULL, 0, NULL}
-  };
-
-  // This is the call that will call all of the other initializes
-  //  for all of the classes in this module
-  static void initTypes()
-  {
-    static bool typesAlreadyInitialized = false;
-    if (!typesAlreadyInitialized)
-    {
-      typesAlreadyInitialized = true;
-<%
-      initTypeCalls.each { %>
-      ${it}();<%
-      }
-
-      classNameAsVariables.each { %>
-      if (PyType_Ready(&(Ty${it}_Type.pythonType)) < 0)
-        return;<%
-      }%>
-    }
-  }
-
-  static struct PyModuleDef createModule
-  {
-      PyModuleDef_HEAD_INIT,
-      (char*)"${module.@name}",
-      "",
-      -1,
-      ${module.@name}_methods
-  };
-
-  PyObject *PyInit_Module_${module.@name}()
-  {
-    initTypes();
-
-    // init general ${module.@name} modules
-    PyObject* module;
-
-<% classNameAsVariables.each { %>
-    Py_INCREF(&(Ty${it}_Type.pythonType));<%
-   }%>
-
-    module = PyModule_Create(&createModule);
-    if (module == NULL) return NULL;
-
-<% classes.each { clazz -> %>
-    PyModule_AddObject(module, (char*)"${clazz.@sym_name}", (PyObject*)(&(Ty${PythonTools.getClassNameAsVariable(clazz)}_Type.pythonType)));<%
-   }%>
-
-   // constants
-   PyModule_AddStringConstant(module, (char*)"__author__", (char*)"Team Kodi <http://kodi.tv>");
-   PyModule_AddStringConstant(module, (char*)"__date__", (char*)"${new Date().toString()}");
-   PyModule_AddStringConstant(module, (char*)"__version__", (char*)"2.25.0");
-   PyModule_AddStringConstant(module, (char*)"__credits__", (char*)"Team Kodi");
-   PyModule_AddStringConstant(module, (char*)"__platform__", (char*)"ALL");
-
-   // need to handle constants
-<% module.depthFirst().findAll( { it.name() == 'constant'} ).each {
-     String pyCall =
-        (it.@type == 'int' || it.@type == 'long' || it.@type == 'unsigned int' || it.@type == 'unsigned long' || it.@type == 'bool') ?
-        'PyModule_AddIntConstant' : 'PyModule_AddStringConstant' %>
-   ${pyCall}(module,"${it.@sym_name}",${it.@value}); <%
-  } %>
-  return module;
-  }
-
-} // end PythonBindings namespace for python type definitions
-
-<%
-Helper.getInsertNodes(module, 'footer').each { %>${Helper.unescape(it)}<% }
-%>
diff --git a/xbmc/interfaces/python3/PythonTools.groovy b/xbmc/interfaces/python3/PythonTools.groovy
deleted file mode 100644
index 0d1bd70654d1..000000000000
--- a/xbmc/interfaces/python3/PythonTools.groovy
+++ /dev/null
@@ -1,152 +0,0 @@
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-import Helper
-import SwigTypeParser
-
-public class PythonTools
-{
-   /**
-    * This array defines a mapping of the api spec type to the python parse format character.
-    *  By default, if a lookup here results in 'null' then the format char is 'O'
-    */
-   private static Map ltypeToFormatChar = [
-      'p.char':"s", bool:"b",
-      int:"i", 'unsigned int' : 'I',
-      long:"l", 'unsigned long' : 'k',
-      'double':"d", 'float':"f",
-      'long long' : "L"
-   ]
-
-   /**
-    * if the parameter can be directly read from python then its type should be in the ltypeToFormatChar
-    *  otherwise we need an intermediate pyobject
-    */
-   public static boolean parameterCanBeUsedDirectly(Node param) { return ltypeToFormatChar[SwigTypeParser.convertTypeToLTypeForParam(param.@type)] != null }
-
-   /**
-    * This method will take the parameter list from the method node passed
-    * and will convert it to a Python argument string for PyArg_ParseTupleAndKeywords
-    */
-   public static String makeFormatStringFromParameters(Node method)
-   {
-      if (!method)
-        return ''
-      List params = method.parm
-      String format = ""
-      boolean previousDefaulted = false
-      params.eachWithIndex { param, i ->
-         String defaultValue = param.@value
-         String paramtype = SwigTypeParser.convertTypeToLTypeForParam(param.@type)
-         String curFormat = ltypeToFormatChar[paramtype];
-         if (curFormat == null) // then we will assume it's an object
-            curFormat = "O";
-
-         if (defaultValue != null && !previousDefaulted)
-         {
-            format +="|"
-            previousDefaulted = true
-         }
-         format += curFormat
-      }
-      return format;
-   }
-
-   /**
-    * This method gets the FULL class name as a variable including the 
-    * namespace. If converts all of the '::' references to '_' so 
-    * that the result can be used in part, or in whole, as a variable name
-    */
-   public static String getClassNameAsVariable(Node clazz) { return Helper.findFullClassName(clazz).replaceAll('::','_') }
-
-   public static String getPyMethodName(Node method, MethodType methodType)
-   {
-      String clazz = Helper.findFullClassName(method)?.replaceAll('::','_')
-
-      // if we're not in a class then this must be a method node
-      assert (clazz != null || methodType == MethodType.method), 'Cannot use a non-class function as a constructor or destructor ' + method
-
-      // it's ok to pass a 'class' node if the methodType is either constructor or destructor
-      assert (method.name() != 'class' || (methodType == MethodType.constructor || methodType == MethodType.destructor))
-
-      // if this is a constructor node then the methodtype best reflect that
-      assert (method.name() != 'constructor' || methodType == MethodType.constructor), 'Cannot use a constructor node and not identify the type as a constructor' + method
-
-      // if this is a destructor node then the methodtype best reflect that
-      assert (method.name() != 'destructor' || methodType == MethodType.destructor), 'Cannot use a destructor node and not identify the type as a destructor' + method
-
-      if (clazz == null)
-        return method.@sym_name
-
-      if (methodType == MethodType.constructor)
-        return clazz + "_New"
-
-      if (methodType == MethodType.destructor)
-        return clazz + "_Dealloc"
-
-      if (method.@name.startsWith("operator "))
-      {
-        if ("[]" == method.@name.substring(9))
-          return clazz + "_operatorIndex_"
-
-        if ("()" == method.@name.substring(9))
-          return clazz + "_callable_"
-      }
-
-      return clazz + "_" + method.@sym_name;
-   }
-
-  public static String makeDocString(Node docnode)
-  { 
-    if (docnode?.name() != 'doc')
-      throw new RuntimeException("Invalid doc Node passed to PythonTools.makeDocString (" + docnode + ")")
-
-    String[] lines = (docnode.@value).split(Helper.newline)
-    def ret = ''
-    lines.eachWithIndex { val, index -> 
-      val = ((val =~ /\\n/).replaceAll('')) // remove extraneous \n's 
-      val = val.replaceAll("\\\\","\\\\\\\\") // escape backslash
-      val = ((val =~ /\"/).replaceAll("\\\\\"")) // escape quotes
-      ret += ('"' + val + '\\n"' + (index != lines.length - 1 ? Helper.newline : ''))
-    }
-
-    return ret
-  }
-
-  public static Node findValidBaseClass(Node clazz, Node module, boolean warn = false)
-  {
-    // I need to find the base type if there is a known class with it
-    assert clazz.baselist.size() < 2, "${clazz} has multiple baselists - need to write code to separate out the public one."
-    String baseclass = 'NULL'
-    List knownbases = []
-    if (clazz.baselist)
-    { 
-      if (clazz.baselist[0].base) clazz.baselist[0].base.each {
-          Node baseclassnode = Helper.findClassNodeByName(module,it.@name,clazz)
-          if (baseclassnode) knownbases.add(baseclassnode)
-          else if (warn && !Helper.isKnownBaseType(it.@name,clazz))
-            System.out.println("WARNING: the base class ${it.@name} for ${Helper.findFullClassName(clazz)} is unrecognized within ${module.@name}.")
-        }
-    }
-    assert knownbases.size() < 2, 
-      "The class ${Helper.findFullClassName(clazz)} has too many known base classes. Multiple inheritance isn't supported in the code generator. Please \"#ifdef SWIG\" out all but one."
-    return knownbases.size() > 0 ? knownbases[0] : null
-  }
-}
diff --git a/xbmc/interfaces/python3/XBPython.cpp b/xbmc/interfaces/python3/XBPython.cpp
deleted file mode 100644
index 4cafce84cb90..000000000000
--- a/xbmc/interfaces/python3/XBPython.cpp
+++ /dev/null
@@ -1,700 +0,0 @@
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-// python.h should always be included first before any other includes
-#include <Python.h>
-
-#include <algorithm>
-
-#include "system.h"
-#include "cores/DllLoader/DllLoaderContainer.h"
-#include "GUIPassword.h"
-#include "XBPython.h"
-#include "filesystem/File.h"
-#include "filesystem/SpecialProtocol.h"
-#include "utils/JSONVariantWriter.h"
-#include "utils/log.h"
-#include "utils/Variant.h"
-#include "Util.h"
-#ifdef TARGET_WINDOWS
-#include "utils/Environment.h"
-#endif
-#include "settings/AdvancedSettings.h"
-
-#include "threads/SystemClock.h"
-#include "interfaces/AnnouncementManager.h"
-
-#include "interfaces/legacy/Monitor.h"
-#include "interfaces/legacy/AddonUtils.h"
-#include "interfaces/python/AddonPythonInvoker.h"
-#include "interfaces/python/PythonInvoker.h"
-PyThreadState* savestate;
-using namespace ANNOUNCEMENT;
-
-XBPython::XBPython()
-{
-  m_bInitialized      = false;
-  m_mainThreadState   = NULL;
-  m_ThreadId          = CThread::GetCurrentThreadId();
-  m_iDllScriptCounter = 0;
-  m_endtime           = 0;
-  m_pDll              = NULL;
-  m_vecPlayerCallbackList.clear();
-  m_vecMonitorCallbackList.clear();
-
-  CAnnouncementManager::GetInstance().AddAnnouncer(this);
-}
-
-XBPython::~XBPython()
-{
-  XBMC_TRACE;
-  CAnnouncementManager::GetInstance().RemoveAnnouncer(this);
-}
-
-#define LOCK_AND_COPY(type, dest, src) \
-  if (!m_bInitialized) return; \
-  CSingleLock lock(src); \
-  src.hadSomethingRemoved = false; \
-  type dest; \
-  dest = src
-
-#define CHECK_FOR_ENTRY(l,v) \
-  (l.hadSomethingRemoved ? (std::find(l.begin(),l.end(),v) != l.end()) : true)
-
-void XBPython::Announce(AnnouncementFlag flag, const char *sender, const char *message, const CVariant &data)
-{
-  if (flag & VideoLibrary)
-  {
-   if (strcmp(message, "OnScanFinished") == 0)
-     OnScanFinished("video");
-   else if (strcmp(message, "OnScanStarted") == 0)
-     OnScanStarted("video");
-   else if (strcmp(message, "OnCleanStarted") == 0)
-     OnCleanStarted("video");
-   else if (strcmp(message, "OnCleanFinished") == 0)
-     OnCleanFinished("video");
-  }
-  else if (flag & AudioLibrary)
-  {
-   if (strcmp(message, "OnScanFinished") == 0)
-     OnScanFinished("music");
-   else if (strcmp(message, "OnScanStarted") == 0)
-     OnScanStarted("music");
-   else if (strcmp(message, "OnCleanStarted") == 0)
-     OnCleanStarted("music");
-   else if (strcmp(message, "OnCleanFinished") == 0)
-     OnCleanFinished("music");
-  }
-  else if (flag & GUI)
-  {
-   if (strcmp(message, "OnScreensaverDeactivated") == 0)
-     OnScreensaverDeactivated();
-   else if (strcmp(message, "OnScreensaverActivated") == 0)
-     OnScreensaverActivated();
-   else if (strcmp(message, "OnDPMSDeactivated") == 0)
-     OnDPMSDeactivated();
-   else if (strcmp(message, "OnDPMSActivated") == 0)
-     OnDPMSActivated();
-  }
-
-  std::string jsonData;
-  if (CJSONVariantWriter::Write(data, jsonData, g_advancedSettings.m_jsonOutputCompact))
-    OnNotification(sender, std::string(ANNOUNCEMENT::AnnouncementFlagToString(flag)) + "." + std::string(message), jsonData);
-}
-
-// message all registered callbacks that we started playing
-void XBPython::OnPlayBackStarted()
-{
-  XBMC_TRACE;
-  LOCK_AND_COPY(std::vector<PVOID>,tmp,m_vecPlayerCallbackList);
-  for (PlayerCallbackList::iterator it = tmp.begin(); (it != tmp.end()); ++it)
-  {
-    if (CHECK_FOR_ENTRY(m_vecPlayerCallbackList,(*it)))
-      ((IPlayerCallback*)(*it))->OnPlayBackStarted();
-  }
-}
-
-// message all registered callbacks that we paused playing
-void XBPython::OnPlayBackPaused()
-{
-  XBMC_TRACE;
-  LOCK_AND_COPY(std::vector<PVOID>,tmp,m_vecPlayerCallbackList);
-  for (PlayerCallbackList::iterator it = tmp.begin(); (it != tmp.end()); ++it)
-  {
-    if (CHECK_FOR_ENTRY(m_vecPlayerCallbackList,(*it)))
-      ((IPlayerCallback*)(*it))->OnPlayBackPaused();
-  }
-}
-
-// message all registered callbacks that we resumed playing
-void XBPython::OnPlayBackResumed()
-{
-  XBMC_TRACE;
-  LOCK_AND_COPY(std::vector<PVOID>,tmp,m_vecPlayerCallbackList);
-  for (PlayerCallbackList::iterator it = tmp.begin(); (it != tmp.end()); ++it)
-  {
-    if (CHECK_FOR_ENTRY(m_vecPlayerCallbackList,(*it)))
-      ((IPlayerCallback*)(*it))->OnPlayBackResumed();
-  }
-}
-
-// message all registered callbacks that xbmc stopped playing
-void XBPython::OnPlayBackEnded()
-{
-  XBMC_TRACE;
-  LOCK_AND_COPY(std::vector<PVOID>,tmp,m_vecPlayerCallbackList);
-  for (PlayerCallbackList::iterator it = tmp.begin(); (it != tmp.end()); ++it)
-  {
-    if (CHECK_FOR_ENTRY(m_vecPlayerCallbackList,(*it)))
-      ((IPlayerCallback*)(*it))->OnPlayBackEnded();
-  }
-}
-
-// message all registered callbacks that user stopped playing
-void XBPython::OnPlayBackStopped()
-{
-  XBMC_TRACE;
-  LOCK_AND_COPY(std::vector<PVOID>,tmp,m_vecPlayerCallbackList);
-  for (PlayerCallbackList::iterator it = tmp.begin(); (it != tmp.end()); ++it)
-  {
-    if (CHECK_FOR_ENTRY(m_vecPlayerCallbackList,(*it)))
-      ((IPlayerCallback*)(*it))->OnPlayBackStopped();
-  }
-}
-
-// message all registered callbacks that playback speed changed (FF/RW)
-void XBPython::OnPlayBackSpeedChanged(int iSpeed)
-{
-  XBMC_TRACE;
-  LOCK_AND_COPY(std::vector<PVOID>,tmp,m_vecPlayerCallbackList);
-  for (PlayerCallbackList::iterator it = tmp.begin(); (it != tmp.end()); ++it)
-  {
-    if (CHECK_FOR_ENTRY(m_vecPlayerCallbackList,(*it)))
-      ((IPlayerCallback*)(*it))->OnPlayBackSpeedChanged(iSpeed);
-  }
-}
-
-// message all registered callbacks that player is seeking
-void XBPython::OnPlayBackSeek(int64_t iTime, int64_t seekOffset)
-{
-  XBMC_TRACE;
-  LOCK_AND_COPY(std::vector<PVOID>,tmp,m_vecPlayerCallbackList);
-  for (PlayerCallbackList::iterator it = tmp.begin(); (it != tmp.end()); ++it)
-  {
-    if (CHECK_FOR_ENTRY(m_vecPlayerCallbackList,(*it)))
-      ((IPlayerCallback*)(*it))->OnPlayBackSeek(iTime, seekOffset);
-  }
-}
-
-// message all registered callbacks that player chapter seeked
-void XBPython::OnPlayBackSeekChapter(int iChapter)
-{
-  XBMC_TRACE;
-  LOCK_AND_COPY(std::vector<PVOID>,tmp,m_vecPlayerCallbackList);
-  for (PlayerCallbackList::iterator it = tmp.begin(); (it != tmp.end()); ++it)
-  {
-    if (CHECK_FOR_ENTRY(m_vecPlayerCallbackList,(*it)))
-      ((IPlayerCallback*)(*it))->OnPlayBackSeekChapter(iChapter);
-  }
-}
-
-// message all registered callbacks that next item has been queued
-void XBPython::OnQueueNextItem()
-{
-  XBMC_TRACE;
-  LOCK_AND_COPY(std::vector<PVOID>,tmp,m_vecPlayerCallbackList);
-  for (PlayerCallbackList::iterator it = tmp.begin(); (it != tmp.end()); ++it)
-  {
-    if (CHECK_FOR_ENTRY(m_vecPlayerCallbackList,(*it)))
-      ((IPlayerCallback*)(*it))->OnQueueNextItem();
-  }
-}
-
-void XBPython::RegisterPythonPlayerCallBack(IPlayerCallback* pCallback)
-{
-  XBMC_TRACE;
-  CSingleLock lock(m_vecPlayerCallbackList);
-  m_vecPlayerCallbackList.push_back(pCallback);
-}
-
-void XBPython::UnregisterPythonPlayerCallBack(IPlayerCallback* pCallback)
-{
-  XBMC_TRACE;
-  CSingleLock lock(m_vecPlayerCallbackList);
-  PlayerCallbackList::iterator it = m_vecPlayerCallbackList.begin();
-  while (it != m_vecPlayerCallbackList.end())
-  {
-    if (*it == pCallback)
-    {
-      it = m_vecPlayerCallbackList.erase(it);
-      m_vecPlayerCallbackList.hadSomethingRemoved = true;
-    }
-    else
-      ++it;
-  }
-}
-
-void XBPython::RegisterPythonMonitorCallBack(XBMCAddon::xbmc::Monitor* pCallback)
-{
-  XBMC_TRACE;
-  CSingleLock lock(m_vecMonitorCallbackList);
-  m_vecMonitorCallbackList.push_back(pCallback);
-}
-
-void XBPython::UnregisterPythonMonitorCallBack(XBMCAddon::xbmc::Monitor* pCallback)
-{
-  XBMC_TRACE;
-  CSingleLock lock(m_vecMonitorCallbackList);
-  MonitorCallbackList::iterator it = m_vecMonitorCallbackList.begin();
-  while (it != m_vecMonitorCallbackList.end())
-  {
-    if (*it == pCallback)
-    {
-      it = m_vecMonitorCallbackList.erase(it);
-      m_vecMonitorCallbackList.hadSomethingRemoved = true;
-    }
-    else
-      ++it;
-  }
-}
-
-void XBPython::OnSettingsChanged(const std::string &ID)
-{
-  XBMC_TRACE;
-  LOCK_AND_COPY(std::vector<XBMCAddon::xbmc::Monitor*>,tmp,m_vecMonitorCallbackList);
-  for (MonitorCallbackList::iterator it = tmp.begin(); (it != tmp.end()); ++it)
-  {
-    if (CHECK_FOR_ENTRY(m_vecMonitorCallbackList,(*it)) && ((*it)->GetId() == ID))
-      (*it)->OnSettingsChanged();
-  }
-}
-
-void XBPython::OnScreensaverActivated()
-{
-  XBMC_TRACE;
-  LOCK_AND_COPY(std::vector<XBMCAddon::xbmc::Monitor*>,tmp,m_vecMonitorCallbackList);
-  for (MonitorCallbackList::iterator it = tmp.begin(); (it != tmp.end()); ++it)
-  {
-    if (CHECK_FOR_ENTRY(m_vecMonitorCallbackList,(*it)))
-      (*it)->OnScreensaverActivated();
-  }
-}
-
-void XBPython::OnScreensaverDeactivated()
-{
-  XBMC_TRACE;
-  LOCK_AND_COPY(std::vector<XBMCAddon::xbmc::Monitor*>,tmp,m_vecMonitorCallbackList);
-  for (MonitorCallbackList::iterator it = tmp.begin(); (it != tmp.end()); ++it)
-  {
-    if (CHECK_FOR_ENTRY(m_vecMonitorCallbackList,(*it)))
-      (*it)->OnScreensaverDeactivated();
-  }
-}
-
-void XBPython::OnDPMSActivated()
-{
-  XBMC_TRACE;
-  LOCK_AND_COPY(std::vector<XBMCAddon::xbmc::Monitor*>,tmp,m_vecMonitorCallbackList);
-  for (MonitorCallbackList::iterator it = tmp.begin(); (it != tmp.end()); ++it)
-  {
-    if (CHECK_FOR_ENTRY(m_vecMonitorCallbackList,(*it)))
-      (*it)->OnDPMSActivated();
-  }
-}
-
-void XBPython::OnDPMSDeactivated()
-{
-  XBMC_TRACE;
-  LOCK_AND_COPY(std::vector<XBMCAddon::xbmc::Monitor*>,tmp,m_vecMonitorCallbackList);
-  for (MonitorCallbackList::iterator it = tmp.begin(); (it != tmp.end()); ++it)
-  {
-    if (CHECK_FOR_ENTRY(m_vecMonitorCallbackList,(*it)))
-      (*it)->OnDPMSDeactivated();
-  }
-}
-
-void XBPython::OnScanStarted(const std::string &library)
-{
-  XBMC_TRACE;
-  LOCK_AND_COPY(std::vector<XBMCAddon::xbmc::Monitor*>,tmp,m_vecMonitorCallbackList);
-  for (MonitorCallbackList::iterator it = tmp.begin(); (it != tmp.end()); ++it)
-  {
-    if (CHECK_FOR_ENTRY(m_vecMonitorCallbackList,(*it)))
-      (*it)->OnScanStarted(library);
-  }
-}
-
-void XBPython::OnScanFinished(const std::string &library)
-{
-  XBMC_TRACE;
-  LOCK_AND_COPY(std::vector<XBMCAddon::xbmc::Monitor*>,tmp,m_vecMonitorCallbackList);
-  for (MonitorCallbackList::iterator it = tmp.begin(); (it != tmp.end()); ++it)
-  {
-    if (CHECK_FOR_ENTRY(m_vecMonitorCallbackList,(*it)))
-      (*it)->OnScanFinished(library);
-  }
-}
-
-void XBPython::OnCleanStarted(const std::string &library)
-{
-  XBMC_TRACE;
-  LOCK_AND_COPY(std::vector<XBMCAddon::xbmc::Monitor*>,tmp,m_vecMonitorCallbackList);
-  for (MonitorCallbackList::iterator it = tmp.begin(); (it != tmp.end()); ++it)
-  {
-    if (CHECK_FOR_ENTRY(m_vecMonitorCallbackList,(*it)))
-      (*it)->OnCleanStarted(library);
-  }
-}
-
-void XBPython::OnCleanFinished(const std::string &library)
-{
-  XBMC_TRACE;
-  LOCK_AND_COPY(std::vector<XBMCAddon::xbmc::Monitor*>,tmp,m_vecMonitorCallbackList);
-  for (MonitorCallbackList::iterator it = tmp.begin(); (it != tmp.end()); ++it)
-  {
-    if (CHECK_FOR_ENTRY(m_vecMonitorCallbackList,(*it)))
-      (*it)->OnCleanFinished(library);
-  }
-}
-
-void XBPython::OnNotification(const std::string &sender, const std::string &method, const std::string &data)
-{
-  XBMC_TRACE;
-  LOCK_AND_COPY(std::vector<XBMCAddon::xbmc::Monitor*>,tmp,m_vecMonitorCallbackList);
-  for (MonitorCallbackList::iterator it = tmp.begin(); (it != tmp.end()); ++it)
-  {
-    if (CHECK_FOR_ENTRY(m_vecMonitorCallbackList,(*it)))
-      (*it)->OnNotification(sender, method, data);
-  }
-}
-
-/**
-* Check for file and print an error if needed
-*/
-bool XBPython::FileExist(const char* strFile)
-{
-  if (!strFile)
-    return false;
-
-  if (!XFILE::CFile::Exists(strFile))
-  {
-    CLog::Log(LOGERROR, "Python: Cannot find '%s'", strFile);
-    return false;
-  }
-  return true;
-}
-
-void XBPython::RegisterExtensionLib(LibraryLoader *pLib)
-{
-  if (!pLib)
-    return;
-
-  CSingleLock lock(m_critSection);
-
-  CLog::Log(LOGDEBUG, "%s, adding %s (%p)", __FUNCTION__, pLib->GetName(), (void*)pLib);
-  m_extensions.push_back(pLib);
-}
-
-void XBPython::UnregisterExtensionLib(LibraryLoader *pLib)
-{
-  if (!pLib)
-    return;
-
-  CSingleLock lock(m_critSection);
-  CLog::Log(LOGDEBUG, "%s, removing %s (0x%p)", __FUNCTION__, pLib->GetName(), (void *)pLib);
-  PythonExtensionLibraries::iterator iter = m_extensions.begin();
-  while (iter != m_extensions.end())
-  {
-    if (*iter == pLib)
-    {
-      m_extensions.erase(iter);
-      break;
-    }
-    ++iter;
-  }
-}
-
-void XBPython::UnloadExtensionLibs()
-{
-  CLog::Log(LOGDEBUG, "%s, clearing python extension libraries", __FUNCTION__);
-  CSingleLock lock(m_critSection);
-  PythonExtensionLibraries::iterator iter = m_extensions.begin();
-  while (iter != m_extensions.end())
-  {
-      DllLoaderContainer::ReleaseModule(*iter);
-      ++iter;
-  }
-  m_extensions.clear();
-}
-
-// Always called with the lock held on m_critSection
-void XBPython::Finalize()
-{
-  XBMC_TRACE;
-  if (m_bInitialized)
-  {
-    CLog::Log(LOGINFO, "Python, unloading python shared library because no scripts are running anymore");
-
-    // set the m_bInitialized flag before releasing the lock. This will prevent
-    // Other methods that rely on this flag from an incorrect interpretation.
-    m_bInitialized    = false;
-    PyThreadState* curTs = (PyThreadState*)m_mainThreadState;
-    m_mainThreadState = NULL; // clear the main thread state before releasing the lock
-    {
-      CSingleExit exit(m_critSection);
-	  PyEval_AcquireThread(curTs);
-
-      Py_Finalize();
-      PyEval_ReleaseLock();
-    }
-
-#if !(defined(TARGET_DARWIN) || defined(TARGET_WINDOWS))
-    UnloadExtensionLibs();
-#endif
-
-    // first free all dlls loaded by python, after that unload python (this is done by UnloadPythonDlls
-#if !(defined(TARGET_DARWIN) || defined(TARGET_WINDOWS))
-    DllLoaderContainer::UnloadPythonDlls();
-#endif
-#if defined(TARGET_POSIX) && !defined(TARGET_DARWIN) && !defined(TARGET_FREEBSD)
-    // we can't release it on windows, as this is done in UnloadPythonDlls() for win32 (see above).
-    // The implementation for linux needs looking at - UnloadPythonDlls() currently only searches for "python36.dll"
-    // The implementation for osx can never unload the python dylib.
-    DllLoaderContainer::ReleaseModule(m_pDll);
-#endif
-  }
-}
-
-void XBPython::Uninitialize()
-{
-  // don't handle any more announcements as most scripts are probably already
-  // stopped and executing a callback on one of their already destroyed classes
-  // would lead to a crash
-  CAnnouncementManager::GetInstance().RemoveAnnouncer(this);
-
-  LOCK_AND_COPY(std::vector<PyElem>,tmpvec,m_vecPyList);
-  m_vecPyList.clear();
-  m_vecPyList.hadSomethingRemoved = true;
-
-  lock.Leave(); //unlock here because the python thread might lock when it exits
-
-  // cleanup threads that are still running
-  tmpvec.clear(); // boost releases the XBPyThreads which, if deleted, calls OnScriptFinalized
-}
-
-void XBPython::Process()
-{
-  if (m_bInitialized)
-  {
-    PyList tmpvec;
-    CSingleLock lock(m_vecPyList);
-    for (PyList::iterator it = m_vecPyList.begin(); it != m_vecPyList.end();)
-    {
-      if (it->bDone)
-      {
-        tmpvec.push_back(*it);
-        it = m_vecPyList.erase(it);
-        m_vecPyList.hadSomethingRemoved = true;
-      }
-      else
-        ++it;
-    }
-    lock.Leave();
-
-    //delete scripts which are done
-    tmpvec.clear(); // boost releases the XBPyThreads which, if deleted, calls OnScriptFinalized
-
-    CSingleLock l2(m_critSection);
-    if(m_iDllScriptCounter == 0 && (XbmcThreads::SystemClockMillis() - m_endtime) > 10000 )
-    {
-      Finalize();
-    }
-  }
-}
-
-bool XBPython::OnScriptInitialized(ILanguageInvoker *invoker)
-{
-  if (invoker == NULL)
-    return false;
-
-  XBMC_TRACE;
-  CLog::Log(LOGINFO, "initializing python engine.");
-  CSingleLock lock(m_critSection);
-  m_iDllScriptCounter++;
-  if (!m_bInitialized)
-  {
-    // first we check if all necessary files are installed
-#ifndef TARGET_POSIX
-    if (!FileExist("special://xbmc/system/python/DLLs/_socket.pyd") ||
-      !FileExist("special://xbmc/system/python/DLLs/_ssl.pyd") ||
-      !FileExist("special://xbmc/system/python/DLLs/_bz2.pyd") ||
-      !FileExist("special://xbmc/system/python/DLLs/pyexpat.pyd") ||
-      !FileExist("special://xbmc/system/python/DLLs/select.pyd") ||
-      !FileExist("special://xbmc/system/python/DLLs/unicodedata.pyd"))
-    {
-      CLog::Log(LOGERROR, "Python: Missing files, unable to execute script");
-      Finalize();
-      return false;
-    }
-#endif
-
-    // Darwin packs .pyo files, we need PYTHONOPTIMIZE on in order to load them.
-    // linux built with unified builds only packages the pyo files so need it
-#if defined(TARGET_DARWIN) || defined(TARGET_LINUX)
-    setenv("PYTHONOPTIMIZE", "1", 1);
-#endif
-    // Info about interesting python envvars available
-    // at http://docs.python.org/using/cmdline.html#environment-variables
-
-#if !defined(TARGET_WINDOWS) && !defined(TARGET_ANDROID)
-    /* PYTHONOPTIMIZE is set off intentionally when using external Python.
-    Reason for this is because we cannot be sure what version of Python
-    was used to compile the various Python object files (i.e. .pyo,
-    .pyc, etc.). */
-    // check if we are running as real xbmc.app or just binary
-    if (!CUtil::GetFrameworksPath(true).empty())
-    {
-      // using external python, it's build looking for xxx/lib/python3.6
-      // so point it to frameworks which is where python3.6 is located
-      setenv("PYTHONHOME", CSpecialProtocol::TranslatePath("special://frameworks").c_str(), 1);
-      setenv("PYTHONPATH", CSpecialProtocol::TranslatePath("special://frameworks").c_str(), 1);
-      CLog::Log(LOGDEBUG, "PYTHONHOME -> %s", CSpecialProtocol::TranslatePath("special://frameworks").c_str());
-      CLog::Log(LOGDEBUG, "PYTHONPATH -> %s", CSpecialProtocol::TranslatePath("special://frameworks").c_str());
-    }
-#elif defined(TARGET_WINDOWS)
-    // because the third party build of python is compiled with vs2008 we need
-    // a hack to set the PYTHONPATH
-    std::string buf;
-    buf = "PYTHONPATH=" + CSpecialProtocol::TranslatePath("special://xbmc/system/python/DLLs") + ";" + CSpecialProtocol::TranslatePath("special://xbmc/system/python/Lib");
-    CEnvironment::putenv(buf);
-    buf = "PYTHONOPTIMIZE=1";
-    CEnvironment::putenv(buf);
-    buf = "PYTHONHOME=" + CSpecialProtocol::TranslatePath("special://xbmc/system/python");
-    CEnvironment::putenv(buf);
-    buf = "OS=win32";
-    CEnvironment::putenv(buf);
-#endif
-
-    Py_Initialize();
-
-    // If this is not the first time we initialize Python, the interpreter
-    // lock already exists and we need to lock it as PyEval_InitThreads
-    // would not do that in that case.
-    if (PyEval_ThreadsInitialized())
-      PyEval_AcquireLock();
-    else
-      PyEval_InitThreads();
-    wchar_t* python_argv[1] = { L"" };
-    PySys_SetArgv(1, python_argv);
-
-    if (!(m_mainThreadState = PyThreadState_Get()))
-      CLog::Log(LOGERROR, "Python threadstate is NULL.");
-	savestate = PyEval_SaveThread();
-
-    m_bInitialized = true;
-  }
-
-  return m_bInitialized;
-}
-
-void XBPython::OnScriptStarted(ILanguageInvoker *invoker)
-{
-  if (invoker == NULL)
-    return;
-
-  if (!m_bInitialized)
-    return;
-
-  PyElem inf;
-  inf.id        = invoker->GetId();
-  inf.bDone     = false;
-  inf.pyThread  = static_cast<CPythonInvoker*>(invoker);
-  CSingleLock lock(m_vecPyList);
-  m_vecPyList.push_back(inf);
-}
-
-void XBPython::OnScriptAbortRequested(ILanguageInvoker *invoker)
-{
-  XBMC_TRACE;
-
-  long invokerId(-1);
-  if (invoker != NULL)
-    invokerId = invoker->GetId();
-
-  LOCK_AND_COPY(std::vector<XBMCAddon::xbmc::Monitor*>, tmp, m_vecMonitorCallbackList);
-  for (MonitorCallbackList::iterator it = tmp.begin(); (it != tmp.end()); ++it)
-  {
-    if (CHECK_FOR_ENTRY(m_vecMonitorCallbackList, (*it)))
-    {
-      if (invokerId < 0 || (*it)->GetInvokerId() == invokerId)
-        (*it)->OnAbortRequested();
-    }
-  }
-}
-
-void XBPython::OnScriptEnded(ILanguageInvoker *invoker)
-{
-  CSingleLock lock(m_vecPyList);
-  PyList::iterator it = m_vecPyList.begin();
-  while (it != m_vecPyList.end())
-  {
-    if (it->id == invoker->GetId())
-    {
-      if (it->pyThread->IsStopping())
-        CLog::Log(LOGINFO, "Python script interrupted by user");
-      else
-        CLog::Log(LOGINFO, "Python script stopped");
-      it->bDone = true;
-    }
-    ++it;
-  }
-}
-
-void XBPython::OnScriptFinalized(ILanguageInvoker *invoker)
-{
-  XBMC_TRACE;
-  CSingleLock lock(m_critSection);
-  // for linux - we never release the library. its loaded and stays in memory.
-  if (m_iDllScriptCounter)
-    m_iDllScriptCounter--;
-  else
-    CLog::Log(LOGERROR, "Python script counter attempted to become negative");
-  m_endtime = XbmcThreads::SystemClockMillis();
-}
-
-ILanguageInvoker* XBPython::CreateInvoker()
-{
-  return new CAddonPythonInvoker(this);
-}
-
-void XBPython::PulseGlobalEvent()
-{
-  m_globalEvent.Set();
-}
-
-bool XBPython::WaitForEvent(CEvent& hEvent, unsigned int milliseconds)
-{
-  // wait for either this event our our global event
-  XbmcThreads::CEventGroup eventGroup{&hEvent, &m_globalEvent};
-  CEvent* ret = eventGroup.wait(milliseconds);
-  if (ret)
-    m_globalEvent.Reset();
-  return ret != NULL;
-}
diff --git a/xbmc/interfaces/python3/XBPython.h b/xbmc/interfaces/python3/XBPython.h
deleted file mode 100644
index 85424dc0a549..000000000000
--- a/xbmc/interfaces/python3/XBPython.h
+++ /dev/null
@@ -1,137 +0,0 @@
-#pragma once
-
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#include "cores/IPlayerCallback.h"
-#include "threads/CriticalSection.h"
-#include "threads/Event.h"
-#include "threads/Thread.h"
-#include "interfaces/IAnnouncer.h"
-#include "interfaces/generic/ILanguageInvocationHandler.h"
-#include "ServiceBroker.h"
-
-#include <memory>
-#include <vector>
-
-#define g_pythonParser CServiceBroker::GetXBPython()
-
-class CPythonInvoker;
-class CVariant;
-
-typedef struct {
-  int id;
-  bool bDone;
-  CPythonInvoker* pyThread;
-}PyElem;
-
-class LibraryLoader;
-
-namespace XBMCAddon
-{
-  namespace xbmc
-  {
-    class Monitor;
-  }
-}
-
-template <class T> struct LockableType : public T, public CCriticalSection
-{ bool hadSomethingRemoved; };
-
-typedef LockableType<std::vector<void*> > PlayerCallbackList;
-typedef LockableType<std::vector<XBMCAddon::xbmc::Monitor*> > MonitorCallbackList;
-typedef LockableType<std::vector<PyElem> > PyList;
-typedef std::vector<LibraryLoader*> PythonExtensionLibraries;
-
-class XBPython :
-  public IPlayerCallback,
-  public ANNOUNCEMENT::IAnnouncer,
-  public ILanguageInvocationHandler
-{
-public:
-  XBPython();
-  ~XBPython() override;
-  void OnPlayBackEnded() override;
-  void OnPlayBackStarted() override;
-  void OnPlayBackPaused() override;
-  void OnPlayBackResumed() override;
-  void OnPlayBackStopped() override;
-  void OnPlayBackSpeedChanged(int iSpeed) override;
-  void OnPlayBackSeek(int64_t iTime, int64_t seekOffset) override;
-  void OnPlayBackSeekChapter(int iChapter) override;
-  void OnQueueNextItem() override;
-
-  void Announce(ANNOUNCEMENT::AnnouncementFlag flag, const char *sender, const char *message, const CVariant &data) override;
-  void RegisterPythonPlayerCallBack(IPlayerCallback* pCallback);
-  void UnregisterPythonPlayerCallBack(IPlayerCallback* pCallback);
-  void RegisterPythonMonitorCallBack(XBMCAddon::xbmc::Monitor* pCallback);
-  void UnregisterPythonMonitorCallBack(XBMCAddon::xbmc::Monitor* pCallback);
-  void OnSettingsChanged(const std::string &strings);
-  void OnScreensaverActivated();
-  void OnScreensaverDeactivated();
-  void OnDPMSActivated();
-  void OnDPMSDeactivated();
-  void OnScanStarted(const std::string &library);
-  void OnScanFinished(const std::string &library);
-  void OnCleanStarted(const std::string &library);
-  void OnCleanFinished(const std::string &library);
-  void OnNotification(const std::string &sender, const std::string &method, const std::string &data);
-
-  void Process() override;
-  void PulseGlobalEvent() override;
-  void Uninitialize() override;
-  bool OnScriptInitialized(ILanguageInvoker *invoker) override;
-  void OnScriptStarted(ILanguageInvoker *invoker) override;
-  void OnScriptAbortRequested(ILanguageInvoker *invoker) override;
-  void OnScriptEnded(ILanguageInvoker *invoker) override;
-  void OnScriptFinalized(ILanguageInvoker *invoker) override;
-  ILanguageInvoker* CreateInvoker() override;
-
-  bool WaitForEvent(CEvent& hEvent, unsigned int milliseconds);
-
-  void RegisterExtensionLib(LibraryLoader *pLib);
-  void UnregisterExtensionLib(LibraryLoader *pLib);
-  void UnloadExtensionLibs();
-
-private:
-  void Finalize();
-
-  CCriticalSection    m_critSection;
-  bool              FileExist(const char* strFile);
-
-  void*             m_mainThreadState;
-  ThreadIdentifier  m_ThreadId;
-  bool              m_bInitialized;
-  int               m_iDllScriptCounter; // to keep track of the total scripts running that need the dll
-  unsigned int      m_endtime;
-
-  //Vector with list of threads used for running scripts
-  PyList              m_vecPyList;
-  PlayerCallbackList  m_vecPlayerCallbackList;
-  MonitorCallbackList m_vecMonitorCallbackList;
-  LibraryLoader*      m_pDll;
-
-  // any global events that scripts should be using
-  CEvent m_globalEvent;
-
-  // in order to finalize and unload the python library, need to save all the extension libraries that are
-  // loaded by it and unload them first (not done by finalize)
-  PythonExtensionLibraries m_extensions;
-};
diff --git a/xbmc/interfaces/python3/preamble.h b/xbmc/interfaces/python3/preamble.h
deleted file mode 100644
index 4d5597dd8bcc..000000000000
--- a/xbmc/interfaces/python3/preamble.h
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#pragma once
-
-#ifdef SWIGPYTHON
-
-#include <Python.h>
-
-#endif
diff --git a/xbmc/interfaces/python3/pythreadstate.h b/xbmc/interfaces/python3/pythreadstate.h
deleted file mode 100644
index 0237edcb9176..000000000000
--- a/xbmc/interfaces/python3/pythreadstate.h
+++ /dev/null
@@ -1,73 +0,0 @@
-#pragma once
-
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#include "threads/SingleLock.h"
-
-//WARNING: since this will unlock/lock the python global interpreter lock,
-//         it will not work recursively
-
-//this is basically a scoped version of a Py_BEGIN_ALLOW_THREADS .. Py_END_ALLOW_THREADS block
-class CPyThreadState
-{
-  public:
-    explicit CPyThreadState(bool save = true)
-    {
-      m_threadState = NULL;
-
-      if (save)
-        Save();
-    }
-
-    ~CPyThreadState()
-    {
-      Restore();
-    }
-
-    void Save()
-    {
-      if (!m_threadState)
-        m_threadState = PyEval_SaveThread(); //same as Py_BEGIN_ALLOW_THREADS
-    }
-
-    void Restore()
-    {
-      if (m_threadState)
-      {
-        PyEval_RestoreThread(m_threadState); //same as Py_END_ALLOW_THREADS
-        m_threadState = NULL;
-      }
-    }
-
-  private:
-    PyThreadState* m_threadState;
-};
-
-/**
- * A CSingleLock that will relinquish the GIL during the time
- *  it takes to obtain the CriticalSection
- */
-class GilSafeSingleLock : public CPyThreadState, public CSingleLock
-{
-public:
-  explicit GilSafeSingleLock(const CCriticalSection& critSec) : CPyThreadState(true), CSingleLock(critSec) { CPyThreadState::Restore(); }
-};
-
diff --git a/xbmc/interfaces/python3/swig.cpp b/xbmc/interfaces/python3/swig.cpp
deleted file mode 100644
index e9f1111e19bb..000000000000
--- a/xbmc/interfaces/python3/swig.cpp
+++ /dev/null
@@ -1,385 +0,0 @@
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#include "LanguageHook.h"
-#include "swig.h"
-#include "utils/StringUtils.h"
-#include "interfaces/legacy/AddonString.h"
-
-#include <string>
-
-namespace PythonBindings
-{
-  TypeInfo::TypeInfo(const std::type_info& ti) : swigType(NULL), parentType(NULL), typeIndex(ti)
-  {
-    static PyTypeObject py_type_object_header = { PyVarObject_HEAD_INIT(NULL, 0)};
-    static int size = (long*)&(py_type_object_header.tp_name) - (long*)&py_type_object_header;
-    memcpy(&(this->pythonType), &py_type_object_header, size);
-  }
-
-  class PyObjectDecrementor
-  {
-    PyObject* obj;
-  public:
-    inline explicit PyObjectDecrementor(PyObject* pyobj) : obj(pyobj) {}
-    inline ~PyObjectDecrementor() { Py_XDECREF(obj); }
-
-    inline PyObject* get() { return obj; }
-  };
-
-  void PyXBMCGetUnicodeString(std::string& buf, PyObject* pObject, bool coerceToString,
-                              const char* argumentName, const char* methodname)
-  {
-    // It's okay for a string to be "None". In this case the buf returned
-    // will be the emptyString.
-    if (pObject == Py_None)
-    {
-      buf = XBMCAddon::emptyString;
-      return;
-    }
-
-    //! @todo UTF-8: Does python use UTF-16?
-    //!              Do we need to convert from the string charset to UTF-8
-    //!              for non-unicode data?
-    if (PyUnicode_Check(pObject))
-    {
-      // Python unicode objects are UCS2 or UCS4 depending on compilation
-      // options, wchar_t is 16-bit or 32-bit depending on platform.
-      // Avoid the complexity by just letting python convert the string.
-
-      buf = PyUnicode_AsUTF8(pObject);
-      return;
-    }
-
-    if (PyBytes_Check(pObject))    // If pobject is of type Bytes
-    {
-      buf = PyBytes_AsString(pObject);
-      return;
-    }
-
-    // if we got here then we need to coerce the value to a string
-    if (coerceToString)
-    {
-      PyObjectDecrementor dec(PyObject_Str(pObject));
-      PyObject* pyStrCast = dec.get();
-      if (pyStrCast)
-      {
-        PyXBMCGetUnicodeString(buf,pyStrCast,false,argumentName,methodname);
-        return;
-      }
-    }
-
-    // Object is not a unicode or a normal string.
-    buf = "";
-    throw XBMCAddon::WrongTypeException("argument \"%s\" for method \"%s\" must be unicode or str", argumentName, methodname);
-  }
-
-  // need to compare the typestring
-  bool isParameterRightType(const char* passedType, const char* expectedType, const char* methodNamespacePrefix, bool tryReverse)
-  {
-    if (strcmp(expectedType,passedType) == 0)
-      return true;
-
-    // well now things are a bit more complicated. We need to see if the passed type
-    // is a subset of the overall type
-    std::string et(expectedType);
-    bool isPointer = (et[0] == 'p' && et[1] == '.');
-    std::string baseType(et,(isPointer ? 2 : 0)); // this may contain a namespace
-
-    std::string ns(methodNamespacePrefix);
-    // cut off trailing '::'
-    if (ns.size() > 2 && ns[ns.size() - 1] == ':' && ns[ns.size() - 2] == ':')
-      ns = ns.substr(0,ns.size()-2);
-
-    bool done = false;
-    while(! done)
-    {
-      done = true;
-
-      // now we need to see if the expected type can be munged
-      //  into the passed type by tacking on the namespace of
-      //  of the method.
-      std::string check(isPointer ? "p." : "");
-      check += ns;
-      check += "::";
-      check += baseType;
-
-      if (strcmp(check.c_str(),passedType) == 0)
-        return true;
-
-      // see if the namespace is nested.
-      int posOfScopeOp = ns.find("::");
-      if (posOfScopeOp >= 0)
-      {
-        done = false;
-        // cur off the outermost namespace
-        ns = ns.substr(posOfScopeOp + 2);
-      }
-    }
-
-    // so far we applied the namespace to the expected type. Now lets try
-    //  the reverse if we haven't already.
-    if (tryReverse)
-      return isParameterRightType(expectedType, passedType, methodNamespacePrefix, false);
-
-    return false;
-  }
-
-  PythonToCppException::PythonToCppException() : XbmcCommons::UncheckedException(" ")
-  {
-    setClassname("PythonToCppException");
-
-    std::string msg;
-    std::string type, value, traceback;
-    if (!ParsePythonException(type, value, traceback))
-      UncheckedException::SetMessage("Strange: No Python exception occured");
-    else
-      SetMessage(type, value, traceback);
-  }
-
-  PythonToCppException::PythonToCppException(const std::string &exceptionType, const std::string &exceptionValue, const std::string &exceptionTraceback) : XbmcCommons::UncheckedException(" ")
-  {
-    setClassname("PythonToCppException");
-
-    SetMessage(exceptionType, exceptionValue, exceptionTraceback);
-  }
-
-  bool PythonToCppException::ParsePythonException(std::string &exceptionType, std::string &exceptionValue, std::string &exceptionTraceback)
-  {
-    PyObject* exc_type;
-    PyObject* exc_value;
-    PyObject* exc_traceback;
-    PyObject* pystring = NULL;
-
-    PyErr_Fetch(&exc_type, &exc_value, &exc_traceback);
-    if (exc_type == NULL && exc_value == NULL && exc_traceback == NULL)
-      return false;
-
-    exceptionType.clear();
-    exceptionValue.clear();
-    exceptionTraceback.clear();
-
-    if (exc_type != NULL && (pystring = PyObject_Str(exc_type)) != NULL && PyUnicode_Check(pystring))
-    {
-      char *str = PyUnicode_AsUTF8(pystring);
-      if (str != NULL)
-        exceptionType = str;
-
-      pystring = PyObject_Str(exc_value);
-      if (pystring != NULL)
-      {
-        str = PyUnicode_AsUTF8(pystring);
-        exceptionValue = str;
-      }
-
-      PyObject *tracebackModule = PyImport_ImportModule("traceback");
-      if (tracebackModule != NULL)
-      {
-        char method[] = "format_exception";
-        char format[] = "OOO";
-        PyObject *tbList = PyObject_CallMethod(tracebackModule, method, format, exc_type, exc_value == NULL ? Py_None : exc_value, exc_traceback == NULL ? Py_None : exc_traceback);
-
-        if (tbList)
-        {
-          PyObject *emptyString = PyUnicode_FromString("");
-          char method[] = "join";
-          char format[] = "O";
-          PyObject *strRetval = PyObject_CallMethod(emptyString, method, format, tbList);
-          Py_DECREF(emptyString);
-
-          if (strRetval)
-          {
-            str = PyUnicode_AsUTF8(strRetval);
-            if (str != NULL)
-              exceptionTraceback = str;
-            Py_DECREF(strRetval);
-          }
-          Py_DECREF(tbList);
-        }
-        Py_DECREF(tracebackModule);
-
-      }
-    }
-
-    Py_XDECREF(exc_type);
-    Py_XDECREF(exc_value);
-    Py_XDECREF(exc_traceback);
-    Py_XDECREF(pystring);
-
-    return true;
-  }
-
-  void PythonToCppException::SetMessage(const std::string &exceptionType, const std::string &exceptionValue, const std::string &exceptionTraceback)
-  {
-    std::string msg = "-->Python callback/script returned the following error<--\n";
-    msg += " - NOTE: IGNORING THIS CAN LEAD TO MEMORY LEAKS!\n";
-
-    if (!exceptionType.empty())
-    {
-      msg += StringUtils::Format("Error Type: %s\n", exceptionType.c_str());
-
-      if (!exceptionValue.empty())
-        msg += StringUtils::Format("Error Contents: %s\n", exceptionValue.c_str());
-
-      if (!exceptionTraceback.empty())
-        msg += exceptionTraceback;
-
-      msg += "-->End of Python script error report<--\n";
-    }
-    else
-      msg += "<unknown exception type>";
-
-    UncheckedException::SetMessage("%s", msg.c_str());
-  }
-
-  XBMCAddon::AddonClass* doretrieveApiInstance(const PyHolder* pythonObj, const TypeInfo* typeInfo, const char* expectedType,
-                              const char* methodNamespacePrefix, const char* methodNameForErrorString)
-  {
-    if (pythonObj->magicNumber != XBMC_PYTHON_TYPE_MAGIC_NUMBER)
-      throw XBMCAddon::WrongTypeException("Non api type passed to \"%s\" in place of the expected type \"%s.\"",
-                                          methodNameForErrorString, expectedType);
-    if (!isParameterRightType(typeInfo->swigType,expectedType,methodNamespacePrefix))
-    {
-      // maybe it's a child class
-      if (typeInfo->parentType)
-        return doretrieveApiInstance(pythonObj, typeInfo->parentType,expectedType,
-                                     methodNamespacePrefix, methodNameForErrorString);
-      else
-        throw XBMCAddon::WrongTypeException("Incorrect type passed to \"%s\", was expecting a \"%s\" but received a \"%s\"",
-                                 methodNameForErrorString,expectedType,typeInfo->swigType);
-    }
-    return const_cast<XBMCAddon::AddonClass*>(reinterpret_cast<const PyHolder*>(pythonObj)->pSelf);
-  }
-
-  /**
-   * This method is a helper for the generated API. It's called prior to any API
-   * class constructor being returned from the generated code to Python
-   */
-  void prepareForReturn(XBMCAddon::AddonClass* c)
-  {
-    XBMC_TRACE;
-    if(c) {
-      c->Acquire();
-      PyThreadState* state = PyThreadState_Get();
-      XBMCAddon::Python::PythonLanguageHook::GetIfExists(state->interp)->RegisterAddonClassInstance(c);
-    }
-  }
-
-  static bool handleInterpRegistrationForClean(XBMCAddon::AddonClass* c)
-  {
-    XBMC_TRACE;
-    if(c){
-      XBMCAddon::AddonClass::Ref<XBMCAddon::Python::PythonLanguageHook> lh =
-        XBMCAddon::AddonClass::Ref<XBMCAddon::AddonClass>(c->GetLanguageHook());
-
-      if (lh.isNotNull())
-      {
-        lh->UnregisterAddonClassInstance(c);
-        return true;
-      }
-      else
-      {
-        PyThreadState* state = PyThreadState_Get();
-        lh = XBMCAddon::Python::PythonLanguageHook::GetIfExists(state->interp);
-        if (lh.isNotNull()) lh->UnregisterAddonClassInstance(c);
-        return true;
-      }
-    }
-    return false;
-  }
-
-  /**
-   * This method is a helper for the generated API. It's called prior to any API
-   * class destructor being dealloc-ed from the generated code from Python
-   */
-  void cleanForDealloc(XBMCAddon::AddonClass* c)
-  {
-    XBMC_TRACE;
-    if (handleInterpRegistrationForClean(c))
-      c->Release();
-  }
-
-  /**
-   * This method is a helper for the generated API. It's called prior to any API
-   * class destructor being dealloc-ed from the generated code from Python
-   *
-   * There is a Catch-22 in the destruction of a Window. 'dispose' needs to be
-   * called on destruction but cannot be called from the destructor.
-   * This overrides the default cleanForDealloc to resolve that.
-   */
-  void cleanForDealloc(XBMCAddon::xbmcgui::Window* c)
-  {
-    XBMC_TRACE;
-    if (handleInterpRegistrationForClean(c))
-    {
-      c->dispose();
-      c->Release();
-    }
-  }
-
-  /**
-   * This method allows for conversion of the native api Type to the Python type.
-   *
-   * When this form of the call is used (and pytype isn't NULL) then the
-   * passed type is used in the instance. This is for classes that extend API
-   * classes in python. The type passed may not be the same type that's stored
-   * in the class metadata of the AddonClass of which 'api' is an instance,
-   * it can be a subclass in python.
-   *
-   * if pytype is NULL then the type is inferred using the class metadata
-   * stored in the AddonClass instance 'api'.
-   */
-  PyObject* makePythonInstance(XBMCAddon::AddonClass* api, PyTypeObject* pytype, bool incrementRefCount)
-  {
-    // null api types result in Py_None
-    if (!api)
-    {
-      Py_INCREF(Py_None);
-      return Py_None;
-    }
-
-    // retrieve the TypeInfo from the api class
-    const TypeInfo* typeInfo = getTypeInfoForInstance(api);
-    PyTypeObject* typeObj = pytype == NULL ? (PyTypeObject*)(&(typeInfo->pythonType)) : pytype;
-
-    PyHolder* self = reinterpret_cast<PyHolder*>(typeObj->tp_alloc(typeObj,0));
-    if (!self) return NULL;
-    self->magicNumber = XBMC_PYTHON_TYPE_MAGIC_NUMBER;
-    self->typeInfo = typeInfo;
-    self->pSelf = api;
-    if (incrementRefCount)
-      Py_INCREF((PyObject*)self);
-    return (PyObject*)self;
-  }
-
-  std::map<std::type_index, const TypeInfo*> typeInfoLookup;
-
-  void registerAddonClassTypeInformation(const TypeInfo* classInfo)
-  {
-    typeInfoLookup[classInfo->typeIndex] = classInfo;
-  }
-
-  const TypeInfo* getTypeInfoForInstance(XBMCAddon::AddonClass* obj)
-  {
-    std::type_index ti(typeid(*obj));
-    return typeInfoLookup[ti];
-  }
-
-}
diff --git a/xbmc/interfaces/python3/swig.h b/xbmc/interfaces/python3/swig.h
deleted file mode 100644
index 57a63fc8adf1..000000000000
--- a/xbmc/interfaces/python3/swig.h
+++ /dev/null
@@ -1,211 +0,0 @@
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#pragma once
-
-#include <Python.h>
-#include <string>
-#include <stdint.h>
-
-#include "interfaces/legacy/Exception.h"
-#include "interfaces/legacy/AddonClass.h"
-#include "interfaces/legacy/Window.h"
-#include <typeindex>
-
-namespace PythonBindings
-{
-  /**
-   * This call will convert the python object passed to a string. The object
-   * passed must be a python str or unicode object unless coerceToString is
-   * true. If coerceToString is true then the type must be castable to a string
-   * using the python call str(pObject).
-   *
-   * This method will handle a 'None' that's passed in. If 'None' is passed then
-   * the resulting buf will contain the value of XBMCAddon::emptyString (which 
-   * is simply a std::string instantiated with the default constructor.
-   */
-  void PyXBMCGetUnicodeString(std::string& buf, PyObject* pObject, bool coerceToString = false,
-                              const char* pos = "unknown", 
-                              const char* methodname = "unknown");
-
-  struct TypeInfo
-  {
-    const char* swigType;
-    TypeInfo* parentType;
-    PyTypeObject pythonType;
-    const std::type_index typeIndex;
-
-    explicit TypeInfo(const std::type_info& ti);
-  };
-
-  // This will hold the pointer to the api type, whether known or unknown
-  struct PyHolder
-  { 
-    PyObject_HEAD
-    int32_t magicNumber;
-    const TypeInfo* typeInfo;
-    XBMCAddon::AddonClass* pSelf;
-  };
-
-#define XBMC_PYTHON_TYPE_MAGIC_NUMBER 0x58626D63
-
-  /**
-   * This method retrieves the pointer from the PyHolder. The return value should
-   * be cast to the appropriate type.
-   *
-   * Since the calls to this are generated there's no NULL pointer checks
-   */
-  inline XBMCAddon::AddonClass* retrieveApiInstance(PyObject* pythonObj, const TypeInfo* typeToCheck, 
-                                   const char* methodNameForErrorString, 
-                                   const char* typenameForErrorString)
-  {
-    if (pythonObj == NULL || pythonObj == Py_None)
-      return NULL;
-    if (reinterpret_cast<PyHolder*>(pythonObj)->magicNumber != XBMC_PYTHON_TYPE_MAGIC_NUMBER || !PyObject_TypeCheck(pythonObj, const_cast<PyTypeObject*>((&(typeToCheck->pythonType)))))
-      throw XBMCAddon::WrongTypeException("Incorrect type passed to \"%s\", was expecting a \"%s\".",methodNameForErrorString,typenameForErrorString);
-    return reinterpret_cast<PyHolder*>(pythonObj)->pSelf;
-  }
-
-  bool isParameterRightType(const char* passedType, const char* expectedType, const char* methodNamespacePrefix, bool tryReverse = true);
-
-  XBMCAddon::AddonClass* doretrieveApiInstance(const PyHolder* pythonObj, const TypeInfo* typeInfo, const char* expectedType, 
-                              const char* methodNamespacePrefix, const char* methodNameForErrorString);
-
-  /**
-   * This method retrieves the pointer from the PyHolder. The return value should
-   * be cast to the appropriate type.
-   *
-   * Since the calls to this are generated there's no NULL pointer checks
-   *
-   * This method will return NULL if either the pythonObj is NULL or the 
-   * pythonObj is Py_None.
-   */
-  inline XBMCAddon::AddonClass* retrieveApiInstance(const PyObject* pythonObj, const char* expectedType, const char* methodNamespacePrefix,
-                                   const char* methodNameForErrorString)
-  {
-    return (pythonObj == NULL || pythonObj == Py_None) ? NULL :
-      doretrieveApiInstance(reinterpret_cast<const PyHolder*>(pythonObj),reinterpret_cast<const PyHolder*>(pythonObj)->typeInfo, expectedType, methodNamespacePrefix, methodNameForErrorString);
-  }
-
-  /**
-   * This method is a helper for the generated API. It's called prior to any API
-   * class constructor being returned from the generated code to Python
-   */
-  void prepareForReturn(XBMCAddon::AddonClass* c);
-
-  /**
-   * This method is a helper for the generated API. It's called prior to any API
-   * class destructor being dealloc-ed from the generated code from Python
-   */
-  void cleanForDealloc(XBMCAddon::AddonClass* c);
-
-  /**
-   * This method is a helper for the generated API. It's called prior to any API
-   * class destructor being dealloc-ed from the generated code from Python
-   *
-   * There is a Catch-22 in the destruction of a Window. 'dispose' needs to be
-   * called on destruction but cannot be called from the destructor.
-   * This overrides the default cleanForDealloc to resolve that.
-   */
-  void cleanForDealloc(XBMCAddon::xbmcgui::Window* c);
-
-  /**
-   * This method allows for conversion of the native api Type to the Python type.
-   *
-   * When this form of the call is used (and pythonType isn't NULL) then the
-   * passed type is used in the instance. This is for classes that extend API
-   * classes in python. The type passed may not be the same type that's stored
-   * in the class metadata of the AddonClass of which 'api' is an instance, 
-   * it can be a subclass in python.
-   *
-   * if pythonType is NULL then the type is inferred using the class metadata 
-   * stored in the AddonClass instance 'api'.
-   */
-  PyObject* makePythonInstance(XBMCAddon::AddonClass* api, PyTypeObject* pythonType, bool incrementRefCount);
-
-  /**
-   * This method allows for conversion of the native api Type to the Python type.
-   * 
-   * When this form of the call is used then the python type constructed will be the 
-   * type given by the class metadata in the AddonClass instance 'api'.
-   *
-   * This is just a helper inline to call the other makePythonInstance with NULL as
-   * the pythonType.
-   */
-  inline PyObject* makePythonInstance(XBMCAddon::AddonClass* api, bool incrementRefCount)
-  {
-    return makePythonInstance(api,NULL,incrementRefCount);
-  }
-
-  void registerAddonClassTypeInformation(const TypeInfo* classInfo);
-  const TypeInfo* getTypeInfoForInstance(XBMCAddon::AddonClass* obj);
-
-  class Director
-  {
-  protected:
-    PyObject* self;
-  public:
-    inline Director() : self(NULL) {}
-    inline void setPyObjectForDirector(PyObject* pyargself) { self = pyargself; }
-  };
-
-  /**
-   * This exception is thrown from Director calls that call into python when the 
-   * Python error is 
-   */
-  class PythonToCppException : public XbmcCommons::UncheckedException
-  {
-  public:
-    /**
-     * Assuming a PyErr_Occurred, this will fill the exception message with all
-     *  of the appropriate information including the traceback if it can be
-     *  obtained. It will also clear the python message.
-     */
-    PythonToCppException();
-    PythonToCppException(const std::string &exceptionType, const std::string &exceptionValue, const std::string &exceptionTraceback);
-
-    static bool ParsePythonException(std::string &exceptionType, std::string &exceptionValue, std::string &exceptionTraceback);
-
-  protected:
-    void SetMessage(const std::string &exceptionType, const std::string &exceptionValue, const std::string &exceptionTraceback);
-  };
-
-  template<class T> struct PythonCompare
-  {
-    static inline int compare(PyObject* obj1, PyObject* obj2, const char* swigType, const char* methodNamespacePrefix, const char* methodNameForErrorString)
-    {
-      XBMC_TRACE;
-      try
-      {
-        T* o1 = (T*)retrieveApiInstance(obj1, swigType, methodNamespacePrefix, methodNameForErrorString);
-        T* o2 = (T*)retrieveApiInstance(obj2, swigType, methodNamespacePrefix, methodNameForErrorString);
-
-        return ((*o1) < (*o2) ? -1 : 
-                ((*o1) > (*o2) ? 1 : 0));
-      }
-      catch (const XBMCAddon::WrongTypeException& e)
-      {
-        CLog::Log(LOGERROR,"EXCEPTION: %s",e.GetMessage());
-        PyErr_SetString(PyExc_RuntimeError, e.GetMessage());
-      }
-      return -1;
-    }
-  };
-}
diff --git a/xbmc/interfaces/python3/test/CMakeLists.txt b/xbmc/interfaces/python3/test/CMakeLists.txt
deleted file mode 100644
index ec38a51931c7..000000000000
--- a/xbmc/interfaces/python3/test/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-if(PYTHON_FOUND)
-  set(SOURCES TestSwig.cpp)
-
-  core_add_test_library(python_test)
-endif()
diff --git a/xbmc/interfaces/python3/test/TestSwig.cpp b/xbmc/interfaces/python3/test/TestSwig.cpp
deleted file mode 100644
index 73a81ccb6857..000000000000
--- a/xbmc/interfaces/python3/test/TestSwig.cpp
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#include "../swig.h"
-
-#include "gtest/gtest.h"
-
-using namespace PythonBindings;
-
-TEST(TestSwig, TypeConversion)
-{
-  EXPECT_TRUE(isParameterRightType("p.XBMCAddon::xbmcgui::ListItem","p.XBMCAddon::xbmcgui::ListItem","XBMCAddon::xbmc::"));
-  EXPECT_TRUE(isParameterRightType("p.XBMCAddon::xbmc::PlayList","p.PlayList","XBMCAddon::xbmc::"));
-  EXPECT_TRUE(isParameterRightType("p.PlayList","p.XBMCAddon::xbmc::PlayList","XBMCAddon::xbmc::"));
-}
-
diff --git a/xbmc/interfaces/python3/typemaps/python.Alternative.intm b/xbmc/interfaces/python3/typemaps/python.Alternative.intm
deleted file mode 100644
index eaee4f085e89..000000000000
--- a/xbmc/interfaces/python3/typemaps/python.Alternative.intm
+++ /dev/null
@@ -1,55 +0,0 @@
-<%
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-    boolean ispointer = swigTypeParser.SwigType_ispointer(ltype)
-    String accessor = ispointer ? '->' : '.'
-    int seq = sequence.increment()
-    altAccess = [ 'former', 'later' ]
-    altSwitch = [ 'first', 'second' ]
-
-    List types = swigTypeParser.SwigType_templateparmlist(ltype)
-%>
-    {
-      // we need to check the parameter type and see if it matches
-      PyObject *pyentry_${seq} = ${slarg};
-      try
-      {
-        ${swigTypeParser.SwigType_str(swigTypeParser.SwigType_ltype(types[0]))} entry0_${seq};
-        ${helper.getInConversion(types[0], 'entry0' + '_' + seq, 'pyentry' + '_' + seq, method,
-                                 [ 'sequence' : sequence ])}
-        ${api}${accessor}${altAccess[0]}() = entry0_${seq};
-      }
-      catch (const XBMCAddon::WrongTypeException&)
-      {
-        try
-        {
-          ${swigTypeParser.SwigType_str(swigTypeParser.SwigType_ltype(types[1]))} entry1_${seq};
-          ${helper.getInConversion(types[1], 'entry1' + '_' + seq, 'pyentry' + '_' + seq, method,
-                                   [ 'sequence' : sequence ])}
-          ${api}${accessor}${altAccess[1]}() = entry1_${seq};
-        }
-        catch (const XBMCAddon::WrongTypeException&)
-        {
-          throw XBMCAddon::WrongTypeException("Failed to convert to input type to either a " 
-                                              "${swigTypeParser.SwigType_ltype(types[0])} or a "
-                                              "${swigTypeParser.SwigType_ltype(types[1])}" );
-        }
-      }
-    }
\ No newline at end of file
diff --git a/xbmc/interfaces/python3/typemaps/python.Alternative.outtm b/xbmc/interfaces/python3/typemaps/python.Alternative.outtm
deleted file mode 100644
index 5288f756eb4b..000000000000
--- a/xbmc/interfaces/python3/typemaps/python.Alternative.outtm
+++ /dev/null
@@ -1,46 +0,0 @@
-<%
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-    List types = swigTypeParser.SwigType_templateparmlist(type)
-    boolean ispointer = swigTypeParser.SwigType_ispointer(type)
-    int seq = sequence.increment()
-    String accessor = ispointer ? '->' : '.'
-    altAccess = [ 'former', 'later' ]
-    altSwitch = [ 'first', 'second' ]
-%>
-    WhichAlternative pos = ${api}${accessor}which();
-
-    if (<%if (ispointer) { %>${api} != NULL && <%}%>pos != XBMCAddon::none)
-    { <%
-      types.eachWithIndex { curType, entryIndex -> 
-%>
-      if (pos == XBMCAddon::${altSwitch[entryIndex]})
-      {
-        ${swigTypeParser.SwigType_str(swigTypeParser.SwigType_ltype(curType))}& entry${seq} = ${api}${accessor}${altAccess[entryIndex]}();
-        {
-          ${helper.getOutConversion(curType,result,method,[ 'api' : 'entry' + seq, 'sequence' : sequence ])}
-        }
-      }
-<%
-        }
-%>
-    }
-    else
-      ${result} = Py_None;
\ No newline at end of file
diff --git a/xbmc/interfaces/python3/typemaps/python.Tuple.intm b/xbmc/interfaces/python3/typemaps/python.Tuple.intm
deleted file mode 100644
index 50567f39051a..000000000000
--- a/xbmc/interfaces/python3/typemaps/python.Tuple.intm
+++ /dev/null
@@ -1,47 +0,0 @@
-<%
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-    List types = swigTypeParser.SwigType_templateparmlist(ltype)
-    boolean ispointer = swigTypeParser.SwigType_ispointer(type)
-    String accessor = ispointer ? '->' : '.'
-    int seq = sequence.increment()
-    tupleAccess = [ 'first', 'second', 'third', 'fourth' ]
-%>
-    if(${slarg})
-    {
-      bool isTuple = PyObject_TypeCheck(${slarg},&PyTuple_Type);
-      if (!isTuple && !PyObject_TypeCheck(${slarg},&PyList_Type))
-        throw WrongTypeException("The parameter \"${api}\" must be either a Tuple or a List.");
-      int vecSize = (isTuple ? PyTuple_Size(${slarg}) : PyList_Size(${slarg}));
-<%
-      types.eachWithIndex { curType, entryIndex ->
-%>
-      if (vecSize > ${entryIndex})
-      {
-        PyObject *pyentry${entryIndex}_${seq} = NULL;
-        pyentry${entryIndex}_${seq} = (isTuple ? PyTuple_GetItem(${slarg}, ${entryIndex}) : PyList_GetItem(${slarg}, ${entryIndex}));
-        ${swigTypeParser.SwigType_str(swigTypeParser.SwigType_ltype(curType))} entry${entryIndex}_${seq};
-        ${helper.getInConversion(curType, 'entry' + entryIndex + '_' + seq, 'pyentry' + entryIndex + '_' + seq, method,[ 'sequence' : sequence ])}
-        ${api}${accessor}${tupleAccess[entryIndex]}() = entry${entryIndex}_${seq};
-      }
-<%
-      }
-%>
-    }
diff --git a/xbmc/interfaces/python3/typemaps/python.Tuple.outtm b/xbmc/interfaces/python3/typemaps/python.Tuple.outtm
deleted file mode 100644
index 02a6cd5e4e21..000000000000
--- a/xbmc/interfaces/python3/typemaps/python.Tuple.outtm
+++ /dev/null
@@ -1,51 +0,0 @@
-<%
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-    List types = swigTypeParser.SwigType_templateparmlist(type)
-    boolean ispointer = swigTypeParser.SwigType_ispointer(type)
-    int seq = sequence.increment()
-    String accessor = ispointer ? '->' : '.'
-    tupleAccess = [ 'first', 'second', 'third', 'fourth' ]
-%>
-    int vecSize = ${api}${accessor}GetNumValuesSet();
-    ${result} = PyTuple_New(vecSize);
-<%
-    if (ispointer)
-    {
-%>
-    if (${api} != NULL)
-<%  }  // this ends the if (ispointer)
-%>    {
-      PyObject* pyentry${seq}; <%
-      types.eachWithIndex { curType, entryIndex -> 
-%>
-
-      if (vecSize > ${entryIndex})
-      {
-        ${swigTypeParser.SwigType_str(swigTypeParser.SwigType_ltype(curType))}& entry${seq} = ${api}${accessor}${tupleAccess[entryIndex]}();
-        {
-          ${helper.getOutConversion(curType,'result',method,[ 'result' : 'pyentry' + seq, 'api' : 'entry' + seq, 'sequence' : sequence ])}
-        }
-        PyTuple_SetItem(${result}, ${entryIndex}, pyentry${seq});
-      }
-<%
-        }
-%>
-    }
\ No newline at end of file
diff --git a/xbmc/interfaces/python3/typemaps/python.buffer.intm b/xbmc/interfaces/python3/typemaps/python.buffer.intm
deleted file mode 100644
index 89b387c5cc2f..000000000000
--- a/xbmc/interfaces/python3/typemaps/python.buffer.intm
+++ /dev/null
@@ -1,38 +0,0 @@
-<%
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-%>
-    if (PyUnicode_Check(${slarg}))
-    {
-      const char* str = PyUnicode_AsUTF8(${slarg});
-      size_t size = (size_t)PyUnicode_GetLength(${slarg});
-      ${api}.allocate(size);
-      ${api}.put(str,size);
-      ${api}.flip(); // prepare the buffer for reading from
-    }
-    else if (PyByteArray_Check(${slarg}))
-    {
-      size_t size = PyByteArray_Size(${slarg});
-      ${api}.allocate(size);
-      ${api}.put(PyByteArray_AsString(${slarg}),size);
-      ${api}.flip(); // prepare the buffer for reading from
-    }
-    else
-      throw XBMCAddon::WrongTypeException("argument \"%s\" for \"%s\" must be a string or a bytearray", "${api}", "${method.@name}");
diff --git a/xbmc/interfaces/python3/typemaps/python.buffer.outtm b/xbmc/interfaces/python3/typemaps/python.buffer.outtm
deleted file mode 100644
index 758ebd6e8a5e..000000000000
--- a/xbmc/interfaces/python3/typemaps/python.buffer.outtm
+++ /dev/null
@@ -1,23 +0,0 @@
-<%
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-    boolean ispointer = swigTypeParser.SwigType_ispointer(type)
-    String accessor = ispointer ? '->' : '.'
-%>${result} = PyByteArray_FromStringAndSize((char*)${api}${accessor}curPosition(),${api}${accessor}remaining());
\ No newline at end of file
diff --git a/xbmc/interfaces/python3/typemaps/python.dict.intm b/xbmc/interfaces/python3/typemaps/python.dict.intm
deleted file mode 100644
index 2d6ca9f8a9a1..000000000000
--- a/xbmc/interfaces/python3/typemaps/python.dict.intm
+++ /dev/null
@@ -1,35 +0,0 @@
-<%
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-    List templateArgs = swigTypeParser.SwigType_templateparmlist(ltype)
-    valtype = templateArgs[0]
-%>
-    {
-      PyObject *pykey, *pyvalue;
-      Py_ssize_t pos = 0;
-      while(PyDict_Next(${slarg}, &pos, &pykey, &pyvalue))
-      {
-        std::string key;
-        PyXBMCGetUnicodeString(key,pykey,false,"${api}","${method.@name}");
-        ${swigTypeParser.SwigType_str(swigTypeParser.SwigType_ltype(valtype))} value;
-        ${helper.getInConversion(valtype, 'value', 'pyvalue' ,method)}
-        ${api}[key] = value;
-      }
-    }
\ No newline at end of file
diff --git a/xbmc/interfaces/python3/typemaps/python.map.intm b/xbmc/interfaces/python3/typemaps/python.map.intm
deleted file mode 100644
index 612295332868..000000000000
--- a/xbmc/interfaces/python3/typemaps/python.map.intm
+++ /dev/null
@@ -1,36 +0,0 @@
-<%
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-    List templateArgs = swigTypeParser.SwigType_templateparmlist(ltype)
-    keytype = templateArgs[0]
-    valtype = templateArgs[1]
-%>
-    {
-      PyObject *pykey, *pyvalue;
-      Py_ssize_t pos = 0;
-      while(PyDict_Next(${slarg}, &pos, &pykey, &pyvalue))
-      {
-        ${swigTypeParser.SwigType_str(swigTypeParser.SwigType_ltype(keytype))} key;
-        ${swigTypeParser.SwigType_str(swigTypeParser.SwigType_ltype(valtype))} value;
-        ${helper.getInConversion(keytype, 'key', 'pykey', method)}
-        ${helper.getInConversion(valtype, 'value', 'pyvalue' ,method)}
-        ${api}[key] = value;
-      }
-    }
\ No newline at end of file
diff --git a/xbmc/interfaces/python3/typemaps/python.smart_ptr.outtm b/xbmc/interfaces/python3/typemaps/python.smart_ptr.outtm
deleted file mode 100644
index a92b16036aa1..000000000000
--- a/xbmc/interfaces/python3/typemaps/python.smart_ptr.outtm
+++ /dev/null
@@ -1,26 +0,0 @@
-<%
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-    itype = swigTypeParser.SwigType_templateparmlist(type)[0]
-    pointertype = swigTypeParser.SwigType_makepointer(itype)
-    int seq = sequence.increment()
-%>
-    ${swigTypeParser.SwigType_str(swigTypeParser.SwigType_ltype(pointertype))} entry${seq} = ${api}.get();
-    ${helper.getOutConversion(pointertype,'result',method,[ 'api' : 'entry' + seq, 'sequence' : sequence ])}
diff --git a/xbmc/interfaces/python3/typemaps/python.string.outtm b/xbmc/interfaces/python3/typemaps/python.string.outtm
deleted file mode 100644
index ebb2a1235355..000000000000
--- a/xbmc/interfaces/python3/typemaps/python.string.outtm
+++ /dev/null
@@ -1,23 +0,0 @@
-<%
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-%>${result} = <%
-  if(method.@feature_python_coerceToUnicode) { %>PyUnicode_DecodeUTF8(${api}.c_str(),${api}.size(),"replace");<% }
-  else { %>PyUnicode_FromStringAndSize(${api}.c_str(), ${api}.length());<% } %>
diff --git a/xbmc/interfaces/python3/typemaps/python.vector.intm b/xbmc/interfaces/python3/typemaps/python.vector.intm
deleted file mode 100644
index 42cbc6d8dd83..000000000000
--- a/xbmc/interfaces/python3/typemaps/python.vector.intm
+++ /dev/null
@@ -1,47 +0,0 @@
-<%
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-    List templateArgs = swigTypeParser.SwigType_templateparmlist(ltype)
-    vectype = templateArgs[0]
-    boolean ispointer = swigTypeParser.SwigType_ispointer(type)
-    String accessor = ispointer ? '->' : '.'
-    int seq = sequence.increment()
-%>
-    if (${slarg})
-    {
-      bool isTuple = PyObject_TypeCheck(${slarg},&PyTuple_Type);
-      if (!isTuple && !PyObject_TypeCheck(${slarg},&PyList_Type))
-        throw WrongTypeException("The parameter \"${api}\" must be either a Tuple or a List.");
-
-      <%  if (ispointer) print("${api} = new std::vector<${swigTypeParser.SwigType_str(vectype)}>();") %>
-      PyObject *pyentry${seq} = NULL;
-      int vecSize = (isTuple ? PyTuple_Size(${slarg}) : PyList_Size(${slarg}));
-      for(int i = 0; i < vecSize; i++)
-      {
-        pyentry${seq} = (isTuple ? PyTuple_GetItem(${slarg}, i) : PyList_GetItem(${slarg}, i));
-        ${swigTypeParser.SwigType_str(swigTypeParser.SwigType_ltype(vectype))} entry${seq};
-        ${helper.getInConversion(vectype, 'entry' + seq, 'pyentry' + seq, method,
-                                 [ 'type' : vectype,
-                                   'ltype' : swigTypeParser.SwigType_ltype(vectype),
-                                   'sequence' : sequence
-                                   ])}
-        ${api}${accessor}push_back(entry${seq});
-      }
-    }
diff --git a/xbmc/interfaces/python3/typemaps/python.vector.outtm b/xbmc/interfaces/python3/typemaps/python.vector.outtm
deleted file mode 100644
index 941204ea7981..000000000000
--- a/xbmc/interfaces/python3/typemaps/python.vector.outtm
+++ /dev/null
@@ -1,48 +0,0 @@
-<%
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-    List templateArgs = swigTypeParser.SwigType_templateparmlist(type)
-    vectype = templateArgs[0]
-    boolean ispointer = swigTypeParser.SwigType_ispointer(type)
-    String accessor = ispointer ? '->' : '.'
-    seq = sequence.increment()
-
-    if (ispointer)
-    {
-%>
-    if (${api} != NULL)
-    { 
-<%  }  %>
-      ${result} = PyList_New(0);
-
-      for (std::vector<${swigTypeParser.SwigType_str(vectype)}>::iterator iter = ${api}${accessor}begin(); iter != ${api}${accessor}end(); ++iter)
-      {
-        ${swigTypeParser.SwigType_str(swigTypeParser.SwigType_ltype(vectype))}& entry${seq} = *iter;
-        PyObject* pyentry${seq};
-        ${helper.getOutConversion(vectype,'result',method,[ 'result' : 'pyentry' + seq, 'api' : 'entry' + seq, 'sequence' : sequence ])}
-        PyList_Append(${result}, pyentry${seq});
-        Py_DECREF(pyentry${seq});
-      }
-<%
-    if (ispointer)
-    {
-%>
-    }
-<%  }  %>
diff --git a/xbmc/network/httprequesthandler/python/HTTPPythonWsgiInvoker.cpp b/xbmc/network/httprequesthandler/python/HTTPPythonWsgiInvoker.cpp
index 69a9bea7d69a..f69a9ba876a0 100644
--- a/xbmc/network/httprequesthandler/python/HTTPPythonWsgiInvoker.cpp
+++ b/xbmc/network/httprequesthandler/python/HTTPPythonWsgiInvoker.cpp
@@ -18,6 +18,8 @@
  *
  */
 
+#include <Python.h>
+
 #include "HTTPPythonWsgiInvoker.h"
 
 #include <utility>
@@ -30,7 +32,7 @@
 #include "URL.h"
 #include "utils/URIUtils.h"
 
-#define MODULE      "xbmc"
+#define MODULE "xbmc"
 
 #define RUNSCRIPT_PREAMBLE \
   "" \
@@ -52,14 +54,14 @@
 
 #define RUNSCRIPT_SETUPTOOLS_HACK \
   "" \
-  "import imp,sys\n" \
+  "import types,sys\n" \
   "pkg_resources_code = \\\n" \
   "\"\"\"\n" \
   "def resource_filename(__name__,__path__):\n" \
   "  return __path__\n" \
   "\"\"\"\n" \
-  "pkg_resources = imp.new_module('pkg_resources')\n" \
-  "exec pkg_resources_code in pkg_resources.__dict__\n" \
+  "pkg_resources = types.ModuleType('pkg_resources')\n" \
+  "exec(pkg_resources_code, pkg_resources.__dict__)\n" \
   "sys.modules['pkg_resources'] = pkg_resources\n" \
   ""
 
@@ -76,8 +78,8 @@
 #endif
 
 namespace PythonBindings {
-  void initModule_xbmc(void);
-  void initModule_xbmcwsgi(void);
+  PyObject* PyInit_Module_xbmc(void);
+  PyObject* PyInit_Module_xbmcwsgi(void);
 }
 
 using namespace PythonBindings;
@@ -90,8 +92,8 @@ typedef struct
 
 static PythonModule PythonModules[] =
 {
-  { "xbmc",           initModule_xbmc },
-  { "xbmcwsgi",       initModule_xbmcwsgi }
+  { "xbmc",           PyInit_Module_xbmc },
+  { "xbmcwsgi",       PyInit_Module_xbmcwsgi }
 };
 
 #define PythonModulesSize sizeof(PythonModules) / sizeof(PythonModule)
@@ -99,7 +101,10 @@ static PythonModule PythonModules[] =
 CHTTPPythonWsgiInvoker::CHTTPPythonWsgiInvoker(ILanguageInvocationHandler* invocationHandler, HTTPPythonRequest* request)
   : CHTTPPythonInvoker(invocationHandler, request),
     m_wsgiResponse(NULL)
-{ }
+{
+    PyImport_AppendInittab("xbmc",     PyInit_Module_xbmc);
+    PyImport_AppendInittab("xbmcwsgi", PyInit_Module_xbmcwsgi);
+}
 
 CHTTPPythonWsgiInvoker::~CHTTPPythonWsgiInvoker()
 {
@@ -146,7 +151,7 @@ void CHTTPPythonWsgiInvoker::executeScript(void *fp, const std::string &script,
   // get the script
   std::string scriptName = URIUtils::GetFileName(script);
   URIUtils::RemoveExtension(scriptName);
-  pyScript = PyString_FromStringAndSize(scriptName.c_str(), scriptName.size());
+  pyScript = PyUnicode_FromStringAndSize(scriptName.c_str(), scriptName.size());
   if (pyScript == NULL)
   {
     CLog::Log(LOGERROR, "CHTTPPythonWsgiInvoker: failed to convert script \"%s\" to python string", script.c_str());
@@ -199,7 +204,7 @@ void CHTTPPythonWsgiInvoker::executeScript(void *fp, const std::string &script,
     pyEnviron = PyDict_New();
     for (std::map<std::string, std::string>::const_iterator cgiEnv = cgiEnvironment.begin(); cgiEnv != cgiEnvironment.end(); ++cgiEnv)
     {
-      PyObject* pyEnvEntry = PyString_FromStringAndSize(cgiEnv->second.c_str(), cgiEnv->second.size());
+      PyObject* pyEnvEntry = PyUnicode_FromStringAndSize(cgiEnv->second.c_str(), cgiEnv->second.size());
       PyDict_SetItemString(pyEnviron, cgiEnv->first.c_str(), pyEnvEntry);
       Py_DECREF(pyEnvEntry);
     }
@@ -406,7 +411,7 @@ void CHTTPPythonWsgiInvoker::addWsgiEnvironment(HTTPPythonRequest* request, void
   }
   {
     // wsgi.url_scheme
-    PyObject* pyValue = PyString_FromStringAndSize("http", 4);
+    PyObject* pyValue = PyUnicode_FromStringAndSize("http", 4);
     PyDict_SetItemString(pyEnviron, "wsgi.url_scheme", pyValue);
     Py_DECREF(pyValue);
   }
diff --git a/xbmc/network/httprequesthandler/python3/CMakeLists.txt b/xbmc/network/httprequesthandler/python3/CMakeLists.txt
deleted file mode 100644
index 7bbbad9b4d35..000000000000
--- a/xbmc/network/httprequesthandler/python3/CMakeLists.txt
+++ /dev/null
@@ -1,10 +0,0 @@
-if(MICROHTTPD_FOUND AND PYTHON_FOUND)
-  set(SOURCES HTTPPythonInvoker.cpp
-              HTTPPythonWsgiInvoker.cpp)
-
-  set(HEADERS HTTPPythonInvoker.h
-              HTTPPythonRequest.h
-              HTTPPythonWsgiInvoker.h)
-
-  core_add_library(network_httprequesthandlers_python)
-endif()
diff --git a/xbmc/network/httprequesthandler/python3/HTTPPythonInvoker.cpp b/xbmc/network/httprequesthandler/python3/HTTPPythonInvoker.cpp
deleted file mode 100644
index f59986a3ca22..000000000000
--- a/xbmc/network/httprequesthandler/python3/HTTPPythonInvoker.cpp
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- *      Copyright (C) 2015 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#include "HTTPPythonInvoker.h"
-#include "CompileInfo.h"
-#include "utils/StringUtils.h"
-
-CHTTPPythonInvoker::CHTTPPythonInvoker(ILanguageInvocationHandler* invocationHandler, HTTPPythonRequest* request)
-  : CPythonInvoker(invocationHandler),
-    m_request(request),
-    m_internalError(false)
-{ }
-
-CHTTPPythonInvoker::~CHTTPPythonInvoker()
-{
-  delete m_request;
-  m_request = NULL;
-}
-
-void CHTTPPythonInvoker::onAbort()
-{
-  if (m_request == NULL)
-    return;
-
-  m_internalError = true;
-  m_request->responseType = HTTPError;
-  m_request->responseStatus = MHD_HTTP_INTERNAL_SERVER_ERROR;
-}
-
-void CHTTPPythonInvoker::onError(const std::string& exceptionType /* = "" */, const std::string& exceptionValue /* = "" */, const std::string& exceptionTraceback /* = "" */)
-{
-  if (m_request == NULL)
-    return;
-
-  m_internalError = true;
-  m_request->responseType = HTTPMemoryDownloadNoFreeCopy;
-  m_request->responseStatus = MHD_HTTP_INTERNAL_SERVER_ERROR;
-
-  std::string output;
-  if (!exceptionType.empty())
-  {
-    output += exceptionType;
-
-    if (!exceptionValue.empty())
-      output += ": " + exceptionValue;
-    output += "\n";
-  }
-
-  if (!exceptionTraceback .empty())
-    output += exceptionTraceback;
-
-  // replace all special characters
-
-  StringUtils::Replace(output, "<", "&lt;");
-  StringUtils::Replace(output, ">", "&gt;");
-  StringUtils::Replace(output, " ", "&nbsp;");
-  StringUtils::Replace(output, "\n", "\n<br />");
-
-  if (!exceptionType.empty())
-  {
-    // now make the type and value bold (needs to be done here because otherwise the < and > would have been replaced
-    output = "<b>" + output;
-    output.insert(output.find('\n'), "</b>");
-  }
-
-  m_request->responseData = "<html><head><title>" + std::string(CCompileInfo::GetAppName()) + ": python error</title></head><body>" + output + "</body></html>";
-}
diff --git a/xbmc/network/httprequesthandler/python3/HTTPPythonInvoker.h b/xbmc/network/httprequesthandler/python3/HTTPPythonInvoker.h
deleted file mode 100644
index a09919c602e0..000000000000
--- a/xbmc/network/httprequesthandler/python3/HTTPPythonInvoker.h
+++ /dev/null
@@ -1,44 +0,0 @@
-#pragma once
-/*
-*      Copyright (C) 2015 Team XBMC
-*      http://xbmc.org
-*
-*  This Program is free software; you can redistribute it and/or modify
-*  it under the terms of the GNU General Public License as published by
-*  the Free Software Foundation; either version 2, or (at your option)
-*  any later version.
-*
-*  This Program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-*  GNU General Public License for more details.
-*
-*  You should have received a copy of the GNU General Public License
-*  along with XBMC; see the file COPYING.  If not, see
-*  <http://www.gnu.org/licenses/>.
-*
-*/
-
-#include <string>
-
-#include "interfaces/python/PythonInvoker.h"
-#include "network/httprequesthandler/IHTTPRequestHandler.h"
-#include "network/httprequesthandler/python/HTTPPythonRequest.h"
-
-class CHTTPPythonInvoker : public CPythonInvoker
-{
-public:
-  ~CHTTPPythonInvoker() override;
-
-  virtual HTTPPythonRequest* GetRequest() = 0;
-
-protected:
-  CHTTPPythonInvoker(ILanguageInvocationHandler* invocationHandler, HTTPPythonRequest* request);
-
-  // overrides of CPythonInvoker
-  void onAbort() override;
-  void onError(const std::string& exceptionType = "", const std::string& exceptionValue = "", const std::string& exceptionTraceback = "") override;
-
-  HTTPPythonRequest* m_request;
-  bool m_internalError;
-};
diff --git a/xbmc/network/httprequesthandler/python3/HTTPPythonRequest.h b/xbmc/network/httprequesthandler/python3/HTTPPythonRequest.h
deleted file mode 100644
index 485c7382111f..000000000000
--- a/xbmc/network/httprequesthandler/python3/HTTPPythonRequest.h
+++ /dev/null
@@ -1,54 +0,0 @@
-#pragma once
-/*
- *      Copyright (C) 2015 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#include <stdint.h>
-
-#include <map>
-#include <string>
-
-#include "XBDateTime.h"
-#include "network/httprequesthandler/IHTTPRequestHandler.h"
-
-typedef struct HTTPPythonRequest
-{
-  struct MHD_Connection *connection;
-  std::string hostname;
-  uint16_t port;
-  std::string url;
-  std::string path;
-  std::string file;
-  HTTPMethod method;
-  std::string version;
-  std::multimap<std::string, std::string> headerValues;
-  std::map<std::string, std::string> getValues;
-  std::map<std::string, std::string> postValues;
-  std::string requestContent;
-  CDateTime requestTime;
-  CDateTime lastModifiedTime;
-
-  HTTPResponseType responseType;
-  int responseStatus;
-  std::string responseContentType;
-  std::string responseData;
-  size_t responseLength;
-  std::multimap<std::string, std::string> responseHeaders;
-  std::multimap<std::string, std::string> responseHeadersError;
-} HTTPPythonRequest;
\ No newline at end of file
diff --git a/xbmc/network/httprequesthandler/python3/HTTPPythonWsgiInvoker.cpp b/xbmc/network/httprequesthandler/python3/HTTPPythonWsgiInvoker.cpp
deleted file mode 100644
index f69a9ba876a0..000000000000
--- a/xbmc/network/httprequesthandler/python3/HTTPPythonWsgiInvoker.cpp
+++ /dev/null
@@ -1,458 +0,0 @@
-/*
- *      Copyright (C) 2015 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#include <Python.h>
-
-#include "HTTPPythonWsgiInvoker.h"
-
-#include <utility>
-
-#include "addons/Webinterface.h"
-#include "interfaces/legacy/wsgi/WsgiErrorStream.h"
-#include "interfaces/legacy/wsgi/WsgiInputStream.h"
-#include "interfaces/legacy/wsgi/WsgiResponse.h"
-#include "interfaces/python/swig.h"
-#include "URL.h"
-#include "utils/URIUtils.h"
-
-#define MODULE "xbmc"
-
-#define RUNSCRIPT_PREAMBLE \
-  "" \
-  "import " MODULE "\n" \
-  "xbmc.abortRequested = False\n" \
-  "class xbmcout:\n" \
-  "  def __init__(self, loglevel=" MODULE ".LOGNOTICE):\n" \
-  "    self.ll=loglevel\n" \
-  "  def write(self, data):\n" \
-  "    " MODULE ".log(data,self.ll)\n" \
-  "  def close(self):\n" \
-  "    " MODULE ".log('.')\n" \
-  "  def flush(self):\n" \
-  "    " MODULE ".log('.')\n" \
-  "import sys\n" \
-  "sys.stdout = xbmcout()\n" \
-  "sys.stderr = xbmcout(" MODULE ".LOGERROR)\n" \
-  ""
-
-#define RUNSCRIPT_SETUPTOOLS_HACK \
-  "" \
-  "import types,sys\n" \
-  "pkg_resources_code = \\\n" \
-  "\"\"\"\n" \
-  "def resource_filename(__name__,__path__):\n" \
-  "  return __path__\n" \
-  "\"\"\"\n" \
-  "pkg_resources = types.ModuleType('pkg_resources')\n" \
-  "exec(pkg_resources_code, pkg_resources.__dict__)\n" \
-  "sys.modules['pkg_resources'] = pkg_resources\n" \
-  ""
-
-#define RUNSCRIPT_POSTSCRIPT \
-        MODULE ".log('-->HTTP Python WSGI Interpreter Initialized<--', " MODULE ".LOGNOTICE)\n" \
-        ""
-
-#if defined(TARGET_ANDROID)
-#define RUNSCRIPT \
-  RUNSCRIPT_PREAMBLE RUNSCRIPT_SETUPTOOLS_HACK RUNSCRIPT_POSTSCRIPT
-#else
-#define RUNSCRIPT \
-  RUNSCRIPT_PREAMBLE RUNSCRIPT_POSTSCRIPT
-#endif
-
-namespace PythonBindings {
-  PyObject* PyInit_Module_xbmc(void);
-  PyObject* PyInit_Module_xbmcwsgi(void);
-}
-
-using namespace PythonBindings;
-
-typedef struct
-{
-  const char *name;
-  CPythonInvoker::PythonModuleInitialization initialization;
-} PythonModule;
-
-static PythonModule PythonModules[] =
-{
-  { "xbmc",           PyInit_Module_xbmc },
-  { "xbmcwsgi",       PyInit_Module_xbmcwsgi }
-};
-
-#define PythonModulesSize sizeof(PythonModules) / sizeof(PythonModule)
-
-CHTTPPythonWsgiInvoker::CHTTPPythonWsgiInvoker(ILanguageInvocationHandler* invocationHandler, HTTPPythonRequest* request)
-  : CHTTPPythonInvoker(invocationHandler, request),
-    m_wsgiResponse(NULL)
-{
-    PyImport_AppendInittab("xbmc",     PyInit_Module_xbmc);
-    PyImport_AppendInittab("xbmcwsgi", PyInit_Module_xbmcwsgi);
-}
-
-CHTTPPythonWsgiInvoker::~CHTTPPythonWsgiInvoker()
-{
-  delete m_wsgiResponse;
-  m_wsgiResponse = NULL;
-}
-
-HTTPPythonRequest* CHTTPPythonWsgiInvoker::GetRequest()
-{
-  if (m_request == NULL || m_wsgiResponse == NULL)
-    return NULL;
-
-  if (m_internalError)
-    return m_request;
-
-  m_wsgiResponse->Finalize(m_request);
-  return m_request;
-}
-
-void CHTTPPythonWsgiInvoker::executeScript(void *fp, const std::string &script, void *module, void *moduleDict)
-{
-  if (m_request == NULL || m_addon == NULL || m_addon->Type() != ADDON::ADDON_WEB_INTERFACE ||
-      fp == NULL || script.empty() || module == NULL || moduleDict == NULL)
-    return;
-
-  ADDON::CWebinterface* webinterface = static_cast<ADDON::CWebinterface*>(m_addon.get());
-  if (webinterface->GetType() != ADDON::WebinterfaceTypeWsgi)
-  {
-    CLog::Log(LOGERROR, "CHTTPPythonWsgiInvoker: trying to execute a non-WSGI script at %s", script.c_str());
-    return;
-  }
-
-  PyObject* pyScript = NULL;
-  PyObject* pyModule = NULL;
-  PyObject* pyEntryPoint = NULL;
-  std::map<std::string, std::string> cgiEnvironment;
-  PyObject* pyEnviron = NULL;
-  PyObject* pyStart_response = NULL;
-  PyObject* pyArgs = NULL;
-  PyObject* pyResult = NULL;
-  PyObject* pyResultIterator = NULL;
-  PyObject* pyIterResult = NULL;
-
-  // get the script
-  std::string scriptName = URIUtils::GetFileName(script);
-  URIUtils::RemoveExtension(scriptName);
-  pyScript = PyUnicode_FromStringAndSize(scriptName.c_str(), scriptName.size());
-  if (pyScript == NULL)
-  {
-    CLog::Log(LOGERROR, "CHTTPPythonWsgiInvoker: failed to convert script \"%s\" to python string", script.c_str());
-    return;
-  }
-
-  // load the script
-  CLog::Log(LOGDEBUG, "CHTTPPythonWsgiInvoker: loading WSGI script \"%s\"", script.c_str());
-  pyModule = PyImport_Import(pyScript);
-  Py_DECREF(pyScript);
-  if (pyModule == NULL)
-  {
-    CLog::Log(LOGERROR, "CHTTPPythonWsgiInvoker: failed to load WSGI script \"%s\"", script.c_str());
-    return;
-  }
-
-  // get the entry point
-  const std::string& entryPoint = webinterface->EntryPoint();
-  CLog::Log(LOGDEBUG, "CHTTPPythonWsgiInvoker: loading entry point \"%s\" from WSGI script \"%s\"", entryPoint.c_str(), script.c_str());
-  pyEntryPoint = PyObject_GetAttrString(pyModule, entryPoint.c_str());
-  if (pyEntryPoint == NULL)
-  {
-    CLog::Log(LOGERROR, "CHTTPPythonWsgiInvoker: failed to entry point \"%s\" from WSGI script \"%s\"", entryPoint.c_str(), script.c_str());
-    goto cleanup;
-  }
-
-  // check if the loaded entry point is a callable function
-  if (!PyCallable_Check(pyEntryPoint))
-  {
-    CLog::Log(LOGERROR, "CHTTPPythonWsgiInvoker: defined entry point \"%s\" from WSGI script \"%s\" is not callable", entryPoint.c_str(), script.c_str());
-    goto cleanup;
-  }
-
-  // prepare the WsgiResponse object
-  m_wsgiResponse = new XBMCAddon::xbmcwsgi::WsgiResponse();
-  if (m_wsgiResponse == NULL)
-  {
-    CLog::Log(LOGERROR, "CHTTPPythonWsgiInvoker: failed to create WsgiResponse object for WSGI script \"%s\"", script.c_str());
-    goto cleanup;
-  }
-
-  try
-  {
-    // prepare the start_response callable
-    pyStart_response = PythonBindings::makePythonInstance(m_wsgiResponse, true);
-
-    // create the (CGI) environment dictionary
-    cgiEnvironment = createCgiEnvironment(m_request, m_addon);
-    // and turn it into a python dictionary
-    pyEnviron = PyDict_New();
-    for (std::map<std::string, std::string>::const_iterator cgiEnv = cgiEnvironment.begin(); cgiEnv != cgiEnvironment.end(); ++cgiEnv)
-    {
-      PyObject* pyEnvEntry = PyUnicode_FromStringAndSize(cgiEnv->second.c_str(), cgiEnv->second.size());
-      PyDict_SetItemString(pyEnviron, cgiEnv->first.c_str(), pyEnvEntry);
-      Py_DECREF(pyEnvEntry);
-    }
-
-    // add the WSGI-specific environment variables
-    addWsgiEnvironment(m_request, pyEnviron);
-  }
-  catch (const XBMCAddon::WrongTypeException& e)
-  {
-    CLog::Log(LOGERROR, "CHTTPPythonWsgiInvoker: failed to prepare WsgiResponse object for WSGI script \"%s\" with wrong type exception: %s", script.c_str(), e.GetMessage());
-    goto cleanup;
-  }
-  catch (const XbmcCommons::Exception& e)
-  {
-    CLog::Log(LOGERROR, "CHTTPPythonWsgiInvoker: failed to prepare WsgiResponse object for WSGI script \"%s\" with exception: %s", script.c_str(), e.GetMessage());
-    goto cleanup;
-  }
-  catch (...)
-  {
-    CLog::Log(LOGERROR, "CHTTPPythonWsgiInvoker: failed to prepare WsgiResponse object for WSGI script \"%s\" with unknown exception", script.c_str());
-    goto cleanup;
-  }
-
-  // put together the arguments
-  pyArgs = PyTuple_Pack(2, pyEnviron, pyStart_response);
-  Py_DECREF(pyEnviron);
-  Py_DECREF(pyStart_response);
-
-  // call the given handler with the prepared arguments
-  pyResult = PyObject_CallObject(pyEntryPoint, pyArgs);
-  Py_DECREF(pyArgs);
-  if (pyResult == NULL)
-  {
-    CLog::Log(LOGERROR, "CHTTPPythonWsgiInvoker: no result for WSGI script \"%s\"", script.c_str());
-    goto cleanup;
-  }
-
-  // try to get an iterator from the result object
-  pyResultIterator = PyObject_GetIter(pyResult);
-  if (pyResultIterator == NULL || !PyIter_Check(pyResultIterator))
-  {
-    CLog::Log(LOGERROR, "CHTTPPythonWsgiInvoker: result of WSGI script \"%s\" is not iterable", script.c_str());
-    goto cleanup;
-  }
-
-  // go through all the iterables in the result and turn them into strings
-  while ((pyIterResult = PyIter_Next(pyResultIterator)) != NULL)
-  {
-    std::string result;
-    try
-    {
-      PythonBindings::PyXBMCGetUnicodeString(result, pyIterResult, false, "result", "handle_request");
-    }
-    catch (const XBMCAddon::WrongTypeException& e)
-    {
-      CLog::Log(LOGERROR, "CHTTPPythonWsgiInvoker: failed to parse result iterable object for WSGI script \"%s\" with wrong type exception: %s", script.c_str(), e.GetMessage());
-      goto cleanup;
-    }
-    catch (const XbmcCommons::Exception& e)
-    {
-      CLog::Log(LOGERROR, "CHTTPPythonWsgiInvoker: failed to parse result iterable object for WSGI script \"%s\" with exception: %s", script.c_str(), e.GetMessage());
-      goto cleanup;
-    }
-    catch (...)
-    {
-      CLog::Log(LOGERROR, "CHTTPPythonWsgiInvoker: failed to parse result iterable object for WSGI script \"%s\" with unknown exception", script.c_str());
-      goto cleanup;
-    }
-
-    // append the result string to the response
-    m_wsgiResponse->Append(result);
-  }
-
-cleanup:
-  if (pyIterResult != NULL)
-  {
-    Py_DECREF(pyIterResult);
-  }
-  if (pyResultIterator != NULL)
-  {
-    // Call optional close method on iterator
-    if (PyObject_HasAttrString(pyResultIterator, (char*)"close") == 1)
-    {
-      if (PyObject_CallMethod(pyResultIterator, (char*)"close", NULL) == NULL)
-        CLog::Log(LOGERROR, "CHTTPPythonWsgiInvoker: failed to close iterator object for WSGI script \"%s\"", script.c_str());
-    }
-    Py_DECREF(pyResultIterator);
-  }
-  if (pyResult != NULL)
-  {
-    Py_DECREF(pyResult);
-  }
-  if (pyEntryPoint != NULL)
-  {
-    Py_DECREF(pyEntryPoint);
-  }
-  if (pyModule != NULL)
-  {
-    Py_DECREF(pyModule);
-  }
-}
-
-std::map<std::string, CPythonInvoker::PythonModuleInitialization> CHTTPPythonWsgiInvoker::getModules() const
-{
-  static std::map<std::string, PythonModuleInitialization> modules;
-  if (modules.empty())
-  {
-    for (size_t i = 0; i < PythonModulesSize; i++)
-      modules.insert(std::make_pair(PythonModules[i].name, PythonModules[i].initialization));
-  }
-
-  return modules;
-}
-
-const char* CHTTPPythonWsgiInvoker::getInitializationScript() const
-{
-  return RUNSCRIPT;
-}
-
-std::map<std::string, std::string> CHTTPPythonWsgiInvoker::createCgiEnvironment(const HTTPPythonRequest* httpRequest, ADDON::AddonPtr addon)
-{
-  std::map<std::string, std::string> environment;
-
-  // REQUEST_METHOD
-  std::string requestMethod;
-  switch (httpRequest->method)
-  {
-  case HEAD:
-    requestMethod = "HEAD";
-    break;
-
-  case POST:
-    requestMethod = "POST";
-    break;
-
-  case GET:
-  default:
-    requestMethod = "GET";
-    break;
-  }
-  environment.insert(std::make_pair("REQUEST_METHOD", requestMethod));
-
-  // SCRIPT_NAME
-  std::string scriptName = std::dynamic_pointer_cast<ADDON::CWebinterface>(addon)->GetBaseLocation();
-  environment.insert(std::make_pair("SCRIPT_NAME", scriptName));
-
-  // PATH_INFO
-  std::string pathInfo = httpRequest->path.substr(scriptName.size());
-  environment.insert(std::make_pair("PATH_INFO", pathInfo));
-
-  // QUERY_STRING
-  CURL url(httpRequest->url);
-  environment.insert(std::make_pair("QUERY_STRING", url.GetOptions()));
-
-  // CONTENT_TYPE
-  std::string headerValue;
-  std::multimap<std::string, std::string>::const_iterator headerIt = httpRequest->headerValues.find(MHD_HTTP_HEADER_CONTENT_TYPE);
-  if (headerIt != httpRequest->headerValues.end())
-    headerValue = headerIt->second;
-  environment.insert(std::make_pair("CONTENT_TYPE", headerValue));
-
-  // CONTENT_LENGTH
-  headerValue.clear();
-  headerIt = httpRequest->headerValues.find(MHD_HTTP_HEADER_CONTENT_LENGTH);
-  if (headerIt != httpRequest->headerValues.end())
-    headerValue = headerIt->second;
-  environment.insert(std::make_pair("CONTENT_LENGTH", headerValue));
-
-  // SERVER_NAME
-  environment.insert(std::make_pair("SERVER_NAME", httpRequest->hostname));
-
-  // SERVER_PORT
-  environment.insert(std::make_pair("SERVER_PORT", StringUtils::Format("%hu", httpRequest->port)));
-
-  // SERVER_PROTOCOL
-  environment.insert(std::make_pair("SERVER_PROTOCOL", httpRequest->version));
-
-  // HTTP_<HEADER_NAME>
-  for (headerIt = httpRequest->headerValues.begin(); headerIt != httpRequest->headerValues.end(); ++headerIt)
-  {
-    std::string headerName = headerIt->first;
-    StringUtils::ToUpper(headerName);
-    environment.insert(std::make_pair("HTTP_" + headerName, headerIt->second));
-  }
-
-  return environment;
-}
-
-void CHTTPPythonWsgiInvoker::addWsgiEnvironment(HTTPPythonRequest* request, void* environment)
-{
-  if (environment == nullptr)
-    return;
-
-  PyObject* pyEnviron = reinterpret_cast<PyObject*>(environment);
-  if (pyEnviron == nullptr)
-    return;
-
-  // WSGI-defined variables
-  {
-    // wsgi.version
-    PyObject* pyValue = Py_BuildValue("(ii)", 1, 0);
-    PyDict_SetItemString(pyEnviron, "wsgi.version", pyValue);
-    Py_DECREF(pyValue);
-  }
-  {
-    // wsgi.url_scheme
-    PyObject* pyValue = PyUnicode_FromStringAndSize("http", 4);
-    PyDict_SetItemString(pyEnviron, "wsgi.url_scheme", pyValue);
-    Py_DECREF(pyValue);
-  }
-  {
-    // wsgi.input
-    XBMCAddon::xbmcwsgi::WsgiInputStream* wsgiInputStream = new XBMCAddon::xbmcwsgi::WsgiInputStream();
-    if (request != NULL)
-      wsgiInputStream->SetRequest(request);
-
-    PythonBindings::prepareForReturn(wsgiInputStream);
-    PyObject* pyWsgiInputStream = PythonBindings::makePythonInstance(wsgiInputStream, false);
-    PyDict_SetItemString(pyEnviron, "wsgi.input", pyWsgiInputStream);
-    Py_DECREF(pyWsgiInputStream);
-  }
-  {
-    // wsgi.errors
-    XBMCAddon::xbmcwsgi::WsgiErrorStream* wsgiErrorStream = new XBMCAddon::xbmcwsgi::WsgiErrorStream();
-    if (request != NULL)
-      wsgiErrorStream->SetRequest(request);
-
-    PythonBindings::prepareForReturn(wsgiErrorStream);
-    PyObject* pyWsgiErrorStream = PythonBindings::makePythonInstance(wsgiErrorStream, false);
-    PyDict_SetItemString(pyEnviron, "wsgi.errors", pyWsgiErrorStream);
-    Py_DECREF(pyWsgiErrorStream);
-  }
-  {
-    // wsgi.multithread
-    PyObject* pyValue = Py_BuildValue("b", false);
-    PyDict_SetItemString(pyEnviron, "wsgi.multithread", pyValue);
-    Py_DECREF(pyValue);
-  }
-  {
-    // wsgi.multiprocess
-    PyObject* pyValue = Py_BuildValue("b", false);
-    PyDict_SetItemString(pyEnviron, "wsgi.multiprocess", pyValue);
-    Py_DECREF(pyValue);
-  }
-  {
-    // wsgi.run_once
-    PyObject* pyValue = Py_BuildValue("b", true);
-    PyDict_SetItemString(pyEnviron, "wsgi.run_once", pyValue);
-    Py_DECREF(pyValue);
-  }
-}
diff --git a/xbmc/network/httprequesthandler/python3/HTTPPythonWsgiInvoker.h b/xbmc/network/httprequesthandler/python3/HTTPPythonWsgiInvoker.h
deleted file mode 100644
index 6231d9644062..000000000000
--- a/xbmc/network/httprequesthandler/python3/HTTPPythonWsgiInvoker.h
+++ /dev/null
@@ -1,58 +0,0 @@
-#pragma once
-/*
-*      Copyright (C) 2015 Team XBMC
-*      http://xbmc.org
-*
-*  This Program is free software; you can redistribute it and/or modify
-*  it under the terms of the GNU General Public License as published by
-*  the Free Software Foundation; either version 2, or (at your option)
-*  any later version.
-*
-*  This Program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-*  GNU General Public License for more details.
-*
-*  You should have received a copy of the GNU General Public License
-*  along with XBMC; see the file COPYING.  If not, see
-*  <http://www.gnu.org/licenses/>.
-*
-*/
-
-#include <map>
-#include <string>
-
-#include "interfaces/python/PythonInvoker.h"
-#include "network/httprequesthandler/IHTTPRequestHandler.h"
-#include "network/httprequesthandler/python/HTTPPythonInvoker.h"
-#include "network/httprequesthandler/python/HTTPPythonRequest.h"
-
-namespace XBMCAddon
-{
-  namespace xbmcwsgi
-  {
-    class WsgiResponse;
-  }
-}
-
-class CHTTPPythonWsgiInvoker : public CHTTPPythonInvoker
-{
-public:
-  CHTTPPythonWsgiInvoker(ILanguageInvocationHandler* invocationHandler, HTTPPythonRequest* request);
-  ~CHTTPPythonWsgiInvoker() override;
-
-  // implementations of CHTTPPythonInvoker
-  HTTPPythonRequest* GetRequest() override;
-
-protected:
-  // overrides of CPythonInvoker
-  void executeScript(void *fp, const std::string &script, void *module, void *moduleDict) override;
-  std::map<std::string, PythonModuleInitialization> getModules() const override;
-  const char* getInitializationScript() const override;
-
-private:
-  static std::map<std::string, std::string> createCgiEnvironment(const HTTPPythonRequest* httpRequest, ADDON::AddonPtr addon);
-  static void addWsgiEnvironment(HTTPPythonRequest* request, void* environment);
-
-  XBMCAddon::xbmcwsgi::WsgiResponse* m_wsgiResponse;
-};

From 45763e37d0c05cbb281112b3343e18a3f8bcfce8 Mon Sep 17 00:00:00 2001
From: Arpit Nandwani <arpit.nandwani@gmail.com>
Date: Sun, 20 Aug 2017 15:51:52 +0530
Subject: [PATCH 10/25] Updated Windows Dependencies

---
 cmake/modules/FindPython.cmake                                | 10 +++++-----
 cmake/scripts/windows/ArchSetup.cmake                         |  2 +-
 project/BuildDependencies/scripts/0_package.target-win32.list |  2 +-
 project/BuildDependencies/scripts/0_package.target-x64.list   |  2 +-
 4 files changed, 8 insertions(+), 8 deletions(-)

diff --git a/cmake/modules/FindPython.cmake b/cmake/modules/FindPython.cmake
index 213b17c62937..260028c57cb4 100644
--- a/cmake/modules/FindPython.cmake
+++ b/cmake/modules/FindPython.cmake
@@ -6,12 +6,12 @@
 # PYTHON_LIBRARIES - The python libraries
 
 if(PKG_CONFIG_FOUND)
-  pkg_check_modules(PC_PYTHON python>=2.7 QUIET)
+  pkg_check_modules(PC_PYTHON python3>=3.4 QUIET)
 endif()
 
-find_program(PYTHON_EXECUTABLE python ONLY_CMAKE_FIND_ROOT_PATH)
-find_library(PYTHON_LIBRARY NAMES python2.7 PATHS ${PC_PYTHON_LIBDIR})
-find_path(PYTHON_INCLUDE_DIR NAMES Python.h PATHS ${PC_PYTHON_INCLUDE_DIRS} ${DEPENDS_PATH}/include/python2.7)
+find_program(PYTHON_EXECUTABLE python3 ONLY_CMAKE_FIND_ROOT_PATH)
+find_library(PYTHON_LIBRARY NAMES python3.6 python3.5 python3.4 PATHS ${PC_PYTHON_LIBDIR})
+find_path(PYTHON_INCLUDE_DIR NAMES Python.h PATHS ${PC_PYTHON_INCLUDE_DIRS})
 
 if(KODI_DEPENDSBUILD)
   find_library(FFI_LIBRARY ffi REQUIRED)
@@ -25,7 +25,7 @@ if(KODI_DEPENDSBUILD)
 
   set(PYTHON_LIBRARIES ${PYTHON_LIBRARY} ${FFI_LIBRARY} ${EXPAT_LIBRARY} ${INTL_LIBRARY} ${GMP_LIBRARY} ${PYTHON_DEP_LIBRARIES})
 else()
-  find_package(PythonLibs 2.7 REQUIRED)
+  find_package(PythonLibs 3.4 REQUIRED)
   list(APPEND PYTHON_LIBRARIES ${PC_PYTHON_STATIC_LIBRARIES})
 endif()
 
diff --git a/cmake/scripts/windows/ArchSetup.cmake b/cmake/scripts/windows/ArchSetup.cmake
index d438b0564314..62d8114c2651 100644
--- a/cmake/scripts/windows/ArchSetup.cmake
+++ b/cmake/scripts/windows/ArchSetup.cmake
@@ -23,7 +23,7 @@ list(APPEND CMAKE_SYSTEM_PREFIX_PATH ${CMAKE_SOURCE_DIR}/project/BuildDependenci
 list(APPEND CMAKE_SYSTEM_LIBRARY_PATH ${CMAKE_SOURCE_DIR}/project/BuildDependencies/mingwlibs/${ARCH}/bin)
 list(APPEND CMAKE_SYSTEM_PREFIX_PATH ${CMAKE_SOURCE_DIR}/project/BuildDependencies/${ARCH})
 list(APPEND CMAKE_SYSTEM_PREFIX_PATH ${CMAKE_SOURCE_DIR}/project/BuildDependencies)
-set(PYTHON_INCLUDE_DIR ${CMAKE_SOURCE_DIR}/project/BuildDependencies/${ARCH}/include/python)
+set(PYTHON_INCLUDE_DIR ${CMAKE_SOURCE_DIR}/project/BuildDependencies/${ARCH}/include/python3.6)
 
 
 # -------- Compiler options ---------
diff --git a/project/BuildDependencies/scripts/0_package.target-win32.list b/project/BuildDependencies/scripts/0_package.target-win32.list
index ee086349b9a2..c22f42e6050a 100644
--- a/project/BuildDependencies/scripts/0_package.target-win32.list
+++ b/project/BuildDependencies/scripts/0_package.target-win32.list
@@ -38,7 +38,7 @@ openssl-1.0.2g-win32-vc140-v2.7z
 pcre-8.37-win32-vc140-v3.7z
 pillow-3.1.0-win32-vc140.7z
 pycryptodome-3.4.3-win32.7z
-python-2.7.13-win32-vc140-v3.7z
+python3-3.6.1-win32-vc140.7z
 rapidjson-1.1.0-win32.7z
 shairplay-0.9.0-win32-vc140-v2.7z
 sqlite-3.10.2-win32-vc140.7z
diff --git a/project/BuildDependencies/scripts/0_package.target-x64.list b/project/BuildDependencies/scripts/0_package.target-x64.list
index 61af8d27c764..540b8ddc03c8 100644
--- a/project/BuildDependencies/scripts/0_package.target-x64.list
+++ b/project/BuildDependencies/scripts/0_package.target-x64.list
@@ -33,7 +33,7 @@ mini_wdk-10.0.14393.0-x64.7z
 mysql-connector-c-6.1.9-x64-vc140.7z
 openssl-1.0.2k-x64-vc140.7z
 pcre-8.40-x64-vc140.7z
-python-2.7.13-x64-vc140-v3.7z
+python3-3.6.1-x64-vc140.7z
 rapidjson-1.1.0-win32.7z
 shairplay-ce80e00-x64-vc140.7z
 sqlite-3.17.0-x64-vc140.7z

From 89c2c6c343aaf7e1cfd1c0f3951bc1f8b4728fb1 Mon Sep 17 00:00:00 2001
From: Arpit Nandwani <arpit.nandwani@gmail.com>
Date: Sun, 20 Aug 2017 16:51:54 +0530
Subject: [PATCH 11/25] Native Files Updated

---
 tools/depends/native/Makefile                                 | 10 +++++-----
 tools/depends/native/distribute-native/Makefile               |  2 +-
 tools/depends/native/distutilscross-native/Makefile           |  5 +++--
 tools/depends/native/distutilscross-native/python3.patch      | 11 +++++++++++
 .../native/{python27-native => python36-native}/Makefile      |  7 ++++---
 5 files changed, 24 insertions(+), 11 deletions(-)
 create mode 100644 tools/depends/native/distutilscross-native/python3.patch
 rename tools/depends/native/{python27-native => python36-native}/Makefile (89%)

diff --git a/tools/depends/native/Makefile b/tools/depends/native/Makefile
index 0562b6bb1e5f..fbd5829615fd 100644
--- a/tools/depends/native/Makefile
+++ b/tools/depends/native/Makefile
@@ -6,7 +6,7 @@ endif
 
 NATIVE= m4-native gettext-native autoconf-native automake-native \
         libtool-native pkg-config-native yasm-native cmake-native \
-        gas-preprocessor-native python27-native zlib-native \
+        gas-preprocessor-native python36-native zlib-native \
         pcre-native swig-native \
         libpng-native libjpeg-turbo-native liblzo2-native giflib-native \
         distribute-native distutilscross-native JsonSchemaBuilder TexturePacker \
@@ -36,12 +36,12 @@ automake-native: autoconf-native
 libtool-native: automake-native
 libpng-native: zlib-native
 swig-native: pcre-native
-distribute-native: python27-native
-distutilscross-native: python27-native distribute-native
+distribute-native: python36-native
+distutilscross-native: python36-native distribute-native
 tar-native: xz-native automake-native
-python27-native: zlib-native
+python36-native: zlib-native
 wayland-scanner-native: expat-native
-scons-native: python27-native
+scons-native: python36-native
 
 #liblzo2 has stale packaged automake files that cause borked host/build detection
 liblzo2-native: automake-native
diff --git a/tools/depends/native/distribute-native/Makefile b/tools/depends/native/distribute-native/Makefile
index 1ff007562099..cd1536a2a8a0 100644
--- a/tools/depends/native/distribute-native/Makefile
+++ b/tools/depends/native/distribute-native/Makefile
@@ -19,7 +19,7 @@ $(PLATFORM): $(TARBALLS_LOCATION)/$(ARCHIVE) $(DEPS)
 	cd $(PLATFORM); $(ARCHIVE_TOOL) $(ARCHIVE_TOOL_FLAGS) $(TARBALLS_LOCATION)/$(ARCHIVE)
 
 .installed-$(PLATFORM): $(PLATFORM)
-	cd $(PLATFORM); $(PREFIX)/bin/python setup.py install --prefix=$(PREFIX)
+	cd $(PLATFORM); $(PREFIX)/bin/python3 setup.py install --prefix=$(PREFIX)
 	touch $@
 
 clean:
diff --git a/tools/depends/native/distutilscross-native/Makefile b/tools/depends/native/distutilscross-native/Makefile
index 7c1a424ac83b..189fb27ecc28 100644
--- a/tools/depends/native/distutilscross-native/Makefile
+++ b/tools/depends/native/distutilscross-native/Makefile
@@ -1,7 +1,7 @@
 include ../../Makefile.include
 PREFIX=$(NATIVEPREFIX)
 PLATFORM=$(NATIVEPLATFORM)
-DEPS= ../../Makefile.include.in Makefile
+DEPS= ../../Makefile.include.in Makefile python3.patch
 
 # lib name, version
 LIBNAME=distutilscross
@@ -17,9 +17,10 @@ $(TARBALLS_LOCATION)/$(ARCHIVE):
 $(PLATFORM): $(TARBALLS_LOCATION)/$(ARCHIVE) $(DEPS)
 	-rm -rf $(PLATFORM)/*; mkdir -p $(PLATFORM)
 	cd $(PLATFORM); $(ARCHIVE_TOOL) $(ARCHIVE_TOOL_FLAGS) $(TARBALLS_LOCATION)/$(ARCHIVE)
+	cd $(PLATFORM); patch -p0 < ../python3.patch
 
 .installed-$(PLATFORM): $(PLATFORM)
-	cd $(PLATFORM); $(PREFIX)/bin/python setup.py install --prefix=$(PREFIX)
+	cd $(PLATFORM); $(PREFIX)/bin/python3 setup.py install --prefix=$(PREFIX)
 	touch $@
 
 clean:
diff --git a/tools/depends/native/distutilscross-native/python3.patch b/tools/depends/native/distutilscross-native/python3.patch
new file mode 100644
index 000000000000..0c08255769ba
--- /dev/null
+++ b/tools/depends/native/distutilscross-native/python3.patch
@@ -0,0 +1,11 @@
+--- distutilscross/crosscompile.py.orig	2017-07-31 23:59:48.328618000 +0530
++++ distutilscross/crosscompile.py	2017-08-01 00:06:04.608664000 +0530
+@@ -32,7 +32,7 @@
+ _get_python_lib = sysconfig.get_python_lib
+ def get_python_lib(plat_specific=0, standard_lib=0, prefix=None):
+     if os.environ.has_key('PYTHONXCPREFIX'):
+-        print "Setting prefix"
++        print("Setting prefix")
+         prefix = os.environ['PYTHONXCPREFIX']
+ 
+     return _get_python_lib(plat_specific, standard_lib, prefix)
diff --git a/tools/depends/native/python27-native/Makefile b/tools/depends/native/python36-native/Makefile
similarity index 89%
rename from tools/depends/native/python27-native/Makefile
rename to tools/depends/native/python36-native/Makefile
index 2df09b497709..60d71f3759ae 100644
--- a/tools/depends/native/python27-native/Makefile
+++ b/tools/depends/native/python36-native/Makefile
@@ -1,16 +1,16 @@
 include ../../Makefile.include
 PLATFORM=$(NATIVEPLATFORM)
-DEPS= ../../Makefile.include.in Makefile
+DEPS= ../../Makefile.include Makefile
 
 # lib name, version
 LIBNAME=Python
-VERSION=2.7.13
+VERSION=3.6.2
 SOURCE=$(LIBNAME)-$(VERSION)
 ARCHIVE=$(SOURCE).tar.xz
 CWD=$(shell pwd)
 HOSTPYTHONDIR=$(CWD)/$(PLATFORM)/hostpython
 
-CONFIGURE=./configure --prefix=$(NATIVEPREFIX) --disable-shared --disable-toolbox-glue --disable-framework
+CONFIGURE=./configure --prefix=$(NATIVEPREFIX) --disable-shared --disable-framework --without-pymalloc
 
 LIBDYLIB=$(PLATFORM)/python
 
@@ -27,6 +27,7 @@ $(PLATFORM): $(TARBALLS_LOCATION)/$(ARCHIVE) $(DEPS)
 	cd $(PLATFORM); $(CONFIGURE)
 
 $(LIBDYLIB): $(PLATFORM)
+	cd $(PLATFORM); $(MAKE) regen-grammar
 	cd $(PLATFORM); $(MAKE)
 
 .installed-$(PLATFORM): $(LIBDYLIB)

From 0204cfb50c32fada233e38a83e4fc4f08dcdab57 Mon Sep 17 00:00:00 2001
From: Arpit Nandwani <arpit.nandwani@gmail.com>
Date: Sun, 20 Aug 2017 17:14:45 +0530
Subject: [PATCH 12/25] Updated Python36 Makefile and Patches

---
 .../target/python27/Python-2.7.10-android.patch    |  59 ---
 .../python27/Python-2.7.12-crosscompile.patch      | 143 ------
 .../target/python27/Python-no-export-path.patch    |  11 -
 tools/depends/target/python27/fix-datetime.patch   |  18 -
 .../target/python27/make-fork-optional.patch       |  15 -
 tools/depends/target/python27/modules.setup        | 520 ---------------------
 .../target/python27/python-android-binmodule.patch |  31 --
 .../depends/target/{python27 => python36}/Makefile |  36 +-
 .../Python-2.6.5-urllib.diff                       |   0
 .../target/python36/Python-3.6.2-android.patch     |  53 +++
 .../python36/Python-3.6.2-crosscompile.patch       | 104 +++++
 .../{python27 => python36}/Python-no-abort.patch   |   6 +-
 .../{python27 => python36}/Python-setup.patch      |   0
 tools/depends/target/python36/fix-datetime.patch   |  16 +
 .../target/{python27 => python36}/fix-ffi.patch    |  18 +-
 .../target/python36/make-fork-optional.patch       |  12 +
 16 files changed, 216 insertions(+), 826 deletions(-)
 delete mode 100644 tools/depends/target/python27/Python-2.7.10-android.patch
 delete mode 100644 tools/depends/target/python27/Python-2.7.12-crosscompile.patch
 delete mode 100644 tools/depends/target/python27/Python-no-export-path.patch
 delete mode 100644 tools/depends/target/python27/fix-datetime.patch
 delete mode 100644 tools/depends/target/python27/make-fork-optional.patch
 delete mode 100644 tools/depends/target/python27/modules.setup
 delete mode 100644 tools/depends/target/python27/python-android-binmodule.patch
 rename tools/depends/target/{python27 => python36}/Makefile (59%)
 rename tools/depends/target/{python27 => python36}/Python-2.6.5-urllib.diff (100%)
 create mode 100644 tools/depends/target/python36/Python-3.6.2-android.patch
 create mode 100644 tools/depends/target/python36/Python-3.6.2-crosscompile.patch
 rename tools/depends/target/{python27 => python36}/Python-no-abort.patch (84%)
 rename tools/depends/target/{python27 => python36}/Python-setup.patch (100%)
 create mode 100644 tools/depends/target/python36/fix-datetime.patch
 rename tools/depends/target/{python27 => python36}/fix-ffi.patch (78%)
 create mode 100644 tools/depends/target/python36/make-fork-optional.patch

diff --git a/tools/depends/target/python27/Python-2.7.10-android.patch b/tools/depends/target/python27/Python-2.7.10-android.patch
deleted file mode 100644
index 29cf6476ba12..000000000000
--- a/tools/depends/target/python27/Python-2.7.10-android.patch
+++ /dev/null
@@ -1,59 +0,0 @@
---- Modules/pwdmodule.c.orig	2015-10-09 10:16:03.679939815 +0200
-+++ Modules/pwdmodule.c	2015-10-09 10:18:48.567945964 +0200
-@@ -68,14 +68,14 @@
- #define SETS(i,val) sets(v, i, val)
- 
-     SETS(setIndex++, p->pw_name);
--#ifdef __VMS
-+#if defined __VMS || defined(ANDROID)
-     SETS(setIndex++, "");
- #else
-     SETS(setIndex++, p->pw_passwd);
- #endif
-     PyStructSequence_SET_ITEM(v, setIndex++, _PyInt_FromUid(p->pw_uid));
-     PyStructSequence_SET_ITEM(v, setIndex++, _PyInt_FromGid(p->pw_gid));
--#ifdef __VMS
-+#if defined __VMS || defined(ANDROID)
-     SETS(setIndex++, "");
- #else
-     SETS(setIndex++, p->pw_gecos);
---- Modules/termios.c.orig	2015-10-09 10:56:52.448031136 +0200
-+++ Modules/termios.c	2015-10-09 10:59:43.668037521 +0200
-@@ -227,6 +227,7 @@
-     return Py_None;
- }
- 
-+#if !defined(ANDROID)
- PyDoc_STRVAR(termios_tcdrain__doc__,
- "tcdrain(fd) -> None\n\
- \n\
-@@ -246,6 +247,7 @@
-     Py_INCREF(Py_None);
-     return Py_None;
- }
-+#endif
- 
- PyDoc_STRVAR(termios_tcflush__doc__,
- "tcflush(fd, queue) -> None\n\
-@@ -301,8 +303,10 @@
-      METH_VARARGS, termios_tcsetattr__doc__},
-     {"tcsendbreak", termios_tcsendbreak,
-      METH_VARARGS, termios_tcsendbreak__doc__},
-+#if !defined(ANDROID)
-     {"tcdrain", termios_tcdrain,
-      METH_VARARGS, termios_tcdrain__doc__},
-+#endif
-     {"tcflush", termios_tcflush,
-      METH_VARARGS, termios_tcflush__doc__},
-     {"tcflow", termios_tcflow,
---- Modules/posixmodule.c.orig	2015-10-09 13:19:47.524350922 +0200
-+++ Modules/posixmodule.c	2015-10-09 13:20:55.436353454 +0200
-@@ -3967,7 +3967,7 @@
-     slave_fd = open(slave_name, O_RDWR | O_NOCTTY); /* open slave */
-     if (slave_fd < 0)
-         return posix_error();
--#if !defined(__CYGWIN__) && !defined(HAVE_DEV_PTC)
-+#if !defined(__CYGWIN__) && !defined(HAVE_DEV_PTC) && !defined(ANDROID)
-     ioctl(slave_fd, I_PUSH, "ptem"); /* push ptem */
-     ioctl(slave_fd, I_PUSH, "ldterm"); /* push ldterm */
- #ifndef __hpux
diff --git a/tools/depends/target/python27/Python-2.7.12-crosscompile.patch b/tools/depends/target/python27/Python-2.7.12-crosscompile.patch
deleted file mode 100644
index 2dc089b91ae3..000000000000
--- a/tools/depends/target/python27/Python-2.7.12-crosscompile.patch
+++ /dev/null
@@ -1,143 +0,0 @@
-index dffc0b9..efc79ab 100644
---- a/Makefile.pre.in
-+++ b/Makefile.pre.in
-@@ -245,6 +245,7 @@ LIBFFI_INCLUDEDIR=	@LIBFFI_INCLUDEDIR@
- ##########################################################################
- # Parser
- PGEN=		Parser/pgen$(EXE)
-+PGEN_FOR_BUILD=$(NATIVE_PGEN)
- 
- PSRCS=		\
- 		Parser/acceler.c \
-@@ -543,9 +544,9 @@ sharedmods: $(BUILDPYTHON) pybuilddir.txt Modules/_math.o
- 	    *\ -s*|s*) quiet="-q";; \
- 	    *) quiet="";; \
- 	esac; \
--	$(RUNSHARED) CC='$(CC)' LDSHARED='$(BLDSHARED)' OPT='$(OPT)' \
-+	$(RUNSHARED) CC='$(CC)' LDSHARED='$(BLDSHARED)' OPT='$(OPT)'    \
- 		_TCLTK_INCLUDES='$(TCLTK_INCLUDES)' _TCLTK_LIBS='$(TCLTK_LIBS)' \
--		$(PYTHON_FOR_BUILD) $(srcdir)/setup.py $$quiet build
-+		PYTHONXCPREFIX='$(DESTDIR)$(prefix)' $(PYTHON_FOR_BUILD) $(srcdir)/setup.py $$quiet build
- 
- # Build static library
- # avoid long command lines, same as LIBRARY_OBJS
-@@ -1120,12 +1121,12 @@ libinstall:	build_all $(srcdir)/Lib/$(PLATDIR) $(srcdir)/Modules/xxmodule.c
- 		$(INSTALL_DATA) $(srcdir)/Modules/xxmodule.c \
- 			$(DESTDIR)$(LIBDEST)/distutils/tests ; \
- 	fi
--	PYTHONPATH=$(DESTDIR)$(LIBDEST)  $(RUNSHARED) \
-+	-PYTHONPATH=$(DESTDIR)$(LIBDEST)  $(RUNSHARED) \
- 		$(PYTHON_FOR_BUILD) -Wi -tt $(DESTDIR)$(LIBDEST)/compileall.py \
- 		-d $(LIBDEST) -f \
- 		-x 'bad_coding|badsyntax|site-packages|lib2to3/tests/data' \
- 		$(DESTDIR)$(LIBDEST)
--	PYTHONPATH=$(DESTDIR)$(LIBDEST) $(RUNSHARED) \
-+	-PYTHONPATH=$(DESTDIR)$(LIBDEST) $(RUNSHARED) \
- 		$(PYTHON_FOR_BUILD) -Wi -tt -O $(DESTDIR)$(LIBDEST)/compileall.py \
- 		-d $(LIBDEST) -f \
- 		-x 'bad_coding|badsyntax|site-packages|lib2to3/tests/data' \
-@@ -1253,11 +1254,13 @@ libainstall:	all python-config
- # Install the dynamically loadable modules
- # This goes into $(exec_prefix)
- sharedinstall: sharedmods
-+	CC='$(CC)' LDSHARED='$(BLDSHARED)' OPT='$(OPT)' \
- 	$(RUNSHARED) $(PYTHON_FOR_BUILD) $(srcdir)/setup.py install \
-+		--skip-build \
- 	   	--prefix=$(prefix) \
--		--install-scripts=$(BINDIR) \
--		--install-platlib=$(DESTSHARED) \
--		--root=$(DESTDIR)/
-+		--install-scripts=$(DESTDIR)$(BINDIR) \
-+		--install-platlib=$(DESTDIR)$(DESTSHARED) \
-+		--root=/
- 	-rm $(DESTDIR)$(DESTSHARED)/_sysconfigdata.py*
- 
- # Here are a couple of targets for MacOSX again, to install a full
-diff --git a/configure.ac b/configure.ac
-index 06c877b..de26012 100644
---- a/configure.ac
-+++ b/configure.ac
-@@ -329,7 +329,6 @@ then
- 	*)
- 		# for now, limit cross builds to known configurations
- 		MACHDEP="unknown"
--		AC_MSG_ERROR([cross build not supported for $host])
- 	esac
- 	ac_sys_release=
-     else
-@@ -375,7 +374,6 @@ if test "$cross_compiling" = yes; then
- 	*)
- 		# for now, limit cross builds to known configurations
- 		MACHDEP="unknown"
--		AC_MSG_ERROR([cross build not supported for $host])
- 	esac
- 	_PYTHON_HOST_PLATFORM="$MACHDEP${_host_cpu:+-$_host_cpu}"
- fi
-diff --git a/setup.py b/Python-2.7.12/setup.py
-index aa08ada..f21e349 100644
---- a/setup.py
-+++ b/setup.py
-@@ -17,7 +17,7 @@ from distutils.command.install import install
- from distutils.command.install_lib import install_lib
- from distutils.spawn import find_executable
- 
--cross_compiling = "_PYTHON_HOST_PLATFORM" in os.environ
-+cross_compiling = ("_PYTHON_HOST_PLATFORM" in os.environ) or ('CROSS_COMPILE_TARGET' in os.environ)
- 
- def get_platform():
-     # cross build
-@@ -178,6 +178,7 @@ class PyBuildExt(build_ext):
- 
-     def build_extensions(self):
- 
-+        return
-         # Detect which modules should be compiled
-         missing = self.detect_modules()
- 
-@@ -342,6 +343,9 @@ class PyBuildExt(build_ext):
- 
-         # Don't try to load extensions for cross builds
-         if cross_compiling:
-+            self.announce(
-+                 'WARNING: skipping import check for cross-compiled: "%s"' %
-+                 ext.name)
-             return
- 
-         try:
-@@ -496,7 +500,7 @@ class PyBuildExt(build_ext):
-                     for directory in reversed(options.dirs):
-                         add_dir_to_list(dir_list, directory)
- 
--        if os.path.normpath(sys.prefix) != '/usr' \
-+        if os.path.normpath(sys.prefix) != '/usr' and not cross_compiling \
-                 and not sysconfig.get_config_var('PYTHONFRAMEWORK'):
-             # OSX note: Don't add LIBDIR and INCLUDEDIR to building a framework
-             # (PYTHONFRAMEWORK is set) to avoid # linking problems when
-@@ -572,6 +576,11 @@ class PyBuildExt(build_ext):
-         if host_platform in ['darwin', 'beos']:
-             math_libs = []
- 
-+        # Insert libraries and headers from embedded root file system (RFS)
-+        #if 'CROSS_COMPILE_TARGET' in os.environ:
-+        #    lib_dirs += [os.environ['RFS'] + '/usr/lib']
-+        #    inc_dirs += [os.environ['RFS'] + '/usr/include']
-+
-         # XXX Omitted modules: gl, pure, dl, SGI-specific modules
- 
-         #
-@@ -2048,8 +2057,13 @@ class PyBuildExt(build_ext):
- 
-                 # Pass empty CFLAGS because we'll just append the resulting
-                 # CFLAGS to Python's; -g or -O2 is to be avoided.
--                cmd = "cd %s && env CFLAGS='' '%s/configure' %s" \
--                      % (ffi_builddir, ffi_srcdir, " ".join(config_args))
-+                if cross_compiling:
-+                    cmd = "cd %s && env CFLAGS='' '%s/configure' --host=%s --build=%s %s" \
-+                          % (ffi_builddir, ffi_srcdir, os.environ.get('HOSTARCH'),
-+                             os.environ.get('BUILDARCH'), " ".join(config_args))
-+                else:
-+                    cmd = "cd %s && env CFLAGS='' '%s/configure' %s" \
-+                          % (ffi_builddir, ffi_srcdir, " ".join(config_args))
- 
-                 res = os.system(cmd)
-                 if res or not os.path.exists(ffi_configfile):
diff --git a/tools/depends/target/python27/Python-no-export-path.patch b/tools/depends/target/python27/Python-no-export-path.patch
deleted file mode 100644
index e46ad4f6da02..000000000000
--- a/tools/depends/target/python27/Python-no-export-path.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- Makefile.pre.in.orig	2015-10-09 19:10:15.042905069 +0200
-+++ Makefile.pre.in	2015-10-09 19:11:01.513642241 +0200
-@@ -1148,8 +1148,6 @@
- $(srcdir)/Lib/$(PLATDIR):
- 	mkdir $(srcdir)/Lib/$(PLATDIR)
- 	cp $(srcdir)/Lib/plat-generic/regen $(srcdir)/Lib/$(PLATDIR)/regen
--	export PATH; PATH="`pwd`:$$PATH"; \
--	export PYTHONPATH; PYTHONPATH="$(srcdir)/Lib:$(abs_builddir)/`cat pybuilddir.txt`"; \
- 	export DYLD_FRAMEWORK_PATH; DYLD_FRAMEWORK_PATH="`pwd`"; \
- 	export EXE; EXE="$(BUILDEXE)"; \
- 	if [ -n "$(MULTIARCH)" ]; then export MULTIARCH; MULTIARCH=$(MULTIARCH); fi; \
diff --git a/tools/depends/target/python27/fix-datetime.patch b/tools/depends/target/python27/fix-datetime.patch
deleted file mode 100644
index 831c69d96406..000000000000
--- a/tools/depends/target/python27/fix-datetime.patch
+++ /dev/null
@@ -1,18 +0,0 @@
---- Modules/_testcapimodule.c.orig	2015-10-07 16:50:38.751087989 +0200
-+++ Modules/_testcapimodule.c	2015-10-07 16:50:59.119088070 +0200
-@@ -8,8 +8,14 @@
- #include "Python.h"
- #include <float.h>
- #include "structmember.h"
--#include "datetime.h"
- #include "marshal.h"
-+#ifdef Py_BUILD_CORE
-+#undef Py_BUILD_CORE
-+#include "datetime.h"
-+#define Py_BUILD_CORE
-+#else
-+#include "datetime.h"
-+#endif
- 
- #ifdef WITH_THREAD
- #include "pythread.h"
diff --git a/tools/depends/target/python27/make-fork-optional.patch b/tools/depends/target/python27/make-fork-optional.patch
deleted file mode 100644
index 049d078014e6..000000000000
--- a/tools/depends/target/python27/make-fork-optional.patch
+++ /dev/null
@@ -1,15 +0,0 @@
---- Modules/posixmodule.c.orig	2015-12-12 17:13:12.000000000 +0100
-+++ Modules/posixmodule.c	2015-12-12 17:13:47.000000000 +0100
-@@ -162,6 +162,12 @@
- #endif  /* ! __WATCOMC__ || __QNX__ */
- #endif /* ! __IBMC__ */
- 
-+
-+#undef HAVE_FORK
-+#undef HAVE_EXECV
-+#undef HAVE_SYSTEM
-+
-+
- #ifndef _MSC_VER
- 
- #if defined(__sgi)&&_COMPILER_VERSION>=700
diff --git a/tools/depends/target/python27/modules.setup b/tools/depends/target/python27/modules.setup
deleted file mode 100644
index 3bfde6d67ac0..000000000000
--- a/tools/depends/target/python27/modules.setup
+++ /dev/null
@@ -1,520 +0,0 @@
-# -*- makefile -*-
-# The file Setup is used by the makesetup script to construct the files
-# Makefile and config.c, from Makefile.pre and config.c.in,
-# respectively.  The file Setup itself is initially copied from
-# Setup.dist; once it exists it will not be overwritten, so you can edit
-# Setup to your heart's content.  Note that Makefile.pre is created
-# from Makefile.pre.in by the toplevel configure script.
-
-# (VPATH notes: Setup and Makefile.pre are in the build directory, as
-# are Makefile and config.c; the *.in and *.dist files are in the source
-# directory.)
-
-# Each line in this file describes one or more optional modules.
-# Modules enabled here will not be compiled by the setup.py script,
-# so the file can be used to override setup.py's behavior.
-
-# Lines have the following structure:
-#
-# <module> ... [<sourcefile> ...] [<cpparg> ...] [<library> ...]
-#
-# <sourcefile> is anything ending in .c (.C, .cc, .c++ are C++ files)
-# <cpparg> is anything starting with -I, -D, -U or -C
-# <library> is anything ending in .a or beginning with -l or -L
-# <module> is anything else but should be a valid Python
-# identifier (letters, digits, underscores, beginning with non-digit)
-#
-# (As the makesetup script changes, it may recognize some other
-# arguments as well, e.g. *.so and *.sl as libraries.  See the big
-# case statement in the makesetup script.)
-#
-# Lines can also have the form
-#
-# <name> = <value>
-#
-# which defines a Make variable definition inserted into Makefile.in
-#
-# Finally, if a line contains just the word "*shared*" (without the
-# quotes but with the stars), then the following modules will not be
-# built statically.  The build process works like this:
-#
-# 1. Build all modules that are declared as static in Modules/Setup,
-#    combine them into libpythonxy.a, combine that into python.
-# 2. Build all modules that are listed as shared in Modules/Setup.
-# 3. Invoke setup.py. That builds all modules that
-#    a) are not builtin, and
-#    b) are not listed in Modules/Setup, and
-#    c) can be build on the target
-#
-# Therefore, modules declared to be shared will not be
-# included in the config.c file, nor in the list of objects to be
-# added to the library archive, and their linker options won't be
-# added to the linker options. Rules to create their .o files and
-# their shared libraries will still be added to the Makefile, and
-# their names will be collected in the Make variable SHAREDMODS.  This
-# is used to build modules as shared libraries.  (They can be
-# installed using "make sharedinstall", which is implied by the
-# toplevel "make install" target.)  (For compatibility,
-# *noconfig* has the same effect as *shared*.)
-#
-# In addition, *static* explicitly declares the following modules to
-# be static.  Lines containing "*static*" and "*shared*" may thus
-# alternate throughout this file.
-
-# NOTE: As a standard policy, as many modules as can be supported by a
-# platform should be present.  The distribution comes with all modules
-# enabled that are supported by most platforms and don't require you
-# to ftp sources from elsewhere.
-*static*
-
-# Some special rules to define PYTHONPATH.
-# Edit the definitions below to indicate which options you are using.
-# Don't add any whitespace or comments!
-
-# Directories where library files get installed.
-# DESTLIB is for Python modules; MACHDESTLIB for shared libraries.
-DESTLIB=$(LIBDEST)
-MACHDESTLIB=$(BINLIBDEST)
-
-# NOTE: all the paths are now relative to the prefix that is computed
-# at run time!
-
-# Standard path -- don't edit.
-# No leading colon since this is the first entry.
-# Empty since this is now just the runtime prefix.
-DESTPATH=
-
-# Site specific path components -- should begin with : if non-empty
-SITEPATH=:site-packages
-
-# Standard path components for test modules
-TESTPATH=
-
-# Path components for machine- or system-dependent modules and shared libraries
-MACHDEPPATH=:plat-$(MACHDEP)
-EXTRAMACHDEPPATH=
-
-# Path component for the Tkinter-related modules
-# The TKPATH variable is always enabled, to save you the effort.
-TKPATH=:lib-tk
-
-# Path component for old modules.
-OLDPATH=:lib-old
-
-COREPYTHONPATH=$(DESTPATH)$(SITEPATH)$(TESTPATH)$(MACHDEPPATH)$(EXTRAMACHDEPPATH)$(TKPATH)$(OLDPATH)
-PYTHONPATH=$(COREPYTHONPATH)
-
-
-# The modules listed here can't be built as shared libraries for
-# various reasons; therefore they are listed here instead of in the
-# normal order.
-
-# This only contains the minimal set of modules required to run the 
-# setup.py script in the root of the Python source tree.
-
-posix posixmodule.c		# posix (UNIX) system calls
-errno errnomodule.c		# posix (UNIX) errno values
-pwd pwdmodule.c			# this is needed to find out the user's home dir
-				# if $HOME is not set
-_sre _sre.c			# Fredrik Lundh's new regular expressions
-_codecs _codecsmodule.c		# access to the builtin codecs and codec registry
-
-# The zipimport module is always imported at startup. Having it as a
-# builtin module avoids some bootstrapping problems and reduces overhead.
-zipimport zipimport.c
-
-# The rest of the modules listed in this file are all commented out by
-# default.  Usually they can be detected and built as dynamically
-# loaded modules by the new setup.py script added in Python 2.1.  If
-# you're on a platform that doesn't support dynamic loading, want to 
-# compile modules statically into the Python binary, or need to 
-# specify some odd set of compiler switches, you can uncomment the 
-# appropriate lines below.
-
-# ======================================================================
-
-# The Python symtable module depends on .h files that setup.py doesn't track
-_symtable symtablemodule.c
-
-# The SGI specific GL module:
-
-GLHACK=-Dclear=__GLclear
-#gl glmodule.c cgensupport.c -I$(srcdir) $(GLHACK) -lgl -lX11
-
-# Pure module.  Cannot be linked dynamically.
-# -DWITH_QUANTIFY, -DWITH_PURIFY, or -DWITH_ALL_PURE
-#WHICH_PURE_PRODUCTS=-DWITH_ALL_PURE
-#PURE_INCLS=-I/usr/local/include
-#PURE_STUBLIBS=-L/usr/local/lib -lpurify_stubs -lquantify_stubs
-#pure puremodule.c $(WHICH_PURE_PRODUCTS) $(PURE_INCLS) $(PURE_STUBLIBS)
-
-# Uncommenting the following line tells makesetup that all following
-# modules are to be built as shared libraries (see above for more
-# detail; also note that *static* reverses this effect):
-
-#*shared*
-
-# GNU readline.  Unlike previous Python incarnations, GNU readline is
-# now incorporated in an optional module, configured in the Setup file
-# instead of by a configure script switch.  You may have to insert a
-# -L option pointing to the directory where libreadline.* lives,
-# and you may have to change -ltermcap to -ltermlib or perhaps remove
-# it, depending on your system -- see the GNU readline instructions.
-# It's okay for this to be a shared library, too.
-
-#readline readline.c -lreadline -lncurses
-
-
-# Modules that should always be present (non UNIX dependent):
-
-array arraymodule.c	# array objects
-cmath cmathmodule.c  # -lm # complex math library functions
-math mathmodule.c _math.c # -lm # math library functions, e.g. sin()
-_struct _struct.c	# binary structure packing/unpacking
-time timemodule.c # -lm # time operations and variables
-operator operator.c	# operator.add() and similar goodies
-_weakref _weakref.c	# basic weak reference support
-_testcapi _testcapimodule.c    # Python C API test module
-_random _randommodule.c	# Random number generator
-_collections _collectionsmodule.c # Container types
-itertools itertoolsmodule.c	# Functions creating iterators for efficient looping 
-strop stropmodule.c		# String manipulations
-_functools _functoolsmodule.c	# Tools for working with functions and callable objects
-
-EXPATDEFINES='-DHAVE_EXPAT_CONFIG_H -DUSE_PYEXPAT_CAPI'
-_elementtree -I$(srcdir)/Modules/expat $(EXPATDEFINES) _elementtree.c	# elementtree accelerator
-#_pickle _pickle.c	# pickle accelerator
-datetime datetimemodule.c	# date/time type
-_bisect _bisectmodule.c	# Bisection algorithms
-
-unicodedata unicodedata.c    # static Unicode character database
-
-# access to ISO C locale support
-_locale _localemodule.c   -lintl
-
-
-# Modules with some UNIX dependencies -- on by default:
-# (If you have a really backward UNIX, select and socket may not be
-# supported...)
-#
-fcntl fcntlmodule.c	# fcntl(2) and ioctl(2)
-#spwd spwdmodule.c		# spwd(3) 
-#grp grpmodule.c		# grp(3)
-select selectmodule.c	# select(2); not on ancient System V
-
-# Memory-mapped files (also works on Win32).
-mmap mmapmodule.c
-
-# CSV file helper
-_csv _csv.c
-
-# Socket module helper for socket(2)
-_socket socketmodule.c
-
-# Socket module helper for SSL support; you must comment out the other
-# socket line above, and possibly edit the SSL variable:
-SSLDEFINES='-DUSE_SSL'
-_ssl _ssl.c \
-	$(SSLDEFINES) -I$(prefix)/include -I$(prefix)/include/openssl \
-	-L$(prefix)/lib -lssl -lcrypto
-
-_hashlib _hashopenssl.c \
-        $(SSLDEFINES) -I$(prefix)/include -I$(prefix)/include/openssl \
-        -L$(prefix)/lib -lssl -lcrypto
-
-# The crypt module is now disabled by default because it breaks builds
-# on many systems (where -lcrypt is needed), e.g. Linux (I believe).
-#
-# First, look at Setup.config; configure may have set this for you.
-
-#crypt cryptmodule.c  -lcrypt	# crypt(3); needs -lcrypt on some systems
-
-# Some more UNIX dependent modules -- off by default, since these
-# are not supported by all UNIX systems:
-
-#nis nismodule.c -lnsl	# Sun yellow pages -- not everywhere
-termios termios.c	# Steen Lumholt's termios module
-resource resource.c	# Jeremy Hylton's rlimit interface
-
-
-# Multimedia modules -- off by default.
-# These don't work for 64-bit platforms!!!
-# #993173 says audioop works on 64-bit platforms, though.
-# These represent audio samples or images as strings:
-
-#audioop audioop.c	# Operations on audio samples
-#imageop imageop.c	# Operations on images
-
-
-# Note that the _md5 and _sha modules are normally only built if the
-# system does not have the OpenSSL libs containing an optimized version.
-
-# The _md5 module implements the RSA Data Security, Inc. MD5
-# Message-Digest Algorithm, described in RFC 1321.  The necessary files
-# md5.c and md5.h are included here.
-
-_md5 md5module.c md5.c
-
-
-# The _sha module implements the SHA checksum algorithms.
-# (NIST's Secure Hash Algorithms.)
-_sha shamodule.c
-_sha256 sha256module.c
-_sha512 sha512module.c
-
-
-# SGI IRIX specific modules -- off by default.
-
-# These module work on any SGI machine:
-
-# *** gl must be enabled higher up in this file ***
-#fm fmmodule.c $(GLHACK) -lfm -lgl		# Font Manager
-#sgi sgimodule.c			# sgi.nap() and a few more
-
-# This module requires the header file
-# /usr/people/4Dgifts/iristools/include/izoom.h:
-#imgfile imgfile.c -limage -lgutil -lgl -lm	# Image Processing Utilities
-
-
-# These modules require the Multimedia Development Option (I think):
-
-#al almodule.c -laudio			# Audio Library
-#cd cdmodule.c -lcdaudio -lds -lmediad	# CD Audio Library
-#cl clmodule.c -lcl -lawareaudio	# Compression Library
-#sv svmodule.c yuvconvert.c -lsvideo -lXext -lX11	# Starter Video
-
-
-# The FORMS library, by Mark Overmars, implements user interface
-# components such as dialogs and buttons using SGI's GL and FM
-# libraries.  You must ftp the FORMS library separately from
-# ftp://ftp.cs.ruu.nl/pub/SGI/FORMS.  It was tested with FORMS 2.2a.
-# NOTE: if you want to be able to use FORMS and curses simultaneously
-# (or both link them statically into the same binary), you must
-# compile all of FORMS with the cc option "-Dclear=__GLclear".
-
-# The FORMS variable must point to the FORMS subdirectory of the forms
-# toplevel directory:
-
-#FORMS=/ufs/guido/src/forms/FORMS
-#fl flmodule.c -I$(FORMS) $(GLHACK) $(FORMS)/libforms.a -lfm -lgl
-
-
-# SunOS specific modules -- off by default:
-
-#sunaudiodev sunaudiodev.c
-
-
-# A Linux specific module -- off by default; this may also work on 
-# some *BSDs.
-
-#linuxaudiodev linuxaudiodev.c
-
-
-# George Neville-Neil's timing module:
-
-timing timingmodule.c
-
-
-# The _tkinter module.
-#
-# The command for _tkinter is long and site specific.  Please
-# uncomment and/or edit those parts as indicated.  If you don't have a
-# specific extension (e.g. Tix or BLT), leave the corresponding line
-# commented out.  (Leave the trailing backslashes in!  If you
-# experience strange errors, you may want to join all uncommented
-# lines and remove the backslashes -- the backslash interpretation is
-# done by the shell's "read" command and it may not be implemented on
-# every system.
-
-# *** Always uncomment this (leave the leading underscore in!):
-# _tkinter _tkinter.c tkappinit.c -DWITH_APPINIT \
-# *** Uncomment and edit to reflect where your Tcl/Tk libraries are:
-#	-L/usr/local/lib \
-# *** Uncomment and edit to reflect where your Tcl/Tk headers are:
-#	-I/usr/local/include \
-# *** Uncomment and edit to reflect where your X11 header files are:
-#	-I/usr/X11R6/include \
-# *** Or uncomment this for Solaris:
-#	-I/usr/openwin/include \
-# *** Uncomment and edit for Tix extension only:
-#	-DWITH_TIX -ltix8.1.8.2 \
-# *** Uncomment and edit for BLT extension only:
-#	-DWITH_BLT -I/usr/local/blt/blt8.0-unoff/include -lBLT8.0 \
-# *** Uncomment and edit for PIL (TkImaging) extension only:
-#     (See http://www.pythonware.com/products/pil/ for more info)
-#	-DWITH_PIL -I../Extensions/Imaging/libImaging  tkImaging.c \
-# *** Uncomment and edit for TOGL extension only:
-#	-DWITH_TOGL togl.c \
-# *** Uncomment and edit to reflect your Tcl/Tk versions:
-#	-ltk8.2 -ltcl8.2 \
-# *** Uncomment and edit to reflect where your X11 libraries are:
-#	-L/usr/X11R6/lib \
-# *** Or uncomment this for Solaris:
-#	-L/usr/openwin/lib \
-# *** Uncomment these for TOGL extension only:
-#	-lGL -lGLU -lXext -lXmu \
-# *** Uncomment for AIX:
-#	-lld \
-# *** Always uncomment this; X11 libraries to link with:
-#	-lX11
-
-# Lance Ellinghaus's syslog module
-syslog syslogmodule.c		# syslog daemon interface
-
-
-# Curses support, requring the System V version of curses, often
-# provided by the ncurses library.  e.g. on Linux, link with -lncurses
-# instead of -lcurses).
-#
-# First, look at Setup.config; configure may have set this for you.
-
-#_curses _cursesmodule.c -lcurses -ltermcap
-# Wrapper for the panel library that's part of ncurses and SYSV curses.
-#_curses_panel _curses_panel.c -lpanel -lncurses 
-
-
-# Generic (SunOS / SVR4) dynamic loading module.
-# This is not needed for dynamic loading of Python modules --
-# it is a highly experimental and dangerous device for calling
-# *arbitrary* C functions in *arbitrary* shared libraries:
-
-#dl dlmodule.c
-
-
-# Modules that provide persistent dictionary-like semantics.  You will
-# probably want to arrange for at least one of them to be available on
-# your machine, though none are defined by default because of library
-# dependencies.  The Python module anydbm.py provides an
-# implementation independent wrapper for these; dumbdbm.py provides
-# similar functionality (but slower of course) implemented in Python.
-
-# The standard Unix dbm module has been moved to Setup.config so that
-# it will be compiled as a shared library by default.  Compiling it as
-# a built-in module causes conflicts with the pybsddb3 module since it
-# creates a static dependency on an out-of-date version of db.so.
-#
-# First, look at Setup.config; configure may have set this for you.
-
-#dbm -I$(prefix)/include -L$(prefix)/lib dbmmodule.c 	# dbm(3) may require -lndbm or similar
-
-# Anthony Baxter's gdbm module.  GNU dbm(3) will require -lgdbm:
-#
-# First, look at Setup.config; configure may have set this for you.
-
-#gdbm gdbmmodule.c -I$(prefix)/include -L$(prefix)/lib -lgdbm
-
-
-# Sleepycat Berkeley DB interface.
-#
-# This requires the Sleepycat DB code, see http://www.sleepycat.com/
-# The earliest supported version of that library is 3.0, the latest
-# supported version is 4.0 (4.1 is specifically not supported, as that
-# changes the semantics of transactional databases). A list of available
-# releases can be found at
-#
-# http://www.sleepycat.com/update/index.html
-#
-# Edit the variables DB and DBLIBVERto point to the db top directory
-# and the subdirectory of PORT where you built it.
-#DB=/usr/local/BerkeleyDB.4.0
-#DBLIBVER=4.0
-#DBINC=$(DB)/include
-#DBLIB=$(DB)/lib
-#_bsddb _bsddb.c -I$(DBINC) -L$(DBLIB) -ldb-$(DBLIBVER)
-
-# Historical Berkeley DB 1.85
-#
-# This module is deprecated; the 1.85 version of the Berkeley DB library has
-# bugs that can cause data corruption. If you can, use later versions of the
-# library instead, available from <http://www.sleepycat.com/>.
-
-#DB=/depot/sundry/src/berkeley-db/db.1.85
-#DBPORT=$(DB)/PORT/irix.5.3
-#bsddb185 bsddbmodule.c -I$(DBPORT)/include -I$(DBPORT) $(DBPORT)/libdb.a
-
-
-
-# Helper module for various ascii-encoders
-binascii binascii.c
-
-# Fred Drake's interface to the Python parser
-parser parsermodule.c
-
-# cStringIO and cPickle
-cStringIO cStringIO.c
-cPickle cPickle.c
-
-
-# Lee Busby's SIGFPE modules.
-# The library to link fpectl with is platform specific.
-# Choose *one* of the options below for fpectl:
-
-# For SGI IRIX (tested on 5.3):
-#fpectl fpectlmodule.c -lfpe
-
-# For Solaris with SunPro compiler (tested on Solaris 2.5 with SunPro C 4.2):
-# (Without the compiler you don't have -lsunmath.)
-#fpectl fpectlmodule.c -R/opt/SUNWspro/lib -lsunmath -lm
-
-# For other systems: see instructions in fpectlmodule.c.
-#fpectl fpectlmodule.c ...
-
-# Test module for fpectl.  No extra libraries needed.
-#fpetest fpetestmodule.c
-
-# Andrew Kuchling's zlib module.
-# This require zlib 1.1.3 (or later).
-# See http://www.gzip.org/zlib/
-zlib zlibmodule.c -I$(prefix)/include -L$(prefix)/lib -lz
-
-# Interface to the Expat XML parser
-#
-# Expat was written by James Clark and is now maintained by a group of
-# developers on SourceForge; see www.libexpat.org for more
-# information.  The pyexpat module was written by Paul Prescod after a
-# prototype by Jack Jansen.  Source of Expat 1.95.2 is included in
-# Modules/expat/.  Usage of a system shared libexpat.so/expat.dll is
-# not advised.
-#
-# More information on Expat can be found at www.libexpat.org.
-#
-pyexpat expat/xmlparse.c expat/xmlrole.c expat/xmltok.c pyexpat.c -I$(srcdir)/Modules/expat $(EXPATDEFINES) -I$(prefix)/include -L$(prefix)/lib -lexpat
-
-
-# Hye-Shik Chang's CJKCodecs
-
-# multibytecodec is required for all the other CJK codec modules
-_multibytecodec cjkcodecs/multibytecodec.c
-
-_codecs_cn cjkcodecs/_codecs_cn.c
-_codecs_hk cjkcodecs/_codecs_hk.c
-_codecs_iso2022 cjkcodecs/_codecs_iso2022.c
-_codecs_jp cjkcodecs/_codecs_jp.c
-_codecs_kr cjkcodecs/_codecs_kr.c
-_codecs_tw cjkcodecs/_codecs_tw.c
-
-# Example -- included for reference only:
-# xx xxmodule.c
-
-# Another example -- the 'xxsubtype' module shows C-level subtyping in action
-xxsubtype xxsubtype.c
-
-_lsprof _lsprof.c rotatingtree.c
-_json _json.c
-#_io/fileio _io/fileio.c
-_io _io/bufferedio.c _io/bytesio.c _io/fileio.c _io/iobase.c _io/_iomodule.c _io/stringio.c _io/textio.c
-_heapq _heapqmodule.c
-_hotshot _hotshot.c
-future_builtins future_builtins.c
-
-SQLITEDEFINES='-DMODULE_NAME="sqlite3"'
-_sqlite3 _sqlite/connection.c  \
-	_sqlite/cursor.c _sqlite/microprotocols.c _sqlite/prepare_protocol.c \
-	_sqlite/row.c _sqlite/statement.c _sqlite/module.c _sqlite/util.c _sqlite/cache.c \
-	-I$(prefix)/include -L$(prefix)/lib -lsqlite3 $(SQLITEDEFINES)
-
-_ctypes _ctypes/callbacks.c  _ctypes/callproc.c  _ctypes/cfield.c  _ctypes/_ctypes.c  \
-        _ctypes/malloc_closure.c  _ctypes/stgdict.c \
-        -I$(prefix)/include/ffi -L$(prefix)/lib -lffi
-
-#bz2 bz2module.c -I$(prefix)/include -L$(prefix)/lib -lbz2
diff --git a/tools/depends/target/python27/python-android-binmodule.patch b/tools/depends/target/python27/python-android-binmodule.patch
deleted file mode 100644
index c28ddf67190e..000000000000
--- a/tools/depends/target/python27/python-android-binmodule.patch
+++ /dev/null
@@ -1,31 +0,0 @@
---- Python/dynload_shlib.c	2014-08-13 15:13:49.879675283 +0200
-+++ Python/dynload_shlib.c	2014-08-13 19:03:57.456363680 +0200
-@@ -112,10 +112,6 @@
-         dlopenflags = PyThreadState_GET()->interp->dlopenflags;
- #endif
- 
--	if (Py_VerboseFlag)
--		PySys_WriteStderr("dlopen(\"%s\", %x);\n", pathname, 
--				  dlopenflags);
--
- #ifdef __VMS
- 	/* VMS currently don't allow a pathname, use a logical name instead */
- 	/* Concatenate 'python_module_' and shortname */
-@@ -125,8 +121,17 @@
- 	PyOS_snprintf(pathbuf, sizeof(pathbuf), "python_module_%-.200s", 
- 		      shortname);
- 	pathname = pathbuf;
-+#elif defined(ANDROID)
-+	/* Android does not allow a pathname and wants lib*.so */
-+	PyOS_snprintf(pathbuf, sizeof(pathbuf), "lib%-.200s.so", 
-+		      shortname);
-+	pathname = pathbuf;
- #endif
- 
-+	if (Py_VerboseFlag)
-+		PySys_WriteStderr("dlopen(\"%s\", %x);\n", pathname, 
-+				  dlopenflags);
-+
- 	handle = dlopen(pathname, dlopenflags);
- 
- 	if (handle == NULL) {
diff --git a/tools/depends/target/python27/Makefile b/tools/depends/target/python36/Makefile
similarity index 59%
rename from tools/depends/target/python27/Makefile
rename to tools/depends/target/python36/Makefile
index 82eec65da0b0..63314785776e 100644
--- a/tools/depends/target/python27/Makefile
+++ b/tools/depends/target/python36/Makefile
@@ -1,28 +1,34 @@
 include ../../Makefile.include
-DEPS= ../../Makefile.include Makefile Python-2.7.12-crosscompile.patch Python-2.7.10-android.patch Python-no-export-path.patch \
-       Python-setup.patch fix-datetime.patch fix-ffi.patch python-android-binmodule.patch Python-no-abort.patch Python-2.6.5-urllib.diff modules.setup make-fork-optional.patch
+DEPS= ../../Makefile.include Makefile Python-3.6.2-crosscompile.patch Python-3.6.2-android.patch \
+       fix-datetime.patch apple.patch modules.setup make-fork-optional.patch
 
 # lib name, version
 LIBNAME=Python
-VERSION=2.7.13
+VERSION=3.6.2
 SOURCE=$(LIBNAME)-$(VERSION)
 ARCHIVE=$(SOURCE).tar.xz
 
 ifeq ($(OS),osx)
   HOSTPLATFORM=_PYTHON_HOST_PLATFORM="darwin"
+  export READELF=$(NATIVEPREFIX)/bin/readelf
 endif
 ifeq ($(OS),ios)
   HOSTPLATFORM=_PYTHON_HOST_PLATFORM="darwin"
   LINK_ICONV=-framework CoreFoundation -liconv
+  export READELF=$(NATIVEPREFIX)/bin/readelf
+endif
+
+ifeq ($(TARGET_PLATFORM),raspberry-pi)
+  export READELF=$(NATIVEPREFIX)/bin/readelf
 endif
 
 # configuration settings
 CONFIGURE=OPT="$(CFLAGS)" \
   LIBS=-lm \
   ./configure --prefix=$(PREFIX) --host=$(HOST) \
-  --disable-toolbox-glue --disable-framework --with-system-ffi --without-pymalloc --enable-ipv6 
+  --disable-framework --with-system-ffi --without-pymalloc --enable-ipv6
 
-LIBDYLIB=$(PLATFORM)/libpython2.7.a
+LIBDYLIB=$(PLATFORM)/libpython3.6.a
 
 all: .installed-$(PLATFORM)
 
@@ -33,20 +39,14 @@ $(PLATFORM): $(TARBALLS_LOCATION)/$(ARCHIVE) $(DEPS)
 	echo $(NATIVEPREFIX)
 	rm -rf $(PLATFORM)/*; mkdir -p $(PLATFORM)
 	cd $(PLATFORM); $(ARCHIVE_TOOL) $(ARCHIVE_TOOL_FLAGS) $(TARBALLS_LOCATION)/$(ARCHIVE)
-	cd $(PLATFORM); patch -p1 < ../Python-2.7.12-crosscompile.patch
-	cd $(PLATFORM); patch -p0 < ../Python-setup.patch
+	cd $(PLATFORM); patch -p0 < ../Python-3.6.2-crosscompile.patch
 	cd $(PLATFORM); patch -p0 < ../fix-datetime.patch
-	cd $(PLATFORM); patch -p0 < ../Python-2.7.10-android.patch
-	cd $(PLATFORM); patch -p0 < ../Python-no-export-path.patch
+	cd $(PLATFORM); patch -p0 < ../Python-3.6.2-android.patch
 	cd $(PLATFORM); patch -p0 < ../fix-ffi.patch
-	cd $(PLATFORM); patch -l -p0 < ../python-android-binmodule.patch
-	cd $(PLATFORM); patch -p1 < ../Python-no-abort.patch
 ifeq ($(OS),ios)
 	cd $(PLATFORM); patch -p0 < ../make-fork-optional.patch
-	cd $(PLATFORM); patch -p0 < ../Python-2.6.5-urllib.diff
 	cd $(PLATFORM); sed -ie 's|MACHDEP="unknown"|MACHDEP="darwin"|' configure.ac
 endif
-	cp modules.setup $(PLATFORM)/Modules/Setup.dist
 
 #Add -liconv as needed, and add the _scproxy module for darwin
 #  disable locale altogether for Android
@@ -57,7 +57,7 @@ else
 endif
 ifeq ($(OS),osx)
 	cd $(PLATFORM); sed -ie 's|MACHDEP="unknown"|MACHDEP="darwin"|' configure.ac
-	echo "_scproxy \$$(srcdir)/Mac/Modules/_scproxy.c -framework SystemConfiguration -framework CoreFoundation" >> $(PLATFORM)/Modules/Setup.dist
+	echo "_scproxy \$$(srcdir)/Modules/_scproxy.c -framework SystemConfiguration -framework CoreFoundation" >> $(PLATFORM)/Modules/Setup.dist
 endif
 
 ifeq ($(OS),android)
@@ -68,13 +68,13 @@ endif
 	cd $(PLATFORM); $(CONFIGURE)
 
 $(LIBDYLIB): $(PLATFORM)
-	$(MAKE) -C $(PLATFORM) $(HOSTPLATFORM) PYTHON_FOR_BUILD=$(NATIVEPREFIX)/bin/python NATIVE_PGEN=$(NATIVEPREFIX)/bin/pgen CROSS_COMPILE_TARGET=yes libpython2.7.a
+	$(MAKE) -C $(PLATFORM) $(HOSTPLATFORM) PYTHON_FOR_BUILD=$(NATIVEPREFIX)/bin/python3 NATIVE_PGEN=$(NATIVEPREFIX)/bin/pgen CROSS_COMPILE_TARGET=yes libpython3.6.a
 	touch $@
 
 .installed-$(PLATFORM): $(LIBDYLIB)
-	$(MAKE) -C $(PLATFORM) $(HOSTPLATFORM) PYTHON_FOR_BUILD=$(NATIVEPREFIX)/bin/python NATIVE_PGEN=$(NATIVEPREFIX)/bin/pgen CROSS_COMPILE_TARGET=yes install
-	find $(PREFIX)/lib/python2.7 -type f -name "*.py" -delete
-	find $(PREFIX)/lib/python2.7 -type f -name "*.pyc" -delete
+	$(MAKE) -C $(PLATFORM) $(HOSTPLATFORM) PYTHON_FOR_BUILD=$(NATIVEPREFIX)/bin/python3 NATIVE_PGEN=$(NATIVEPREFIX)/bin/pgen CROSS_COMPILE_TARGET=yes install
+	# find $(PREFIX)/lib/python3.6 -type f -name "*.py" -delete
+	find $(PREFIX)/lib/python3.6 -type f -name "*.pyc" -delete
 	touch $(LIBDYLIB)
 	touch $@
 
diff --git a/tools/depends/target/python27/Python-2.6.5-urllib.diff b/tools/depends/target/python36/Python-2.6.5-urllib.diff
similarity index 100%
rename from tools/depends/target/python27/Python-2.6.5-urllib.diff
rename to tools/depends/target/python36/Python-2.6.5-urllib.diff
diff --git a/tools/depends/target/python36/Python-3.6.2-android.patch b/tools/depends/target/python36/Python-3.6.2-android.patch
new file mode 100644
index 000000000000..98e97108fd6f
--- /dev/null
+++ b/tools/depends/target/python36/Python-3.6.2-android.patch
@@ -0,0 +1,53 @@
+--- Modules/pwdmodule.c.orig	2017-08-06 15:17:15.150696238 +0530
++++ Modules/pwdmodule.c	2017-08-06 15:24:51.550696238 +0530
+@@ -82,7 +82,7 @@
+ #endif
+     PyStructSequence_SET_ITEM(v, setIndex++, _PyLong_FromUid(p->pw_uid));
+     PyStructSequence_SET_ITEM(v, setIndex++, _PyLong_FromGid(p->pw_gid));
+-#if defined(HAVE_STRUCT_PASSWD_PW_GECOS)
++#if defined(HAVE_STRUCT_PASSWD_PW_GECOS) && !defined(__ANDROID__)
+     SETS(setIndex++, p->pw_gecos);
+ #else
+     SETS(setIndex++, "");
+
+--- Modules/termios.c.orig	2017-08-06 15:17:42.822696238 +0530
++++ Modules/termios.c	2017-08-06 15:37:30.242696238 +0530
+@@ -220,6 +220,7 @@
+     return Py_None;
+ }
+ 
++#if !defined(__ANDROID__)
+ PyDoc_STRVAR(termios_tcdrain__doc__,
+ "tcdrain(fd) -> None\n\
+ \n\
+@@ -239,6 +240,7 @@
+     Py_INCREF(Py_None);
+     return Py_None;
+ }
++#endif
+ 
+ PyDoc_STRVAR(termios_tcflush__doc__,
+ "tcflush(fd, queue) -> None\n\
+@@ -294,8 +296,10 @@
+      METH_VARARGS, termios_tcsetattr__doc__},
+     {"tcsendbreak", termios_tcsendbreak,
+      METH_VARARGS, termios_tcsendbreak__doc__},
++     #if !defined(__ANDROID__)
+     {"tcdrain", termios_tcdrain,
+      METH_VARARGS, termios_tcdrain__doc__},
++     #endif
+     {"tcflush", termios_tcflush,
+      METH_VARARGS, termios_tcflush__doc__},
+     {"tcflow", termios_tcflow,
+
+--- Modules/posixmodule.c
++++ Modules/posixmodule.c
+@@ -1932,7 +1932,7 @@
+         return NULL;
+ 
+     PyStructSequence_SET_ITEM(v, 0, PyLong_FromLong((long)st->st_mode));
+-#if defined(HAVE_LARGEFILE_SUPPORT) || defined(MS_WINDOWS)
++#if defined(HAVE_LARGEFILE_SUPPORT) || defined(MS_WINDOWS) || defined(ANDROID)
+     Py_BUILD_ASSERT(sizeof(unsigned long long) >= sizeof(st->st_ino));
+     PyStructSequence_SET_ITEM(v, 1,
+                               PyLong_FromUnsignedLongLong(st->st_ino));
diff --git a/tools/depends/target/python36/Python-3.6.2-crosscompile.patch b/tools/depends/target/python36/Python-3.6.2-crosscompile.patch
new file mode 100644
index 000000000000..5f575683f6ce
--- /dev/null
+++ b/tools/depends/target/python36/Python-3.6.2-crosscompile.patch
@@ -0,0 +1,104 @@
+--- Makefile.pre.in.orig	2017-08-02 16:55:54.406031000 +0530
++++ Makefile.pre.in	2017-08-02 16:58:42.814031000 +0530
+@@ -279,7 +279,7 @@
+ ##########################################################################
+ # Parser
+ PGEN=		Parser/pgen$(EXE)
+-
++PGEN_FOR_BUILD=$(NATIVE_PGEN)
+ POBJS=		\
+ 		Parser/acceler.o \
+ 		Parser/grammar1.o \
+@@ -575,7 +575,7 @@
+ 	esac; \
+ 	$(RUNSHARED) CC='$(CC)' LDSHARED='$(BLDSHARED)' OPT='$(OPT)' \
+ 		_TCLTK_INCLUDES='$(TCLTK_INCLUDES)' _TCLTK_LIBS='$(TCLTK_LIBS)' \
+-		$(PYTHON_FOR_BUILD) $(srcdir)/setup.py $$quiet build
++		PYTHONXCPREFIX='$(DESTDIR)$(prefix)' $(PYTHON_FOR_BUILD) $(srcdir)/setup.py $$quiet build
+ 
+ 
+ # Build static library
+@@ -1434,11 +1434,13 @@
+ # Install the dynamically loadable modules
+ # This goes into $(exec_prefix)
+ sharedinstall: sharedmods
++	CC='$(CC)' LDSHARED='$(BLDSHARED)' OPT='$(OPT)' \
+ 	$(RUNSHARED) $(PYTHON_FOR_BUILD) $(srcdir)/setup.py install \
++	   	--skip-build \
+ 	   	--prefix=$(prefix) \
+-		--install-scripts=$(BINDIR) \
+-		--install-platlib=$(DESTSHARED) \
+-		--root=$(DESTDIR)/
++		--install-scripts=$(DESTDIR)$(BINDIR) \
++		--install-platlib=$(DESTDIR)$(DESTSHARED) \
++		--root=/
+ 	-rm $(DESTDIR)$(DESTSHARED)/_sysconfigdata_$(ABIFLAGS)_$(MACHDEP)_$(MULTIARCH).py
+ 	-rm -r $(DESTDIR)$(DESTSHARED)/__pycache__
+ 
+
+--- configure.ac.orig	2017-08-02 03:14:45.287912000 +0530
++++ configure.ac	2017-08-02 03:37:45.849848000 +0530
+@@ -382,7 +382,6 @@
+ 	*)
+ 		# for now, limit cross builds to known configurations
+ 		MACHDEP="unknown"
+-		AC_MSG_ERROR([cross build not supported for $host])
+ 	esac
+ 	ac_sys_release=
+     else
+@@ -427,7 +426,6 @@
+ 	*)
+ 		# for now, limit cross builds to known configurations
+ 		MACHDEP="unknown"
+-		AC_MSG_ERROR([cross build not supported for $host])
+ 	esac
+ 	_PYTHON_HOST_PLATFORM="$MACHDEP${_host_cpu:+-$_host_cpu}"
+ fi
+
+
+--- setup.py.orig	2017-08-02 03:15:31.390951999 +0530
++++ setup.py	2017-08-02 03:49:29.957726000 +0530
+@@ -16,7 +16,7 @@
+ from distutils.command.build_scripts import build_scripts
+ from distutils.spawn import find_executable
+ 
+-cross_compiling = "_PYTHON_HOST_PLATFORM" in os.environ
++cross_compiling = ("_PYTHON_HOST_PLATFORM" in os.environ) or ('CROSS_COMPILE_TARGET' in os.environ)
+ 
+ # Add special CFLAGS reserved for building the interpreter and the stdlib
+ # modules (Issue #21121).
+@@ -199,6 +199,7 @@
+ 
+     def build_extensions(self):
+ 
++        return
+         # Detect which modules should be compiled
+         missing = self.detect_modules()
+ 
+@@ -376,6 +377,9 @@
+ 
+         # Don't try to load extensions for cross builds
+         if cross_compiling:
++            self.announce(
++                'WARNING: skipping import check for cross-compiled: "%s"' %
++                ext.name)
+             return
+ 
+         loader = importlib.machinery.ExtensionFileLoader(ext.name, ext_filename)
+@@ -1943,8 +1947,13 @@
+ 
+                 # Pass empty CFLAGS because we'll just append the resulting
+                 # CFLAGS to Python's; -g or -O2 is to be avoided.
+-                cmd = "cd %s && env CFLAGS='' '%s/configure' %s" \
+-                      % (ffi_builddir, ffi_srcdir, " ".join(config_args))
++                if cross_compiling:
++                    cmd = "cd %s && env CFLAGS='' '%s/configure' --host=%s --build=%s %s" \
++                          % (ffi_builddir, ffi_srcdir, os.environ.get('HOSTARCH'),
++                             os.environ.get('BUILDARCH'), " ".join(config_args))
++                else:
++                    cmd = "cd %s && env CFLAGS='' '%s/configure' %s" \
++                          % (ffi_builddir, ffi_srcdir, " ".join(config_args))
+ 
+                 res = os.system(cmd)
+                 if res or not os.path.exists(ffi_configfile):
+
diff --git a/tools/depends/target/python27/Python-no-abort.patch b/tools/depends/target/python36/Python-no-abort.patch
similarity index 84%
rename from tools/depends/target/python27/Python-no-abort.patch
rename to tools/depends/target/python36/Python-no-abort.patch
index 0f0807cd6085..e23f828d7867 100644
--- a/tools/depends/target/python27/Python-no-abort.patch
+++ b/tools/depends/target/python36/Python-no-abort.patch
@@ -1,9 +1,9 @@
 diff -ur orig/Modules/posixmodule.c arm-linux-androideabi-21/Modules/posixmodule.c
 --- orig/Modules/posixmodule.c	2016-07-30 22:35:02.016158026 +0200
 +++ arm-linux-androideabi-21/Modules/posixmodule.c	2016-08-27 13:02:46.755833610 +0200
-@@ -8615,7 +8615,7 @@
- static PyObject *
- posix_abort(PyObject *self, PyObject *noargs)
+@@ -10365,7 +10365,7 @@
+ os_abort_impl(PyObject *module)
+ /*[clinic end generated code: output=dcf52586dad2467c input=cf2c7d98bc504047]*/
  {
 -    abort();
 +    // abort();
diff --git a/tools/depends/target/python27/Python-setup.patch b/tools/depends/target/python36/Python-setup.patch
similarity index 100%
rename from tools/depends/target/python27/Python-setup.patch
rename to tools/depends/target/python36/Python-setup.patch
diff --git a/tools/depends/target/python36/fix-datetime.patch b/tools/depends/target/python36/fix-datetime.patch
new file mode 100644
index 000000000000..31d91e8a7888
--- /dev/null
+++ b/tools/depends/target/python36/fix-datetime.patch
@@ -0,0 +1,16 @@
+--- Modules/_testcapimodule.c.orig	2017-08-01 21:44:07.917316734 +0530
++++ Modules/_testcapimodule.c	2017-08-01 21:47:50.309316734 +0530
+@@ -10,7 +10,13 @@
+ #include "Python.h"
+ #include <float.h>
+ #include "structmember.h"
++#ifdef Py_BUILD_CORE
++#undef Py_BUILD_CORE
+ #include "datetime.h"
++#define Py_BUILD_CORE
++#else
++#include "datetime.h"
++#endif
+ #include "marshal.h"
+ #include <signal.h>
+ 
diff --git a/tools/depends/target/python27/fix-ffi.patch b/tools/depends/target/python36/fix-ffi.patch
similarity index 78%
rename from tools/depends/target/python27/fix-ffi.patch
rename to tools/depends/target/python36/fix-ffi.patch
index ca90d0dadc63..8a4282c0e0b8 100644
--- a/tools/depends/target/python27/fix-ffi.patch
+++ b/tools/depends/target/python36/fix-ffi.patch
@@ -1,5 +1,5 @@
---- Modules/_ctypes/malloc_closure.c.orig	2015-10-11 20:37:30.534378131 +0200
-+++ Modules/_ctypes/malloc_closure.c	2015-10-11 20:38:57.322381368 +0200
+--- Modules/_ctypes/malloc_closure.c.orig	2017-08-06 19:18:47.412010000 +0530
++++ Modules/_ctypes/malloc_closure.c	2017-08-06 19:21:37.760010000 +0530
 @@ -89,6 +89,7 @@
  /******************************************************************/
  
@@ -21,9 +21,11 @@
      return (void *)item;
  }
 +*/
---- Modules/_ctypes/cfield.c.orig	2015-10-11 20:34:03.034370393 +0200
-+++ Modules/_ctypes/cfield.c	2015-10-11 20:37:04.462377159 +0200
-@@ -1727,6 +1727,7 @@
+
+
+--- Modules/_ctypes/cfield.c.orig	2017-08-06 19:19:03.724010000 +0530
++++ Modules/_ctypes/cfield.c	2017-08-06 19:32:45.592010000 +0530
+@@ -1631,6 +1631,7 @@
  */
  
  /* align and size are bogus for void, but they must not be zero */
@@ -31,12 +33,12 @@
  ffi_type ffi_type_void = { 1, 1, FFI_TYPE_VOID };
  
  ffi_type ffi_type_uint8 = { 1, 1, FFI_TYPE_UINT8 };
-@@ -1743,14 +1744,14 @@
+@@ -1647,14 +1648,15 @@
  
  ffi_type ffi_type_float = { sizeof(float), FLOAT_ALIGN, FFI_TYPE_FLOAT };
  ffi_type ffi_type_double = { sizeof(double), DOUBLE_ALIGN, FFI_TYPE_DOUBLE };
--
 +*/
+ 
  #ifdef ffi_type_longdouble
  #undef ffi_type_longdouble
  #endif
@@ -47,5 +49,5 @@
  
  ffi_type ffi_type_pointer = { sizeof(void *), VOID_P_ALIGN, FFI_TYPE_POINTER };
 -
-+*/
++  */
  /*---------------- EOF ----------------*/
diff --git a/tools/depends/target/python36/make-fork-optional.patch b/tools/depends/target/python36/make-fork-optional.patch
new file mode 100644
index 000000000000..e7c7998bccd7
--- /dev/null
+++ b/tools/depends/target/python36/make-fork-optional.patch
@@ -0,0 +1,12 @@
+--- Modules/posixmodule.c.orig	2017-08-06 15:18:11.634696238 +0530
++++ Modules/posixmodule.c	2017-08-06 20:20:07.016010000 +0530
+@@ -195,6 +195,9 @@
+ #endif  /* _MSC_VER */
+ #endif  /* ! __WATCOMC__ || __QNX__ */
+ 
++#undef HAVE_FORK
++#undef HAVE_EXECV
++#undef HAVE_SYSTEM
+ 
+ /*[clinic input]
+ # one of the few times we lie about this name!

From f8e75b8b5079363db18021b8ade971889af29059 Mon Sep 17 00:00:00 2001
From: Arpit Nandwani <arpit.nandwani@gmail.com>
Date: Sun, 20 Aug 2017 17:16:38 +0530
Subject: [PATCH 13/25] Added modules.setup

---
 tools/depends/target/python36/Makefile      |   1 +
 tools/depends/target/python36/modules.setup | 411 ++++++++++++++++++++++++++++
 2 files changed, 412 insertions(+)
 create mode 100644 tools/depends/target/python36/modules.setup

diff --git a/tools/depends/target/python36/Makefile b/tools/depends/target/python36/Makefile
index 63314785776e..8612c26f3347 100644
--- a/tools/depends/target/python36/Makefile
+++ b/tools/depends/target/python36/Makefile
@@ -47,6 +47,7 @@ ifeq ($(OS),ios)
 	cd $(PLATFORM); patch -p0 < ../make-fork-optional.patch
 	cd $(PLATFORM); sed -ie 's|MACHDEP="unknown"|MACHDEP="darwin"|' configure.ac
 endif
+	cp modules.setup $(PLATFORM)/Modules/Setup.dist
 
 #Add -liconv as needed, and add the _scproxy module for darwin
 #  disable locale altogether for Android
diff --git a/tools/depends/target/python36/modules.setup b/tools/depends/target/python36/modules.setup
new file mode 100644
index 000000000000..5b08e67a4856
--- /dev/null
+++ b/tools/depends/target/python36/modules.setup
@@ -0,0 +1,411 @@
+# -*- makefile -*-
+# The file Setup is used by the makesetup script to construct the files
+# Makefile and config.c, from Makefile.pre and config.c.in,
+# respectively.  The file Setup itself is initially copied from
+# Setup.dist; once it exists it will not be overwritten, so you can edit
+# Setup to your heart's content.  Note that Makefile.pre is created
+# from Makefile.pre.in by the toplevel configure script.
+
+# (VPATH notes: Setup and Makefile.pre are in the build directory, as
+# are Makefile and config.c; the *.in and *.dist files are in the source
+# directory.)
+
+# Each line in this file describes one or more optional modules.
+# Modules enabled here will not be compiled by the setup.py script,
+# so the file can be used to override setup.py's behavior.
+
+# Lines have the following structure:
+#
+# <module> ... [<sourcefile> ...] [<cpparg> ...] [<library> ...]
+#
+# <sourcefile> is anything ending in .c (.C, .cc, .c++ are C++ files)
+# <cpparg> is anything starting with -I, -D, -U or -C
+# <library> is anything ending in .a or beginning with -l or -L
+# <module> is anything else but should be a valid Python
+# identifier (letters, digits, underscores, beginning with non-digit)
+#
+# (As the makesetup script changes, it may recognize some other
+# arguments as well, e.g. *.so and *.sl as libraries.  See the big
+# case statement in the makesetup script.)
+#
+# Lines can also have the form
+#
+# <name> = <value>
+#
+# which defines a Make variable definition inserted into Makefile.in
+#
+# Finally, if a line contains just the word "*shared*" (without the
+# quotes but with the stars), then the following modules will not be
+# built statically.  The build process works like this:
+#
+# 1. Build all modules that are declared as static in Modules/Setup,
+#    combine them into libpythonxy.a, combine that into python.
+# 2. Build all modules that are listed as shared in Modules/Setup.
+# 3. Invoke setup.py. That builds all modules that
+#    a) are not builtin, and
+#    b) are not listed in Modules/Setup, and
+#    c) can be build on the target
+#
+# Therefore, modules declared to be shared will not be
+# included in the config.c file, nor in the list of objects to be
+# added to the library archive, and their linker options won't be
+# added to the linker options. Rules to create their .o files and
+# their shared libraries will still be added to the Makefile, and
+# their names will be collected in the Make variable SHAREDMODS.  This
+# is used to build modules as shared libraries.  (They can be
+# installed using "make sharedinstall", which is implied by the
+# toplevel "make install" target.)  (For compatibility,
+# *noconfig* has the same effect as *shared*.)
+#
+# In addition, *static* explicitly declares the following modules to
+# be static.  Lines containing "*static*" and "*shared*" may thus
+# alternate throughout this file.
+
+# NOTE: As a standard policy, as many modules as can be supported by a
+# platform should be present.  The distribution comes with all modules
+# enabled that are supported by most platforms and don't require you
+# to ftp sources from elsewhere.
+*static*
+
+# Some special rules to define PYTHONPATH.
+# Edit the definitions below to indicate which options you are using.
+# Don't add any whitespace or comments!
+
+# Directories where library files get installed.
+# DESTLIB is for Python modules; MACHDESTLIB for shared libraries.
+DESTLIB=$(LIBDEST)
+MACHDESTLIB=$(BINLIBDEST)
+
+# NOTE: all the paths are now relative to the prefix that is computed
+# at run time!
+
+# Standard path -- don't edit.
+# No leading colon since this is the first entry.
+# Empty since this is now just the runtime prefix.
+DESTPATH=
+
+# Site specific path components -- should begin with : if non-empty
+SITEPATH=:site-packages 
+
+# Standard path components for test modules
+TESTPATH=
+
+# Path components for machine- or system-dependent modules and shared libraries
+MACHDEPPATH=:plat-$(MACHDEP)
+EXTRAMACHDEPPATH=
+
+COREPYTHONPATH=$(DESTPATH)$(SITEPATH)$(TESTPATH)$(MACHDEPPATH)$(EXTRAMACHDEPPATH)
+PYTHONPATH=$(COREPYTHONPATH)
+
+
+# The modules listed here can't be built as shared libraries for
+# various reasons; therefore they are listed here instead of in the
+# normal order.
+
+# This only contains the minimal set of modules required to run the
+# setup.py script in the root of the Python source tree.
+
+posix posixmodule.c		# posix (UNIX) system calls
+errno errnomodule.c		# posix (UNIX) errno values
+pwd pwdmodule.c			# this is needed to find out the user's home dir
+				# if $HOME is not set
+_sre _sre.c			# Fredrik Lundh's new regular expressions
+_codecs _codecsmodule.c		# access to the builtin codecs and codec registry
+_weakref _weakref.c		# weak references
+_functools _functoolsmodule.c   # Tools for working with functions and callable objects
+_operator _operator.c	        # operator.add() and similar goodies
+_collections _collectionsmodule.c # Container types
+itertools itertoolsmodule.c    # Functions creating iterators for efficient looping
+atexit atexitmodule.c      # Register functions to be run at interpreter-shutdown
+_signal signalmodule.c
+_stat _stat.c			# stat.h interface
+time timemodule.c	# -lm # time operations and variables
+
+# access to ISO C locale support
+_locale _localemodule.c   -lintl  
+
+# Standard I/O baseline
+_io -I$(srcdir)/Modules/_io _io/_iomodule.c _io/iobase.c _io/fileio.c _io/bytesio.c _io/bufferedio.c _io/textio.c _io/stringio.c
+
+# The zipimport module is always imported at startup. Having it as a
+# builtin module avoids some bootstrapping problems and reduces overhead.
+zipimport zipimport.c
+
+# faulthandler module
+faulthandler faulthandler.c
+
+# debug tool to trace memory blocks allocated by Python
+_tracemalloc _tracemalloc.c hashtable.c
+
+# The rest of the modules listed in this file are all commented out by
+# default.  Usually they can be detected and built as dynamically
+# loaded modules by the new setup.py script added in Python 2.1.  If
+# you're on a platform that doesn't support dynamic loading, want to
+# compile modules statically into the Python binary, or need to
+# specify some odd set of compiler switches, you can uncomment the
+# appropriate lines below.
+
+# ======================================================================
+
+# The Python symtable module depends on .h files that setup.py doesn't track
+_symtable symtablemodule.c
+
+# Uncommenting the following line tells makesetup that all following
+# modules are to be built as shared libraries (see above for more
+# detail; also note that *static* reverses this effect):
+
+#*shared*
+
+# GNU readline.  Unlike previous Python incarnations, GNU readline is
+# now incorporated in an optional module, configured in the Setup file
+# instead of by a configure script switch.  You may have to insert a
+# -L option pointing to the directory where libreadline.* lives,
+# and you may have to change -ltermcap to -ltermlib or perhaps remove
+# it, depending on your system -- see the GNU readline instructions.
+# It's okay for this to be a shared library, too.
+
+#readline readline.c -lreadline -ltermcap
+
+
+# Modules that should always be present (non UNIX dependent):
+
+array arraymodule.c	# array objects
+cmath cmathmodule.c _math.c # -lm # complex math library functions
+math mathmodule.c _math.c # -lm # math library functions, e.g. sin()
+_struct _struct.c	# binary structure packing/unpacking
+_weakref _weakref.c	# basic weak reference support
+_testcapi _testcapimodule.c    # Python C API test module
+_random _randommodule.c	# Random number generator
+_elementtree -I$(srcdir)/Modules/expat -DHAVE_EXPAT_CONFIG_H -DUSE_PYEXPAT_CAPI _elementtree.c	# elementtree accelerator
+_pickle _pickle.c	# pickle accelerator
+_datetime _datetimemodule.c	# datetime accelerator
+_bisect _bisectmodule.c	# Bisection algorithms
+_heapq _heapqmodule.c	# Heap queue algorithm
+_asyncio _asynciomodule.c  # Fast asyncio Future
+
+unicodedata unicodedata.c    # static Unicode character database
+
+
+# Modules with some UNIX dependencies -- on by default:
+# (If you have a really backward UNIX, select and socket may not be
+# supported...)
+
+fcntl fcntlmodule.c	# fcntl(2) and ioctl(2)
+#spwd spwdmodule.c		# spwd(3)
+#grp grpmodule.c		# grp(3)
+select selectmodule.c	# select(2); not on ancient System V
+
+# Memory-mapped files (also works on Win32).
+mmap mmapmodule.c
+
+# CSV file helper
+_csv _csv.c
+
+# Socket module helper for socket(2)
+_socket socketmodule.c
+
+# Socket module helper for SSL support; you must comment out the other
+# socket line above, and possibly edit the SSL variable:
+SSLDEFINES='-DUSE_SSL'
+_ssl _ssl.c \
+	$(SSLDEFINES) -I$(prefix)/include -I$(prefix)/include/openssl \
+	-L$(prefix)/lib -lssl -lcrypto
+
+_hashlib _hashopenssl.c \
+        $(SSLDEFINES) -I$(prefix)/include -I$(prefix)/include/openssl \
+        -L$(prefix)/lib -lssl -lcrypto
+
+# The crypt module is now disabled by default because it breaks builds
+# on many systems (where -lcrypt is needed), e.g. Linux (I believe).
+#
+# First, look at Setup.config; configure may have set this for you.
+
+#_crypt _cryptmodule.c  #-lcrypt	# crypt(3); needs -lcrypt on some systems
+
+
+# Some more UNIX dependent modules -- off by default, since these
+# are not supported by all UNIX systems:
+
+#nis nismodule.c -lnsl	# Sun yellow pages -- not everywhere
+termios termios.c	# Steen Lumholt's termios module
+resource resource.c	# Jeremy Hylton's rlimit interface
+
+_posixsubprocess _posixsubprocess.c  # POSIX subprocess module helper
+
+# Multimedia modules -- off by default.
+# These don't work for 64-bit platforms!!!
+# #993173 says audioop works on 64-bit platforms, though.
+# These represent audio samples or images as strings:
+
+#audioop audioop.c	# Operations on audio samples
+
+
+# Note that the _md5 and _sha modules are normally only built if the
+# system does not have the OpenSSL libs containing an optimized version.
+
+# The _md5 module implements the RSA Data Security, Inc. MD5
+# Message-Digest Algorithm, described in RFC 1321.
+
+_md5 md5module.c
+
+
+# The _sha module implements the SHA checksum algorithms.
+# (NIST's Secure Hash Algorithms.)
+_sha1 sha1module.c
+_sha256 sha256module.c
+_sha512 sha512module.c
+
+# _blake module
+#_blake2 _blake2/blake2module.c _blake2/blake2b_impl.c _blake2/blake2s_impl.c
+
+# The _tkinter module.
+#
+# The command for _tkinter is long and site specific.  Please
+# uncomment and/or edit those parts as indicated.  If you don't have a
+# specific extension (e.g. Tix or BLT), leave the corresponding line
+# commented out.  (Leave the trailing backslashes in!  If you
+# experience strange errors, you may want to join all uncommented
+# lines and remove the backslashes -- the backslash interpretation is
+# done by the shell's "read" command and it may not be implemented on
+# every system.
+
+# *** Always uncomment this (leave the leading underscore in!):
+# _tkinter _tkinter.c tkappinit.c -DWITH_APPINIT \
+# *** Uncomment and edit to reflect where your Tcl/Tk libraries are:
+#	-L/usr/local/lib \
+# *** Uncomment and edit to reflect where your Tcl/Tk headers are:
+#	-I/usr/local/include \
+# *** Uncomment and edit to reflect where your X11 header files are:
+#	-I/usr/X11R6/include \
+# *** Or uncomment this for Solaris:
+#	-I/usr/openwin/include \
+# *** Uncomment and edit for Tix extension only:
+#	-DWITH_TIX -ltix8.1.8.2 \
+# *** Uncomment and edit for BLT extension only:
+#	-DWITH_BLT -I/usr/local/blt/blt8.0-unoff/include -lBLT8.0 \
+# *** Uncomment and edit for PIL (TkImaging) extension only:
+#     (See http://www.pythonware.com/products/pil/ for more info)
+#	-DWITH_PIL -I../Extensions/Imaging/libImaging  tkImaging.c \
+# *** Uncomment and edit for TOGL extension only:
+#	-DWITH_TOGL togl.c \
+# *** Uncomment and edit to reflect your Tcl/Tk versions:
+#	-ltk8.2 -ltcl8.2 \
+# *** Uncomment and edit to reflect where your X11 libraries are:
+#	-L/usr/X11R6/lib \
+# *** Or uncomment this for Solaris:
+#	-L/usr/openwin/lib \
+# *** Uncomment these for TOGL extension only:
+#	-lGL -lGLU -lXext -lXmu \
+# *** Uncomment for AIX:
+#	-lld \
+# *** Always uncomment this; X11 libraries to link with:
+#	-lX11
+
+# Lance Ellinghaus's syslog module
+#syslog syslogmodule.c		# syslog daemon interface
+
+
+# Curses support, requiring the System V version of curses, often
+# provided by the ncurses library.  e.g. on Linux, link with -lncurses
+# instead of -lcurses).
+#
+# First, look at Setup.config; configure may have set this for you.
+
+#_curses _cursesmodule.c -lcurses -ltermcap
+# Wrapper for the panel library that's part of ncurses and SYSV curses.
+#_curses_panel _curses_panel.c -lpanel -lncurses
+
+
+# Modules that provide persistent dictionary-like semantics.  You will
+# probably want to arrange for at least one of them to be available on
+# your machine, though none are defined by default because of library
+# dependencies.  The Python module dbm/__init__.py provides an
+# implementation independent wrapper for these; dbm/dumb.py provides
+# similar functionality (but slower of course) implemented in Python.
+
+# The standard Unix dbm module has been moved to Setup.config so that
+# it will be compiled as a shared library by default.  Compiling it as
+# a built-in module causes conflicts with the pybsddb3 module since it
+# creates a static dependency on an out-of-date version of db.so.
+#
+# First, look at Setup.config; configure may have set this for you.
+
+#_dbm _dbmmodule.c 	# dbm(3) may require -lndbm or similar
+
+# Anthony Baxter's gdbm module.  GNU dbm(3) will require -lgdbm:
+#
+# First, look at Setup.config; configure may have set this for you.
+
+#_gdbm _gdbmmodule.c -I/usr/local/include -L/usr/local/lib -lgdbm
+
+
+# Helper module for various ascii-encoders
+#binascii binascii.c
+
+# Fred Drake's interface to the Python parser
+parser parsermodule.c
+
+
+# Lee Busby's SIGFPE modules.
+# The library to link fpectl with is platform specific.
+# Choose *one* of the options below for fpectl:
+
+# For SGI IRIX (tested on 5.3):
+#fpectl fpectlmodule.c -lfpe
+
+# For Solaris with SunPro compiler (tested on Solaris 2.5 with SunPro C 4.2):
+# (Without the compiler you don't have -lsunmath.)
+#fpectl fpectlmodule.c -R/opt/SUNWspro/lib -lsunmath -lm
+
+# For other systems: see instructions in fpectlmodule.c.
+#fpectl fpectlmodule.c ...
+
+# Test module for fpectl.  No extra libraries needed.
+#fpetest fpetestmodule.c
+
+# Andrew Kuchling's zlib module.
+# This require zlib 1.1.3 (or later).
+# See http://www.gzip.org/zlib/
+zlib zlibmodule.c -I$(prefix)/include -L$(exec_prefix)/lib -lz
+
+# Interface to the Expat XML parser
+#
+# Expat was written by James Clark and is now maintained by a group of
+# developers on SourceForge; see www.libexpat.org for more
+# information.  The pyexpat module was written by Paul Prescod after a
+# prototype by Jack Jansen.  Source of Expat 1.95.2 is included in
+# Modules/expat/.  Usage of a system shared libexpat.so/expat.dll is
+# not advised.
+#
+# More information on Expat can be found at www.libexpat.org.
+#
+#pyexpat expat/xmlparse.c expat/xmlrole.c expat/xmltok.c pyexpat.c -I$(srcdir)/Modules/expat -DHAVE_EXPAT_CONFIG_H -DUSE_PYEXPAT_CAPI
+
+# Hye-Shik Chang's CJKCodecs
+
+# multibytecodec is required for all the other CJK codec modules
+#_multibytecodec cjkcodecs/multibytecodec.c
+
+_codecs_cn cjkcodecs/_codecs_cn.c
+_codecs_hk cjkcodecs/_codecs_hk.c
+_codecs_iso2022 cjkcodecs/_codecs_iso2022.c
+_codecs_jp cjkcodecs/_codecs_jp.c
+_codecs_kr cjkcodecs/_codecs_kr.c
+_codecs_tw cjkcodecs/_codecs_tw.c
+
+# Example -- included for reference only:
+# xx xxmodule.c
+
+# Another example -- the 'xxsubtype' module shows C-level subtyping in action
+xxsubtype xxsubtype.c
+
+SQLITEDEFINES='-DMODULE_NAME="sqlite3"'
+_sqlite3 _sqlite/connection.c  \
+	_sqlite/cursor.c _sqlite/microprotocols.c _sqlite/prepare_protocol.c \
+	_sqlite/row.c _sqlite/statement.c _sqlite/module.c _sqlite/util.c _sqlite/cache.c \
+	-I$(prefix)/include -L$(prefix)/lib -lsqlite3 $(SQLITEDEFINES)
+
+_ctypes _ctypes/callbacks.c  _ctypes/callproc.c  _ctypes/cfield.c  _ctypes/_ctypes.c  \
+        _ctypes/malloc_closure.c  _ctypes/stgdict.c \
+        -I$(prefix)/include/ffi -L$(prefix)/lib -lffi
+

From 2e9813414e4a0ac8d75c145231fe2e234aecb7ef Mon Sep 17 00:00:00 2001
From: Arpit Nandwani <arpit.nandwani@gmail.com>
Date: Sun, 20 Aug 2017 17:29:18 +0530
Subject: [PATCH 14/25] Updated the PythonPath in target directories

---
 tools/depends/target/Makefile                            | 10 +++++-----
 tools/depends/target/config.site.in                      |  2 +-
 tools/depends/target/pythonmodule-pil/Makefile           | 16 ++++++++--------
 .../target/pythonmodule-pil/pillow-crosscompile.patch    |  2 +-
 tools/depends/target/pythonmodule-pycryptodome/Makefile  | 14 +++++++-------
 tools/depends/target/pythonmodule-setuptools/Makefile    | 16 ++++++++--------
 6 files changed, 30 insertions(+), 30 deletions(-)

diff --git a/tools/depends/target/Makefile b/tools/depends/target/Makefile
index b73016201a2a..5317b60cad88 100644
--- a/tools/depends/target/Makefile
+++ b/tools/depends/target/Makefile
@@ -10,7 +10,7 @@ DEPENDS = \
 	openssl gmp nettle gnutls curl \
 	libjpeg-turbo libpng fribidi libass \
 	libxml2 rapidjson libmicrohttpd mysql libffi \
-	python27 libshairplay libfmt \
+	python36 libshairplay libfmt \
 	libplist libcec libbluray tinyxml \
 	libssh taglib libusb libnfs \
 	pythonmodule-pil pythonmodule-pycryptodome pythonmodule-setuptools \
@@ -89,7 +89,7 @@ fontconfig: freetype2 expat $(ICONV)
 curl: openssl
 libass: fontconfig fribidi libpng freetype2 expat $(ICONV)
 libmicrohttpd: gnutls libgcrypt libgpg-error
-python27: expat gettext libxml2 sqlite3 openssl libffi
+python36: expat gettext libxml2 sqlite3 openssl libffi
 libcdio: $(ICONV)
 libcdio-gplv3: $(ICONV)
 libplist: libxml2 $(ZLIB)
@@ -101,9 +101,9 @@ libpng: $(ZLIB)
 openssl: $(ZLIB)
 gnutls: nettle $(ZLIB)
 nettle: gmp
-pythonmodule-pycryptodome: $(PYMODULE_DEPS) python27 pythonmodule-setuptools
-pythonmodule-pil: bzip2 $(PYMODULE_DEPS) $(ZLIB) libjpeg-turbo libpng freetype2 python27 pythonmodule-setuptools
-pythonmodule-setuptools: $(PYMODULE_DEPS) python27
+pythonmodule-pycryptodome: $(PYMODULE_DEPS) python36 pythonmodule-setuptools
+pythonmodule-pil: bzip2 $(PYMODULE_DEPS) $(ZLIB) libjpeg-turbo libpng freetype2 python36 pythonmodule-setuptools
+pythonmodule-setuptools: $(PYMODULE_DEPS) python36
 libxslt: libgcrypt libxml2
 ffmpeg: $(ICONV) $(ZLIB) bzip2 $(FFMPEG_DEPENDS)
 platform: p8-platform
diff --git a/tools/depends/target/config.site.in b/tools/depends/target/config.site.in
index d3a2e2e3cc5f..11f25ae79426 100644
--- a/tools/depends/target/config.site.in
+++ b/tools/depends/target/config.site.in
@@ -35,7 +35,7 @@ LIBGCRYPT_CONFIG=@prefix@/@deps_dir@/bin/libgcrypt-config
 PATH=@prefix@/@tool_dir@/bin:@use_toolchain@/usr/bin:@use_toolchain@/bin:$PATH
 LD_LIBRARY_PATH=@prefix@/@tool_dir@/lib:$LD_LIBRARY_PATH
 
-PYTHON_VERSION=2.7
+PYTHON_VERSION=3.6
 PYTHON_LDFLAGS="-L@prefix@/@deps_dir@/lib -L@prefix@/@deps_dir@/lib64 -lpython${PYTHON_VERSION} -lc -ldl -lm -lexpat -lffi -lintl -lutil -lssl -lcrypto"
 PYTHON_CPPFLAGS=-I@prefix@/@deps_dir@/include/python${PYTHON_VERSION}
 PYTHON_SITE_PKG=@prefix@/@deps_dir@/lib/python${PYTHON_VERSION}/site-packages
diff --git a/tools/depends/target/pythonmodule-pil/Makefile b/tools/depends/target/pythonmodule-pil/Makefile
index 9a83544201b2..ad1400e2a542 100644
--- a/tools/depends/target/pythonmodule-pil/Makefile
+++ b/tools/depends/target/pythonmodule-pil/Makefile
@@ -10,22 +10,22 @@ VERSION=3.0.0
 SOURCE=$(LIBNAME)-$(VERSION)
 ARCHIVE=$(SOURCE).tar.gz
 
-CROSSFLAGS=PYTHONXCPREFIX="$(PREFIX)" CC="$(CC) $(CFLAGS)" LDSHARED="$(CC) -shared" LDFLAGS="$(LDFLAGS)" PYTHONPATH="$(PREFIX)/lib/python2.7/site-packages/"
+CROSSFLAGS=PYTHONXCPREFIX="$(PREFIX)" CC="$(CC) $(CFLAGS)" LDSHARED="$(CC) -shared" LDFLAGS="$(LDFLAGS)" PYTHONPATH="$(PREFIX)/lib/python3.6/site-packages/"
 ifeq ($(OS),android)
 PILPATH=$(PREFIX)/share/$(APP_NAME)/addons/script.module.pil
-CROSSFLAGS=PYTHONXCPREFIX="$(PREFIX)" CC="$(CC) $(CFLAGS)" LDSHARED="$(CC) -shared" LDFLAGS="$(LDFLAGS) -L$(PREFIX)/lib/dummy-lib$(APP_NAME)/ -l$(APP_NAME) -lm" PYTHONPATH="$(PILPATH):$(PREFIX)/lib/python2.7/site-packages/"
+CROSSFLAGS=PYTHONXCPREFIX="$(PREFIX)" CC="$(CC) $(CFLAGS)" LDSHARED="$(CC) -shared" LDFLAGS="$(LDFLAGS) -L$(PREFIX)/lib/dummy-lib$(APP_NAME)/ -l$(APP_NAME) -lm" PYTHONPATH="$(PILPATH):$(PREFIX)/lib/python3.6/site-packages/"
 endif
 
 ifeq (darwin, $(findstring darwin, $(HOST)))
 ifeq ($(OS),ios)
-PYTHON_O=$(abs_top_srcdir)/target/python27/$(PLATFORM)/Modules/python.o
+PYTHON_O=$(abs_top_srcdir)/target/python36/$(PLATFORM)/Programs/python.o
 endif
 #ensure that only our target ldflags are passed to the python build
 LDSHARED:=$(CC) -bundle -undefined dynamic_lookup $(LDFLAGS)
-CROSSFLAGS=PYTHONXCPREFIX="$(PREFIX)" CC="$(CC) $(CFLAGS)" CCSHARED="$(CC) $(CFLAGS) $(PYTHON_O)" LDFLAGS="$(LDFLAGS)" PYTHONPATH="$(PREFIX)/lib/python2.7/site-packages/" LDSHARED="$(LDSHARED)"
+CROSSFLAGS=PYTHONXCPREFIX="$(PREFIX)" CC="$(CC) $(CFLAGS)" CCSHARED="$(CC) $(CFLAGS) $(PYTHON_O)" LDFLAGS="$(LDFLAGS)" PYTHONPATH="$(PREFIX)/lib/python3.6/site-packages/" LDSHARED="$(LDSHARED)"
 endif
 
-LIBDYLIB=$(PLATFORM)/dist/PIL-$(VERSION)-py2.7-$(OS)-$(CPU).egg
+LIBDYLIB=$(PLATFORM)/dist/PIL-$(VERSION)-py3.6-$(OS)-$(CPU).egg
 ifeq ($(OS),android)
 LIBDYLIB=$(PREFIX)/share/$(APP_NAME)/addons/script.module.pil/lib/PIL/_imaging.so
 endif
@@ -42,16 +42,16 @@ $(PLATFORM): $(TARBALLS_LOCATION)/$(ARCHIVE) $(DEPS)
 
 $(LIBDYLIB): $(PLATFORM)
 	mkdir -p $(PLATFORM)/output
-	cd $(PLATFORM); $(CROSSFLAGS) $(NATIVEPREFIX)/bin/python setup.py build_ext --plat-name $(OS)-$(CPU)
+	cd $(PLATFORM); $(CROSSFLAGS) $(NATIVEPREFIX)/bin/python3 setup.py build_ext --plat-name $(OS)-$(CPU)
 
 .installed-$(PLATFORM): $(LIBDYLIB)
 ifeq ($(OS),android)
 	mkdir -p $(PREFIX)/share/$(APP_NAME)/addons/script.module.pil/lib
-	cd $(PLATFORM); $(CROSSFLAGS) $(NATIVEPREFIX)/bin/python setup.py install --install-lib  $(PREFIX)/share/$(APP_NAME)/addons/script.module.pil
+	cd $(PLATFORM); $(CROSSFLAGS) $(NATIVEPREFIX)/bin/python3 setup.py install --install-lib  $(PREFIX)/share/$(APP_NAME)/addons/script.module.pil
 	cd $(PREFIX)/share/$(APP_NAME)/addons/script.module.pil/lib && unzip -o ../Pillow-*.egg
 	cd $(PREFIX)/share/$(APP_NAME)/addons/script.module.pil && rm -rf Pillow-*.egg
 else
-	cd $(PLATFORM); $(CROSSFLAGS) $(NATIVEPREFIX)/bin/python setup.py install --prefix=$(PREFIX)
+	cd $(PLATFORM); $(CROSSFLAGS) $(NATIVEPREFIX)/bin/python3 setup.py install --prefix=$(PREFIX)
 endif
 	touch $@
 
diff --git a/tools/depends/target/pythonmodule-pil/pillow-crosscompile.patch b/tools/depends/target/pythonmodule-pil/pillow-crosscompile.patch
index 86e1a914f700..fc401f7d4c3c 100644
--- a/tools/depends/target/pythonmodule-pil/pillow-crosscompile.patch
+++ b/tools/depends/target/pythonmodule-pil/pillow-crosscompile.patch
@@ -26,7 +26,7 @@
          if prefix:
              _add_directory(library_dirs, os.path.join(prefix, "lib"))
              _add_directory(include_dirs, os.path.join(prefix, "include"))
-+            _add_directory(include_dirs, os.path.join(prefix, "include/python2.7"))
++            _add_directory(include_dirs, os.path.join(prefix, "include/python3.6"))
  
          #
          # add platform directories
diff --git a/tools/depends/target/pythonmodule-pycryptodome/Makefile b/tools/depends/target/pythonmodule-pycryptodome/Makefile
index 73bd4bb0f600..acfa16b37968 100644
--- a/tools/depends/target/pythonmodule-pycryptodome/Makefile
+++ b/tools/depends/target/pythonmodule-pycryptodome/Makefile
@@ -10,21 +10,21 @@ VERSION=3.4.3
 SOURCE=$(LIBNAME)-$(VERSION)
 ARCHIVE=$(SOURCE).tar.gz
 
-CROSSFLAGS=PYTHONXCPREFIX="$(PREFIX)" CC="$(CC) $(CFLAGS)" LDSHARED="$(CC) -shared" LDFLAGS="$(LDFLAGS)" PYTHONPATH="$(PREFIX)/lib/python2.7/site-packages/"
+CROSSFLAGS=PYTHONXCPREFIX="$(PREFIX)" CC="$(CC) $(CFLAGS)" LDSHARED="$(CC) -shared" LDFLAGS="$(LDFLAGS)" PYTHONPATH="$(PREFIX)/lib/python3.6/site-packages/"
 ifeq ($(OS),android)
-CROSSFLAGS=PYTHONXCPREFIX="$(PREFIX)" CC="$(CC) $(CFLAGS)" LDSHARED="$(CC) -shared" LDFLAGS="$(LDFLAGS) -L$(PREFIX)/lib/dummy-lib$(APP_NAME)/ -l$(APP_NAME) -lm" PYTHONPATH="$(PREFIX)/lib/python2.7/site-packages/"
+CROSSFLAGS=PYTHONXCPREFIX="$(PREFIX)" CC="$(CC) $(CFLAGS)" LDSHARED="$(CC) -shared" LDFLAGS="$(LDFLAGS) -L$(PREFIX)/lib/dummy-lib$(APP_NAME)/ -l$(APP_NAME) -lm" PYTHONPATH="$(PREFIX)/lib/python3.6/site-packages/"
 endif
 
 ifeq (darwin, $(findstring darwin, $(HOST)))
 ifeq ($(OS),ios)
-PYTHON_O=$(abs_top_srcdir)/target/python27/$(PLATFORM)/Modules/python.o
+PYTHON_O=$(abs_top_srcdir)/target/python36/$(PLATFORM)/Modules/python.o
 endif
 #ensure that only our target ldflags are passed to the python build
 LDSHARED:=$(CC) -bundle -undefined dynamic_lookup $(LDFLAGS)
-CROSSFLAGS=PYTHONXCPREFIX="$(PREFIX)" CC="$(CC) $(CFLAGS)" CCSHARED="$(CC) $(CFLAGS) $(PYTHON_O)" LDFLAGS="$(LDFLAGS)" PYTHONPATH="$(PREFIX)/lib/python2.7/site-packages/" LDSHARED="$(LDSHARED)"
+CROSSFLAGS=PYTHONXCPREFIX="$(PREFIX)" CC="$(CC) $(CFLAGS)" CCSHARED="$(CC) $(CFLAGS) $(PYTHON_O)" LDFLAGS="$(LDFLAGS)" PYTHONPATH="$(PREFIX)/lib/python3.6/site-packages/" LDSHARED="$(LDSHARED)"
 endif
 
-LIBDYLIB=$(PLATFORM)/dist/$(LIBNAME)-$(VERSION)-py2.7.egg
+LIBDYLIB=$(PLATFORM)/dist/$(LIBNAME)-$(VERSION)-py3.6.egg
 
 all: .installed-$(PLATFORM)
 
@@ -41,10 +41,10 @@ endif
 
 $(LIBDYLIB): $(PLATFORM)
 	mkdir -p $(PLATFORM)/output
-	cd $(PLATFORM); touch .separate_namespace && $(CROSSFLAGS) $(NATIVEPREFIX)/bin/python setup.py build_ext --plat-name $(OS)-$(TARGET_ARCH)
+	cd $(PLATFORM); touch .separate_namespace && $(CROSSFLAGS) $(NATIVEPREFIX)/bin/python3 setup.py build_ext --plat-name $(OS)-$(TARGET_ARCH)
 
 .installed-$(PLATFORM): $(LIBDYLIB)
-	cd $(PLATFORM); $(CROSSFLAGS) $(NATIVEPREFIX)/bin/python setup.py install --prefix=$(PREFIX)
+	cd $(PLATFORM); $(CROSSFLAGS) $(NATIVEPREFIX)/bin/python3 setup.py install --prefix=$(PREFIX)
 	touch $@
 
 clean:
diff --git a/tools/depends/target/pythonmodule-setuptools/Makefile b/tools/depends/target/pythonmodule-setuptools/Makefile
index f4b29d555965..c7b7ccd3c75d 100644
--- a/tools/depends/target/pythonmodule-setuptools/Makefile
+++ b/tools/depends/target/pythonmodule-setuptools/Makefile
@@ -10,20 +10,20 @@ VERSION=18.4
 SOURCE=$(LIBNAME)-$(VERSION)
 ARCHIVE=$(SOURCE).tar.gz
 
-CROSSFLAGS=PYTHONXCPREFIX="$(PREFIX)" CC="$(CC) $(CFLAGS)" LDSHARED="$(CC) -shared" LDFLAGS="$(LDFLAGS)" PYTHONPATH="$(PREFIX)/lib/python2.7/site-packages/"
+CROSSFLAGS=PYTHONXCPREFIX="$(PREFIX)" CC="$(CC) $(CFLAGS)" LDSHARED="$(CC) -shared" LDFLAGS="$(LDFLAGS)" PYTHONPATH="$(PREFIX)/lib/python3.6/site-packages/"
 ifeq ($(OS),android)
 #PYTHONPATH=$(PREFIX)/share/$(APP_NAME)/addons/script.module.pil
-CROSSFLAGS=PYTHONXCPREFIX="$(PREFIX)" CC="$(CC) $(CFLAGS)" LDSHARED="$(CC) -shared" LDFLAGS="$(LDFLAGS) -L$(PREFIX)/lib/dummy-lib$(APP_NAME)/ -l$(APP_NAME) -lm" PYTHONPATH="$(PREFIX)/lib/python2.7/site-packages/"
+CROSSFLAGS=PYTHONXCPREFIX="$(PREFIX)" CC="$(CC) $(CFLAGS)" LDSHARED="$(CC) -shared" LDFLAGS="$(LDFLAGS) -L$(PREFIX)/lib/dummy-lib$(APP_NAME)/ -l$(APP_NAME) -lm" PYTHONPATH="$(PREFIX)/lib/python3.6/site-packages/"
 endif
 ifeq ($(OS),osx)
-CROSSFLAGS=PYTHONXCPREFIX="$(PREFIX)" CC="$(CC)" LDSHARED="$(CC) -shared" LDFLAGS="$(LDFLAGS) -lpython" PYTHONPATH="$(PREFIX)/lib/python2.7/site-packages/"
+CROSSFLAGS=PYTHONXCPREFIX="$(PREFIX)" CC="$(CC)" LDSHARED="$(CC) -shared" LDFLAGS="$(LDFLAGS) -lpython" PYTHONPATH="$(PREFIX)/lib/python3.6/site-packages/"
 endif
 ifeq ($(OS),ios)
-PYTHON_O=$(abs_top_srcdir)/target/python27/$(PLATFORM)/Modules/python.o
-CROSSFLAGS=PYTHONXCPREFIX="$(PREFIX)" CC="$(CC) $(CFLAGS)" CCSHARED="$(CC) $(CFLAGS) $(PYTHON_O)" LDFLAGS="$(LDFLAGS)" PYTHONPATH="$(PREFIX)/lib/python2.7/site-packages/"
+PYTHON_O=$(abs_top_srcdir)/target/python36/$(PLATFORM)/Modules/python.o
+CROSSFLAGS=PYTHONXCPREFIX="$(PREFIX)" CC="$(CC) $(CFLAGS)" CCSHARED="$(CC) $(CFLAGS) $(PYTHON_O)" LDFLAGS="$(LDFLAGS)" PYTHONPATH="$(PREFIX)/lib/python3.6/site-packages/"
 endif
 
-LIBDYLIB=$(PLATFORM)/dist/$(LIBNAME)-$(VERSION)-py2.7.egg
+LIBDYLIB=$(PLATFORM)/dist/$(LIBNAME)-$(VERSION)-py3.6.egg
 
 all: .installed-$(PLATFORM)
 
@@ -36,10 +36,10 @@ $(PLATFORM): $(TARBALLS_LOCATION)/$(ARCHIVE) $(DEPS)
 
 $(LIBDYLIB): $(PLATFORM)
 	mkdir -p $(PLATFORM)/output
-	cd $(PLATFORM); $(CROSSFLAGS) $(NATIVEPREFIX)/bin/python setup.py build_ext --plat-name $(OS)-$(CPU)
+	cd $(PLATFORM); $(CROSSFLAGS) $(NATIVEPREFIX)/bin/python3 setup.py build_ext --plat-name $(OS)-$(CPU)
 
 .installed-$(PLATFORM): $(LIBDYLIB)
-	cd $(PLATFORM); $(CROSSFLAGS) $(NATIVEPREFIX)/bin/python setup.py install --prefix=$(PREFIX)
+	cd $(PLATFORM); $(CROSSFLAGS) $(NATIVEPREFIX)/bin/python3 setup.py install --prefix=$(PREFIX)
 	touch $@
 
 clean:

From 1b5d2bb6df69c49b68cdbe6eaafa9f17206768ff Mon Sep 17 00:00:00 2001
From: Arpit Nandwani <arpit.nandwani@gmail.com>
Date: Sun, 20 Aug 2017 17:32:31 +0530
Subject: [PATCH 15/25] Added Rasberry Pi Fix

---
 tools/depends/Makefile.include.in                  |  7 ++++
 tools/depends/native/Makefile                      |  8 +++--
 tools/depends/native/binutils-native/Makefile      | 37 ++++++++++++++++++++++
 .../native/binutils-native/readelfOnly.patch       | 37 ++++++++++++++++++++++
 tools/depends/target/python36/Makefile             |  6 ----
 5 files changed, 87 insertions(+), 8 deletions(-)
 create mode 100644 tools/depends/native/binutils-native/Makefile
 create mode 100644 tools/depends/native/binutils-native/readelfOnly.patch

diff --git a/tools/depends/Makefile.include.in b/tools/depends/Makefile.include.in
index 70b2b2c62629..9993ad3432ee 100644
--- a/tools/depends/Makefile.include.in
+++ b/tools/depends/Makefile.include.in
@@ -112,3 +112,10 @@ export LIBTOOLIZE=@prefix@/@tool_dir@/bin/libtoolize
 export AUTORECONF=@prefix@/@tool_dir@/bin/autoreconf
 export JSON_BUILDER=$(NATIVEPREFIX)/bin/JsonSchemaBuilder
 
+ifeq ($(OS), $(filter $(OS), osx ios))
+    export READELF=$(NATIVEPREFIX)/bin/readelf
+endif
+
+ifeq ($(TARGET_PLATFORM),raspberry-pi)
+  export READELF=$(NATIVEPREFIX)/bin/readelf
+endif
diff --git a/tools/depends/native/Makefile b/tools/depends/native/Makefile
index fbd5829615fd..7635f02a20c9 100644
--- a/tools/depends/native/Makefile
+++ b/tools/depends/native/Makefile
@@ -14,17 +14,21 @@ NATIVE= m4-native gettext-native autoconf-native automake-native \
 
 
 ifeq ($(OS),ios)
-  NATIVE += dpkg-native xz-native tar-native fakeroot-native gen_entitlements-native ldid-native
+  NATIVE += binutils-native dpkg-native xz-native tar-native fakeroot-native gen_entitlements-native ldid-native
 endif
 
 ifeq ($(OS),osx)
-  NATIVE += xz-native tar-native
+  NATIVE += binutils-native xz-native tar-native
 endif
 
 ifeq ($(ENABLE_WAYLAND),yes)
   NATIVE += expat-native wayland-scanner-native scons-native
 endif
 
+ifeq ($(TARGET_PLATFORM),raspberry-pi)
+  NATIVE += binutils-native
+endif
+
 .PHONY: $(NATIVE) native
 
 all: native
diff --git a/tools/depends/native/binutils-native/Makefile b/tools/depends/native/binutils-native/Makefile
new file mode 100644
index 000000000000..3a4c6f84ec18
--- /dev/null
+++ b/tools/depends/native/binutils-native/Makefile
@@ -0,0 +1,37 @@
+include ../../Makefile.include
+PLATFORM=$(NATIVEPLATFORM)
+DEPS= ../../Makefile.include Makefile readelfOnly.patch
+
+# lib name, version
+LIBNAME=binutils
+VERSION=2.29
+SOURCE=$(LIBNAME)-$(VERSION)
+ARCHIVE=$(SOURCE).tar.gz
+
+CONFIGURE=./configure --prefix=$(NATIVEPREFIX)
+
+LIBDYLIB=$(PLATFORM)/binutils/readelf
+
+all: .installed-$(PLATFORM)
+
+$(TARBALLS_LOCATION)/$(ARCHIVE):
+	cd $(TARBALLS_LOCATION); $(RETRIEVE_TOOL) $(RETRIEVE_TOOL_FLAGS) $(BASE_URL)/$(ARCHIVE)
+
+$(PLATFORM): $(TARBALLS_LOCATION)/$(ARCHIVE) $(DEPS)
+	rm -rf $(PLATFORM)/*; mkdir -p $(PLATFORM)
+	cd $(PLATFORM); $(ARCHIVE_TOOL) $(ARCHIVE_TOOL_FLAGS) $(TARBALLS_LOCATION)/$(ARCHIVE)
+	cd $(PLATFORM); patch -p1 -i ../readelfOnly.patch
+	cd $(PLATFORM); $(CONFIGURE)
+
+$(LIBDYLIB): $(PLATFORM)
+	$(MAKE) -C $(PLATFORM) all-binutils
+
+.installed-$(PLATFORM): $(LIBDYLIB)
+	cd $(PLATFORM)/binutils; $(MAKE) install-binPROGRAMS
+	touch $@
+
+clean:
+	rm -rf $(PLATFORM) .installed-$(PLATFORM)
+
+distclean::
+	rm -rf $(PLATFORM) .installed-$(PLATFORM)
diff --git a/tools/depends/native/binutils-native/readelfOnly.patch b/tools/depends/native/binutils-native/readelfOnly.patch
new file mode 100644
index 000000000000..6afebc70cfaf
--- /dev/null
+++ b/tools/depends/native/binutils-native/readelfOnly.patch
@@ -0,0 +1,37 @@
+--- a/Makefile.in
++++ b/Makefile.in
+@@ -5129,7 +5129,7 @@
+ all-binutils: stage_current
+ @endif gcc-bootstrap
+ @if binutils
+-TARGET-binutils=all
++TARGET-binutils=readelf
+ maybe-all-binutils: all-binutils
+ all-binutils: configure-binutils
+ 	@r=`${PWD_COMMAND}`; export r; \
+--- a/binutils/Makefile.am
++++ b/binutils/Makefile.am
+@@ -86,7 +86,7 @@
+ 
+ SRCONV_PROG=srconv$(EXEEXT) sysdump$(EXEEXT) coffdump$(EXEEXT)
+ 
+-bin_PROGRAMS = $(SIZE_PROG) $(OBJDUMP_PROG) $(AR_PROG) $(STRINGS_PROG) $(RANLIB_PROG) $(OBJCOPY_PROG) @BUILD_NLMCONV@ @BUILD_SRCONV@ @BUILD_DLLTOOL@ @BUILD_WINDRES@ @BUILD_WINDMC@ $(ADDR2LINE_PROG) $(READELF_PROG) $(ELFEDIT_PROG) @BUILD_DLLWRAP@
++bin_PROGRAMS = $(READELF_PROG)
+ 
+ bin_SCRIPTS = @BUILD_INSTALL_MISC@
+ EXTRA_SCRIPTS = embedspu
+--- a/binutils/Makefile.in
++++ b/binutils/Makefile.in
+@@ -71,11 +71,7 @@
+ build_triplet = @build@
+ host_triplet = @host@
+ target_triplet = @target@
+-bin_PROGRAMS = $(am__EXEEXT_6) $(am__EXEEXT_7) $(am__EXEEXT_8) \
+-	$(am__EXEEXT_9) $(am__EXEEXT_10) $(am__EXEEXT_11) \
+-	@BUILD_NLMCONV@ @BUILD_SRCONV@ @BUILD_DLLTOOL@ @BUILD_WINDRES@ \
+-	@BUILD_WINDMC@ $(am__EXEEXT_12) $(am__EXEEXT_13) \
+-	$(am__EXEEXT_14) @BUILD_DLLWRAP@
++bin_PROGRAMS = $(am__EXEEXT_13)
+ noinst_PROGRAMS = $(am__EXEEXT_18) $(am__EXEEXT_21) @BUILD_MISC@
+ EXTRA_PROGRAMS = $(am__EXEEXT_1) srconv$(EXEEXT) sysdump$(EXEEXT) \
+ 	coffdump$(EXEEXT) $(am__EXEEXT_2) $(am__EXEEXT_3) \
diff --git a/tools/depends/target/python36/Makefile b/tools/depends/target/python36/Makefile
index 8612c26f3347..197a9aaebdd8 100644
--- a/tools/depends/target/python36/Makefile
+++ b/tools/depends/target/python36/Makefile
@@ -10,16 +10,10 @@ ARCHIVE=$(SOURCE).tar.xz
 
 ifeq ($(OS),osx)
   HOSTPLATFORM=_PYTHON_HOST_PLATFORM="darwin"
-  export READELF=$(NATIVEPREFIX)/bin/readelf
 endif
 ifeq ($(OS),ios)
   HOSTPLATFORM=_PYTHON_HOST_PLATFORM="darwin"
   LINK_ICONV=-framework CoreFoundation -liconv
-  export READELF=$(NATIVEPREFIX)/bin/readelf
-endif
-
-ifeq ($(TARGET_PLATFORM),raspberry-pi)
-  export READELF=$(NATIVEPREFIX)/bin/readelf
 endif
 
 # configuration settings

From 009633f92ee52b55a30954b07048f310ca4ce769 Mon Sep 17 00:00:00 2001
From: Arpit Nandwani <arpit.nandwani@gmail.com>
Date: Sun, 20 Aug 2017 17:33:34 +0530
Subject: [PATCH 16/25] Added IOS and OSX Fix

---
 tools/darwin/Support/copyframeworks-ios.command |  8 ++++----
 tools/darwin/Support/copyframeworks-osx.command | 10 +++++-----
 tools/depends/target/python36/Makefile          |  1 +
 tools/depends/target/python36/apple.patch       | 12 ++++++++++++
 4 files changed, 22 insertions(+), 9 deletions(-)
 create mode 100644 tools/depends/target/python36/apple.patch

diff --git a/tools/darwin/Support/copyframeworks-ios.command b/tools/darwin/Support/copyframeworks-ios.command
index d52033ebf931..73487f2f515e 100755
--- a/tools/darwin/Support/copyframeworks-ios.command
+++ b/tools/darwin/Support/copyframeworks-ios.command
@@ -74,14 +74,14 @@ for a in $(otool -L "$TARGET_BINARY"  | grep "$EXTERNAL_LIBS\|$DYLIB_NAMEPATH" |
   install_name_tool -change "$a" "$DYLIB_NAMEPATH/$(basename $a)" "$TARGET_BINARY"
 done
 
-echo "Package $EXTERNAL_LIBS/lib/python2.7"
+echo "Package $EXTERNAL_LIBS/lib/python3.6"
 mkdir -p "$TARGET_CONTENTS/Frameworks/lib"
 PYTHONSYNC="rsync -aq --exclude .DS_Store --exclude *.a --exclude *.exe --exclude test --exclude tests"
-${PYTHONSYNC} "$EXTERNAL_LIBS/lib/python2.7" "$TARGET_FRAMEWORKS/lib/"
-rm -rf "$TARGET_FRAMEWORKS/lib/python2.7/config"
+${PYTHONSYNC} "$EXTERNAL_LIBS/lib/python3.6" "$TARGET_FRAMEWORKS/lib/"
+rm -rf "$TARGET_FRAMEWORKS/lib/python3.6/config"
 
 echo "Checking python *.so for dylib dependencies"
-check_xbmc_dylib_depends "$TARGET_FRAMEWORKS"/lib/python2.7 "*.so"
+check_xbmc_dylib_depends "$TARGET_FRAMEWORKS"/lib/python3.6 "*.so"
 
 echo "Checking system *.so for dylib dependencies"
 check_xbmc_dylib_depends "$XBMC_HOME"/system "*.so"
diff --git a/tools/darwin/Support/copyframeworks-osx.command b/tools/darwin/Support/copyframeworks-osx.command
index 2ac16b45d3c8..a607a15f904f 100755
--- a/tools/darwin/Support/copyframeworks-osx.command
+++ b/tools/darwin/Support/copyframeworks-osx.command
@@ -81,14 +81,14 @@ for a in $(otool -LX "$TARGET_BINARY"  | grep "$EXTERNAL_LIBS" | awk ' { print $
 	install_name_tool -change "$a" "$DYLIB_NAMEPATH/$(basename $a)" "$TARGET_BINARY"
 done
 
-echo "Package $EXTERNAL_LIBS/lib/python2.7"
+echo "Package $EXTERNAL_LIBS/lib/python3.6"
 mkdir -p "$TARGET_CONTENTS/Libraries/lib"
 PYTHONSYNC="rsync -aq --exclude .DS_Store --exclude *.a --exclude *.exe --exclude test --exclude tests"
-${PYTHONSYNC} "$EXTERNAL_LIBS/lib/python2.7" "$TARGET_FRAMEWORKS/lib/"
-rm -rf "$TARGET_FRAMEWORKS/lib/python2.7/config"
+${PYTHONSYNC} "$EXTERNAL_LIBS/lib/python3.6" "$TARGET_FRAMEWORKS/lib/"
+rm -rf "$TARGET_FRAMEWORKS/lib/python3.6/config"
 
-echo "Checking $TARGET_FRAMEWORKS/lib/python2.7 *.so for dylib dependencies"
-check_xbmc_dylib_depends "$TARGET_FRAMEWORKS"/lib/python2.7 "*.so"
+echo "Checking $TARGET_FRAMEWORKS/lib/python3.6 *.so for dylib dependencies"
+check_xbmc_dylib_depends "$TARGET_FRAMEWORKS"/lib/python3.6 "*.so"
 
 echo "Checking $XBMC_HOME/system *.so for dylib dependencies"
 check_xbmc_dylib_depends "$XBMC_HOME"/system "*.so"
diff --git a/tools/depends/target/python36/Makefile b/tools/depends/target/python36/Makefile
index 197a9aaebdd8..ee4b8ca42d8b 100644
--- a/tools/depends/target/python36/Makefile
+++ b/tools/depends/target/python36/Makefile
@@ -37,6 +37,7 @@ $(PLATFORM): $(TARBALLS_LOCATION)/$(ARCHIVE) $(DEPS)
 	cd $(PLATFORM); patch -p0 < ../fix-datetime.patch
 	cd $(PLATFORM); patch -p0 < ../Python-3.6.2-android.patch
 	cd $(PLATFORM); patch -p0 < ../fix-ffi.patch
+	cd $(PLATFORM); patch -p1 -i ../apple.patch
 ifeq ($(OS),ios)
 	cd $(PLATFORM); patch -p0 < ../make-fork-optional.patch
 	cd $(PLATFORM); sed -ie 's|MACHDEP="unknown"|MACHDEP="darwin"|' configure.ac
diff --git a/tools/depends/target/python36/apple.patch b/tools/depends/target/python36/apple.patch
new file mode 100644
index 000000000000..912c719791e2
--- /dev/null
+++ b/tools/depends/target/python36/apple.patch
@@ -0,0 +1,12 @@
+--- a/Modules/posixmodule.c
++++ b/Modules/posixmodule.c
+@@ -111,6 +111,9 @@
+ #include <sys/xattr.h>
+ #endif
+ 
++#if defined(__APPLE__) && defined(_POSIX_C_SOURCE)
++#undef _POSIX_C_SOURCE
++#endif
+ #if defined(__FreeBSD__) || defined(__DragonFly__) || defined(__APPLE__)
+ #ifdef HAVE_SYS_SOCKET_H
+ #include <sys/socket.h>

From c41e94480c0c261978e5bd5f0c11fcacf1f2c3a2 Mon Sep 17 00:00:00 2001
From: Arpit Nandwani <arpit.nandwani@gmail.com>
Date: Sun, 20 Aug 2017 17:35:02 +0530
Subject: [PATCH 17/25] Added Android Fix

---
 cmake/scripts/android/Install.cmake             |  2 +-
 tools/android/packaging/Makefile.in             | 10 +++++-----
 tools/android/packaging/xbmc/src/Splash.java.in |  2 +-
 xbmc/cores/DllLoader/exports/emu_msvcrt.cpp     |  6 +++---
 xbmc/platform/android/activity/XBMCApp.cpp      |  4 ++--
 5 files changed, 12 insertions(+), 12 deletions(-)

diff --git a/cmake/scripts/android/Install.cmake b/cmake/scripts/android/Install.cmake
index 46181f70034b..b6d40d8b5947 100644
--- a/cmake/scripts/android/Install.cmake
+++ b/cmake/scripts/android/Install.cmake
@@ -64,7 +64,7 @@ add_custom_target(bundle
                                                ${CMAKE_BINARY_DIR}/tools/android/packaging/media
     COMMAND ${CMAKE_COMMAND} -E copy_directory ${CMAKE_SOURCE_DIR}/tools/android/packaging/xbmc/res
                                                ${CMAKE_BINARY_DIR}/tools/android/packaging/xbmc/res
-    COMMAND ${CMAKE_COMMAND} -E copy_directory ${DEPENDS_PATH}/lib/python2.7 ${libdir}/python2.7
+    COMMAND ${CMAKE_COMMAND} -E copy_directory ${DEPENDS_PATH}/lib/python3.6 ${libdir}/python3.6
     COMMAND ${CMAKE_COMMAND} -E copy_directory ${DEPENDS_PATH}/share/${APP_NAME_LC} ${datadir}/${APP_NAME_LC}
     COMMAND ${CMAKE_COMMAND} -E copy $<TARGET_FILE:${APP_NAME_LC}>
                                      ${libdir}/${APP_NAME_LC}/$<TARGET_FILE_NAME:${APP_NAME_LC}>)
diff --git a/tools/android/packaging/Makefile.in b/tools/android/packaging/Makefile.in
index 11d73c30f0af..d688a0e0902a 100644
--- a/tools/android/packaging/Makefile.in
+++ b/tools/android/packaging/Makefile.in
@@ -106,9 +106,9 @@ sharedobb: shared
 	@echo "$(CMAKE_SOURCE_DIR)/main.@APP_NAME_LC@.obb created"
 
 python: | xbmc/assets
-	mkdir -p xbmc/assets/python2.7/lib/
-	cp -rfp $(PREFIX)/lib/python2.7 xbmc/assets/python2.7/lib/
-	cd xbmc/assets/python2.7/lib/python2.7/; rm -rf test config lib-dynload
+	mkdir -p xbmc/assets/python3.6/lib/
+	cp -rfp $(PREFIX)/lib/python3.6 xbmc/assets/python3.6/lib/
+	cd xbmc/assets/python3.6/lib/python3.6/; rm -rf test config lib-dynload
 
 res:
 	mkdir -p xbmc/gen/$(APP_PACKAGE_DIR) xbmc/res xbmc/res/raw xbmc/res/values images
@@ -132,7 +132,7 @@ res:
 
 libs: $(PREFIX)/lib/@APP_NAME_LC@/lib@APP_NAME_LC@.so
 	rm -rf xbmc/lib/$(CPU) xbmc/obj/local/$(CPU)
-	mkdir -p xbmc/lib/$(CPU) xbmc/assets/python2.7/lib/ xbmc/obj/local/$(CPU)
+	mkdir -p xbmc/lib/$(CPU) xbmc/assets/python3.6/lib/ xbmc/obj/local/$(CPU)
 	cp -fpL $(SRCLIBS) xbmc/obj/local/$(CPU)/
 	cp -fp $(PREFIX)/lib/@APP_NAME_LC@/lib@APP_NAME_LC@.so xbmc/obj/local/$(CPU)/
 	find $(PREFIX)/lib/@APP_NAME_LC@/addons -name "*.so" -exec cp -fp {} xbmc/obj/local/$(CPU)/ \; || true
@@ -140,7 +140,7 @@ libs: $(PREFIX)/lib/@APP_NAME_LC@/lib@APP_NAME_LC@.so
 	find $(DEPENDS_PATH)/share/kodi/addons -name "*.so" -exec cp -fp {} xbmc/obj/local/$(CPU)/ \; || true
 	find $(DEPENDS_PATH)/lib/kodi/addons -name "*.so" -exec cp -fp {} xbmc/obj/local/$(CPU)/ \; || true
 	find $(PREFIX)/lib/@APP_NAME_LC@/system -name "*.so" -exec cp -fp {} xbmc/obj/local/$(CPU)/ \;
-	DIR=${CURDIR}; cd $(PREFIX)/lib/python2.7/site-packages; for i in `find Cryptodome -name \*.so` ; do FN=`echo $$i | cut -c1- | tr "/" "_"` ; mv $$i $$DIR/xbmc/obj/local/$(CPU)/$$FN ; done
+	DIR=${CURDIR}; cd $(PREFIX)/lib/python3.6/site-packages; for i in `find Cryptodome -name \*.so` ; do FN=`echo $$i | cut -c1- | tr "/" "_"` ; mv $$i $$DIR/xbmc/obj/local/$(CPU)/$$FN ; done
 	cd xbmc/obj/local/$(CPU)/; find . -name "*.so" -not -name "lib*.so" | sed "s/\.\///" | xargs -I@ mv @ lib@
 	cp -fp xbmc/obj/local/$(CPU)/*.so xbmc/lib/$(CPU)/
 	$(STRIP) --strip-unneeded xbmc/lib/$(CPU)/*.so
diff --git a/tools/android/packaging/xbmc/src/Splash.java.in b/tools/android/packaging/xbmc/src/Splash.java.in
index cf64f3dfcb53..746c24ae5532 100644
--- a/tools/android/packaging/xbmc/src/Splash.java.in
+++ b/tools/android/packaging/xbmc/src/Splash.java.in
@@ -320,7 +320,7 @@ public class Splash extends Activity {
 
           if (! (sName.startsWith("assets/") || (mInstallLibs && sName.startsWith("lib/"))) )
             continue;
-          if (sName.startsWith("assets/python2.7"))
+          if (sName.startsWith("assets/python"))
             continue;
 
           String sFullPath = null;
diff --git a/xbmc/cores/DllLoader/exports/emu_msvcrt.cpp b/xbmc/cores/DllLoader/exports/emu_msvcrt.cpp
index 89cf87ced581..1865a2ef0c01 100644
--- a/xbmc/cores/DllLoader/exports/emu_msvcrt.cpp
+++ b/xbmc/cores/DllLoader/exports/emu_msvcrt.cpp
@@ -143,8 +143,8 @@ extern "C" void __stdcall init_emu_environ()
   // check if we are running as real xbmc.app or just binary
   if (!CUtil::GetFrameworksPath(true).empty())
   {
-    // using external python, it's build looking for xxx/lib/python2.7
-    // so point it to frameworks which is where python2.7 is located
+    // using external python, it's build looking for xxx/lib/python3.6
+    // so point it to frameworks which is where python3.6 is located
     dll_putenv(std::string("PYTHONPATH=" +
       CSpecialProtocol::TranslatePath("special://frameworks")).c_str());
     dll_putenv(std::string("PYTHONHOME=" +
@@ -166,7 +166,7 @@ extern "C" void __stdcall init_emu_environ()
 
 #if defined(TARGET_ANDROID)
   std::string apkPath = getenv("XBMC_ANDROID_APK");
-  apkPath += "/assets/python2.7";
+  apkPath += "/assets/python3.6";
   dll_putenv(std::string("PYTHONHOME=" + apkPath).c_str());
   dll_putenv("PYTHONOPTIMIZE=");
   dll_putenv("PYTHONNOUSERSITE=1");
diff --git a/xbmc/platform/android/activity/XBMCApp.cpp b/xbmc/platform/android/activity/XBMCApp.cpp
index df6f613d1629..318a85c5e33d 100644
--- a/xbmc/platform/android/activity/XBMCApp.cpp
+++ b/xbmc/platform/android/activity/XBMCApp.cpp
@@ -352,7 +352,7 @@ void CXBMCApp::onLostFocus()
 
 void CXBMCApp::Initialize()
 {
-  g_application.m_ServiceManager->GetAnnouncementManager().AddAnnouncer(CXBMCApp::get());  
+  g_application.m_ServiceManager->GetAnnouncementManager().AddAnnouncer(CXBMCApp::get());
 }
 
 void CXBMCApp::Deinitialize()
@@ -1186,7 +1186,7 @@ void CXBMCApp::SetupEnv()
     setenv("HOME", getenv("KODI_TEMP"), 0);
 
   std::string apkPath = getenv("XBMC_ANDROID_APK");
-  apkPath += "/assets/python2.7";
+  apkPath += "/assets/python3.6";
   setenv("PYTHONHOME", apkPath.c_str(), 1);
   setenv("PYTHONPATH", "", 1);
   setenv("PYTHONOPTIMIZE","", 1);

From cffd9f2620c29739891ea452ef430f681acc9f6a Mon Sep 17 00:00:00 2001
From: Arpit Nandwani <arpit.nandwani@gmail.com>
Date: Sun, 20 Aug 2017 17:59:54 +0530
Subject: [PATCH 18/25] Updated versioncheck addon for Python3

---
 addons/service.xbmc.versioncheck/README.md         |  2 +-
 addons/service.xbmc.versioncheck/addon.xml         |  2 +-
 addons/service.xbmc.versioncheck/changelog.txt     |  8 +--
 addons/service.xbmc.versioncheck/lib/__init__.py   |  2 +-
 .../{aptdeamonhandler.py => aptdaemonhandler.py}   |  4 +-
 addons/service.xbmc.versioncheck/lib/common.py     | 25 +++++--
 .../service.xbmc.versioncheck/lib/jsoninterface.py | 12 +++-
 .../lib/shellhandlerapt.py                         |  2 +-
 addons/service.xbmc.versioncheck/lib/versions.py   |  4 +-
 addons/service.xbmc.versioncheck/lib/viewer.py     | 14 ++--
 .../resources/language/Hebrew/strings.po           |  2 +-
 .../resources/language/Korean/strings.po           |  2 +-
 .../resources/versions.txt                         | 78 ++++++++++++++++++++++
 addons/service.xbmc.versioncheck/service.py        | 20 ++++--
 14 files changed, 139 insertions(+), 38 deletions(-)
 rename addons/service.xbmc.versioncheck/lib/{aptdeamonhandler.py => aptdaemonhandler.py} (97%)

diff --git a/addons/service.xbmc.versioncheck/README.md b/addons/service.xbmc.versioncheck/README.md
index 1442d6f532aa..5f8cbc56e50c 100644
--- a/addons/service.xbmc.versioncheck/README.md
+++ b/addons/service.xbmc.versioncheck/README.md
@@ -3,4 +3,4 @@ XBMC Versioncheck
 
 This service checks the installed XBMC version against the next available one and notifies you if there is a new version available.
 When a new version comes out the versions.txt should be updated to reflect the latest version available.
-When updating the version.txt always put latest release at the top since the list is read in chronilogical order.
+When updating the version.txt always put latest release at the top since the list is read in chronological order.
diff --git a/addons/service.xbmc.versioncheck/addon.xml b/addons/service.xbmc.versioncheck/addon.xml
index 2601eb69fe63..c10315dd6f89 100644
--- a/addons/service.xbmc.versioncheck/addon.xml
+++ b/addons/service.xbmc.versioncheck/addon.xml
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
 <addon id="service.xbmc.versioncheck"
        name="Version Check"
-      version="0.3.17"
+      version="0.3.23"
       provider-name="Team Kodi">
     <requires>
         <import addon="xbmc.python" version="2.1.0"/>
diff --git a/addons/service.xbmc.versioncheck/changelog.txt b/addons/service.xbmc.versioncheck/changelog.txt
index 5e6e7bd660af..6e44656dc1bb 100644
--- a/addons/service.xbmc.versioncheck/changelog.txt
+++ b/addons/service.xbmc.versioncheck/changelog.txt
@@ -1,10 +1,4 @@
-v0.3.17
-- Update version list
-
-v0.3.16
-- Update version list
-
-v0.3.15
+v0.3.5 to v0.3.23
 - Update version list
 
 v0.3.14
diff --git a/addons/service.xbmc.versioncheck/lib/__init__.py b/addons/service.xbmc.versioncheck/lib/__init__.py
index 4b0dc39c7f8b..55e5f844b4a2 100644
--- a/addons/service.xbmc.versioncheck/lib/__init__.py
+++ b/addons/service.xbmc.versioncheck/lib/__init__.py
@@ -1 +1 @@
-from common import *
+from .common import *
diff --git a/addons/service.xbmc.versioncheck/lib/aptdeamonhandler.py b/addons/service.xbmc.versioncheck/lib/aptdaemonhandler.py
similarity index 97%
rename from addons/service.xbmc.versioncheck/lib/aptdeamonhandler.py
rename to addons/service.xbmc.versioncheck/lib/aptdaemonhandler.py
index 012312758c70..1e09b56100d6 100644
--- a/addons/service.xbmc.versioncheck/lib/aptdeamonhandler.py
+++ b/addons/service.xbmc.versioncheck/lib/aptdaemonhandler.py
@@ -16,7 +16,7 @@
 #    along with this program. If not, see <http://www.gnu.org/licenses/>.
 #
 import xbmc
-from common import *
+from .common import *
 
 try:
     #import apt
@@ -26,7 +26,7 @@
 except:
     log('python apt import error')
 
-class AptdeamonHandler:
+class AptdaemonHandler:
 
     def __init__(self):
         self.aptclient = client.AptClient()
diff --git a/addons/service.xbmc.versioncheck/lib/common.py b/addons/service.xbmc.versioncheck/lib/common.py
index 1aa62a3deed1..ffe0fe461b24 100644
--- a/addons/service.xbmc.versioncheck/lib/common.py
+++ b/addons/service.xbmc.versioncheck/lib/common.py
@@ -15,6 +15,7 @@
 #    You should have received a copy of the GNU General Public License
 #    along with this program. If not, see <http://www.gnu.org/licenses/>.
 #
+import sys
 
 import os
 import xbmc
@@ -25,8 +26,12 @@
 ADDON        = xbmcaddon.Addon()
 ADDONVERSION = ADDON.getAddonInfo('version')
 ADDONNAME    = ADDON.getAddonInfo('name')
-ADDONPATH    = ADDON.getAddonInfo('path').decode('utf-8')
-ADDONPROFILE = xbmc.translatePath( ADDON.getAddonInfo('profile') ).decode('utf-8')
+if sys.version_info.major >= 3:
+    ADDONPATH    = ADDON.getAddonInfo('path')
+    ADDONPROFILE = xbmc.translatePath( ADDON.getAddonInfo('profile') )
+else:
+    ADDONPATH    = ADDON.getAddonInfo('path').decode('utf-8')
+    ADDONPROFILE = xbmc.translatePath( ADDON.getAddonInfo('profile') ).decode('utf-8')
 ICON         = ADDON.getAddonInfo('icon')
 
 monitor = xbmc.Monitor()
@@ -34,7 +39,10 @@
 # Fixes unicode problems
 def string_unicode(text, encoding='utf-8'):
     try:
-        text = unicode( text, encoding )
+        if sys.version_info.major >= 3:
+            text = str( text )
+        else:
+            text = unicode( text, encoding )
     except:
         pass
     return text
@@ -51,10 +59,13 @@ def localise(id):
     return string
 
 def log(txt):
-    if isinstance (txt,str):
-        txt = txt.decode("utf-8")
-    message = u'%s: %s' % ("Version Check", txt)
-    xbmc.log(msg=message.encode("utf-8"), level=xbmc.LOGDEBUG)
+    if sys.version_info.major >= 3:
+        message = '%s: %s' % ("Version Check", txt.encode('utf-8'))
+    else:
+        if isinstance (txt,str):
+            txt = txt.decode("utf-8") 
+        message = (u'%s: %s' % ("Version Check", txt)).encode("utf-8")
+    xbmc.log(msg=message, level=xbmc.LOGDEBUG)
 
 def get_password_from_user():
     keyboard = xbmc.Keyboard("", ADDONNAME + "," +localise(32022), True)
diff --git a/addons/service.xbmc.versioncheck/lib/jsoninterface.py b/addons/service.xbmc.versioncheck/lib/jsoninterface.py
index 32395e890bde..8625e553dd19 100644
--- a/addons/service.xbmc.versioncheck/lib/jsoninterface.py
+++ b/addons/service.xbmc.versioncheck/lib/jsoninterface.py
@@ -31,10 +31,13 @@
 def get_installedversion():
     # retrieve current installed version
     json_query = xbmc.executeJSONRPC('{ "jsonrpc": "2.0", "method": "Application.GetProperties", "params": {"properties": ["version", "name"]}, "id": 1 }')
-    json_query = unicode(json_query, 'utf-8', errors='ignore')
+    if sys.version_info.major >= 3:
+        json_query = str(json_query)
+    else:
+        json_query = unicode(json_query, 'utf-8', errors='ignore')
     json_query = jsoninterface.loads(json_query)
     version_installed = []
-    if json_query.has_key('result') and json_query['result'].has_key('version'):
+    if 'result' in json_query and 'version' in json_query['result']:
         version_installed  = json_query['result']['version']
     return version_installed
     
@@ -48,6 +51,9 @@ def get_versionfilelist():
         file = xbmcvfs.File(version_file)
     data = file.read()
     file.close()
-    version_query = unicode(data, 'utf-8', errors='ignore')
+    if sys.version_info.major >= 3:
+        version_query = str(data)
+    else:
+        version_query = unicode(data, 'utf-8', errors='ignore')
     version_query = jsoninterface.loads(version_query)
     return version_query
diff --git a/addons/service.xbmc.versioncheck/lib/shellhandlerapt.py b/addons/service.xbmc.versioncheck/lib/shellhandlerapt.py
index b09ed1c269c7..9fbb0b5e5b69 100644
--- a/addons/service.xbmc.versioncheck/lib/shellhandlerapt.py
+++ b/addons/service.xbmc.versioncheck/lib/shellhandlerapt.py
@@ -16,7 +16,7 @@
 #    along with this program. If not, see <http://www.gnu.org/licenses/>.
 #
 import xbmc
-from common import *
+from .common import *
 
 try:
     from subprocess import check_output
diff --git a/addons/service.xbmc.versioncheck/lib/versions.py b/addons/service.xbmc.versioncheck/lib/versions.py
index 6ffa16611c04..b99151c6e32a 100644
--- a/addons/service.xbmc.versioncheck/lib/versions.py
+++ b/addons/service.xbmc.versioncheck/lib/versions.py
@@ -24,7 +24,7 @@ def compare_version(version_installed, versionlist):
     versionlist_rc = versionlist['releases']['releasecandidate']
     versionlist_beta = versionlist['releases']['beta']
     versionlist_alpha = versionlist['releases']['alpha']
-    versionlist_prealpha = versionlist['releases']['prealpha'] 
+    versionlist_prealpha = versionlist['releases']['prealpha']
     log('Version installed %s' %version_installed)
     ### Check to upgrade to newest available stable version
     # check on smaller major version. Smaller version than available always notify
@@ -122,6 +122,6 @@ def compare_version(version_installed, versionlist):
                 version_available = versionlist_alpha[0]
                 oldversion = True
                 log('Version available  %s' %versionlist_alpha[0])
-                log('You are running an older non alpha version')     
+                log('You are running an older non alpha version')
     version_stable = versionlist_stable[0]
     return oldversion, version_installed, version_available, version_stable
\ No newline at end of file
diff --git a/addons/service.xbmc.versioncheck/lib/viewer.py b/addons/service.xbmc.versioncheck/lib/viewer.py
index 58a3f379b3b6..186c46afbb47 100644
--- a/addons/service.xbmc.versioncheck/lib/viewer.py
+++ b/addons/service.xbmc.versioncheck/lib/viewer.py
@@ -28,8 +28,12 @@
 ADDON        = xbmcaddon.Addon('service.xbmc.versioncheck')
 ADDONVERSION = ADDON.getAddonInfo('version')
 ADDONNAME    = ADDON.getAddonInfo('name')
-ADDONPATH    = ADDON.getAddonInfo('path').decode('utf-8')
-ADDONPROFILE = xbmc.translatePath( ADDON.getAddonInfo('profile') ).decode('utf-8')
+if sys.version_info.major >= 3:
+    ADDONPATH    = ADDON.getAddonInfo('path')
+    ADDONPROFILE = xbmc.translatePath( ADDON.getAddonInfo('profile') )
+else:
+    ADDONPATH    = ADDON.getAddonInfo('path').decode('utf-8')
+    ADDONPROFILE = xbmc.translatePath( ADDON.getAddonInfo('profile') ).decode('utf-8')
 ICON         = ADDON.getAddonInfo('icon')
 
 class Viewer:
@@ -61,7 +65,7 @@ def getText(self):
         try:
             if sys.argv[ 1 ] == "gotham-alpha_notice":
                 return "Call to Gotham alpha users", self.readFile(os.path.join(ADDONPATH , "resources/gotham-alpha_notice.txt"))
-        except Exception, e:
+        except Exception as e:
             xbmc.log(ADDONNAME + ': ' + str(e), xbmc.LOGERROR)
         return "", ""
 
@@ -79,7 +83,7 @@ def __init__(self, *args, **kwargs):
             xbmc.sleep(100)
             # launch url
             self.launchUrl(url)
-        except Exception, e:
+        except Exception as e:
             xbmc.log(ADDONNAME + ': ' + str(e), xbmc.LOGERROR)
 
     def launchUrl(self, url):
@@ -92,7 +96,7 @@ def Main():
             WebBrowser()
         else:
             Viewer()
-    except Exception, e:
+    except Exception as e:
         xbmc.log(ADDONNAME + ': ' + str(e), xbmc.LOGERROR)
 
 if (__name__ == "__main__"):
diff --git a/addons/service.xbmc.versioncheck/resources/language/Hebrew/strings.po b/addons/service.xbmc.versioncheck/resources/language/Hebrew/strings.po
index a32554a939a2..704289a898a9 100644
--- a/addons/service.xbmc.versioncheck/resources/language/Hebrew/strings.po
+++ b/addons/service.xbmc.versioncheck/resources/language/Hebrew/strings.po
@@ -94,7 +94,7 @@ msgstr " -http://kodi.tv  ."
 
 msgctxt "#32034"
 msgid "Using %s while %s is available."
-msgstr " s%  s% ."
+msgstr " %s  %s ."
 
 msgctxt "#32035"
 msgid "It is recommended that you to upgrade to a newer version."
diff --git a/addons/service.xbmc.versioncheck/resources/language/Korean/strings.po b/addons/service.xbmc.versioncheck/resources/language/Korean/strings.po
index bc32baf5a55f..6fb8be9140f8 100644
--- a/addons/service.xbmc.versioncheck/resources/language/Korean/strings.po
+++ b/addons/service.xbmc.versioncheck/resources/language/Korean/strings.po
@@ -94,7 +94,7 @@ msgstr "  http://kodi.tv ."
 
 msgctxt "#32034"
 msgid "Using %s while %s is available."
-msgstr "    %s    % ()   "
+msgstr "    %s    %s ()   "
 
 msgctxt "#32035"
 msgid "It is recommended that you to upgrade to a newer version."
diff --git a/addons/service.xbmc.versioncheck/resources/versions.txt b/addons/service.xbmc.versioncheck/resources/versions.txt
index bf238907638b..163314cb4b72 100644
--- a/addons/service.xbmc.versioncheck/resources/versions.txt
+++ b/addons/service.xbmc.versioncheck/resources/versions.txt
@@ -3,6 +3,51 @@
     "releases": {
         "stable": [
             {
+                "major": "17",
+                "minor": "3",
+                "tag": "stable",
+                "tagversion":"",
+                "revision": "20170524-147cec4",
+                "extrainfo": "final",
+                "addon_support": "yes"
+            },
+            {
+                "major": "17",
+                "minor": "1",
+                "tag": "stable",
+                "tagversion":"",
+                "revision": "20170320-fc1619b",
+                "extrainfo": "final",
+                "addon_support": "yes"
+            },
+            {
+                "major": "17",
+                "minor": "0",
+                "tag": "stable",
+                "tagversion":"",
+                "revision": "20170201-a10c504",
+                "extrainfo": "final",
+                "addon_support": "yes"
+            },
+            {
+                "major": "16",
+                "minor": "1",
+                "tag": "stable",
+                "tagversion":"",
+                "revision": "20160424-c327c53",
+                "extrainfo": "final",
+                "addon_support": "yes"
+            },
+            {
+                "major": "16",
+                "minor": "0",
+                "tag": "stable",
+                "tagversion":"",
+                "revision": "20160220-a5f3a99",
+                "extrainfo": "final",
+                "addon_support": "yes"
+            },
+            {
                 "major": "15",
                 "minor": "2",
                 "tag": "stable",
@@ -149,6 +194,15 @@
         ],
         "releasecandidate": [
             {
+                "major": "17",
+                "minor": "0",
+                "tag": "releasecandidate",
+                "tagversion":"3",
+                "revision": "20170111-4d93228",
+                "extrainfo": "RC3",
+                "addon_support": "yes"
+            },
+            {
                 "major": "16",
                 "minor": "0",
                 "tag": "releasecandidate",
@@ -322,6 +376,14 @@
         ],
         "beta": [
             {
+                "major": "17",
+                "minor": "0",
+                "tag": "beta",
+                "tagversion":"6",
+                "revision": "20161130-654f1b7",
+                "addon_support": "yes"
+            },
+            {
                 "major": "16",
                 "minor": "0",
                 "tag": "beta",
@@ -564,6 +626,22 @@
         ],
         "alpha": [
             {
+                "major": "17",
+                "minor": "0",
+                "tag": "alpha",
+                "tagversion":"2",
+                "revision": "",
+                "addon_support": "yes"
+            },
+            {
+                "major": "17",
+                "minor": "0",
+                "tag": "alpha",
+                "tagversion":"1",
+                "revision": "",
+                "addon_support": "yes"
+            },
+            {
                 "major": "16",
                 "minor": "0",
                 "tag": "alpha",
diff --git a/addons/service.xbmc.versioncheck/service.py b/addons/service.xbmc.versioncheck/service.py
index 7537ff3faf39..7f85bedefe93 100644
--- a/addons/service.xbmc.versioncheck/service.py
+++ b/addons/service.xbmc.versioncheck/service.py
@@ -31,11 +31,16 @@
 ICON         = lib.common.ICON
 oldversion = False
 
+monitor = xbmc.Monitor()
+
 class Main:
     def __init__(self):
         linux = False
         packages = []
-        xbmc.sleep(5000)
+
+        if monitor.waitForAbort(5):
+            sys.exit(0)
+
         if xbmc.getCondVisibility('System.Platform.Linux') and ADDON.getSetting("upgrade_apt") == 'true':
             packages = ['kodi']
             _versionchecklinux(packages)
@@ -62,9 +67,9 @@ def _versionchecklinux(packages):
         handler = False
         result = False
         try:
-            # try aptdeamon first
-            from lib.aptdeamonhandler import AptdeamonHandler
-            handler = AptdeamonHandler()
+            # try aptdaemon first
+            from lib.aptdaemonhandler import AptdaemonHandler
+            handler = AptdaemonHandler()
         except:
             # fallback to shell
             # since we need the user password, ask to check for new version first
@@ -100,5 +105,8 @@ def _versionchecklinux(packages):
 
 
 if (__name__ == "__main__"):
-    log('Version %s started' % ADDONVERSION)
-    Main()
+    if ADDON.getSetting("versioncheck_enable") == "false":
+        log("Disabled")
+    else:
+        log('Version %s started' % ADDONVERSION)
+        Main()

From 87ed4c0d7decfe5a5b6a19ed47bdc38300157c08 Mon Sep 17 00:00:00 2001
From: Rechi <Rechi@users.noreply.github.com>
Date: Tue, 22 Aug 2017 15:53:46 +0200
Subject: [PATCH 19/25] Added Wayland Fix

---
 tools/depends/native/Makefile                 |  5 ++--
 tools/depends/native/python27-native/Makefile | 41 +++++++++++++++++++++++++++
 tools/depends/native/python36-native/Makefile |  2 --
 3 files changed, 44 insertions(+), 4 deletions(-)
 create mode 100644 tools/depends/native/python27-native/Makefile

diff --git a/tools/depends/native/Makefile b/tools/depends/native/Makefile
index 7635f02a20c9..f166b10b69d5 100644
--- a/tools/depends/native/Makefile
+++ b/tools/depends/native/Makefile
@@ -22,7 +22,7 @@ ifeq ($(OS),osx)
 endif
 
 ifeq ($(ENABLE_WAYLAND),yes)
-  NATIVE += expat-native wayland-scanner-native scons-native
+  NATIVE += expat-native wayland-scanner-native python27-native scons-native
 endif
 
 ifeq ($(TARGET_PLATFORM),raspberry-pi)
@@ -43,9 +43,10 @@ swig-native: pcre-native
 distribute-native: python36-native
 distutilscross-native: python36-native distribute-native
 tar-native: xz-native automake-native
+python27-native: zlib-native
 python36-native: zlib-native
 wayland-scanner-native: expat-native
-scons-native: python36-native
+scons-native: python27-native
 
 #liblzo2 has stale packaged automake files that cause borked host/build detection
 liblzo2-native: automake-native
diff --git a/tools/depends/native/python27-native/Makefile b/tools/depends/native/python27-native/Makefile
new file mode 100644
index 000000000000..2df09b497709
--- /dev/null
+++ b/tools/depends/native/python27-native/Makefile
@@ -0,0 +1,41 @@
+include ../../Makefile.include
+PLATFORM=$(NATIVEPLATFORM)
+DEPS= ../../Makefile.include.in Makefile
+
+# lib name, version
+LIBNAME=Python
+VERSION=2.7.13
+SOURCE=$(LIBNAME)-$(VERSION)
+ARCHIVE=$(SOURCE).tar.xz
+CWD=$(shell pwd)
+HOSTPYTHONDIR=$(CWD)/$(PLATFORM)/hostpython
+
+CONFIGURE=./configure --prefix=$(NATIVEPREFIX) --disable-shared --disable-toolbox-glue --disable-framework
+
+LIBDYLIB=$(PLATFORM)/python
+
+all: .installed-$(PLATFORM)
+
+$(TARBALLS_LOCATION)/$(ARCHIVE):
+	cd $(TARBALLS_LOCATION); $(RETRIEVE_TOOL) $(RETRIEVE_TOOL_FLAGS) $(BASE_URL)/$(ARCHIVE)
+
+$(PLATFORM): $(TARBALLS_LOCATION)/$(ARCHIVE) $(DEPS)
+	rm -rf $(PLATFORM)/*; mkdir -p $(PLATFORM)
+	cd $(PLATFORM); $(ARCHIVE_TOOL) $(ARCHIVE_TOOL_FLAGS) $(TARBALLS_LOCATION)/$(ARCHIVE)
+	#cd $(PLATFORM); patch -p0 < ../cpython-2.6.5-multiarch.patch
+	#cd $(PLATFORM); patch -p0 < ../cpython-2.6.5-nosslv2.patch
+	cd $(PLATFORM); $(CONFIGURE)
+
+$(LIBDYLIB): $(PLATFORM)
+	cd $(PLATFORM); $(MAKE)
+
+.installed-$(PLATFORM): $(LIBDYLIB)
+	cd $(PLATFORM); $(MAKE) install
+	install $(PLATFORM)/Parser/pgen $(NATIVEPREFIX)/bin
+	touch $@
+
+clean:
+	rm -rf $(PLATFORM) .installed-$(PLATFORM)
+
+distclean::
+	rm -rf $(PLATFORM) .installed-$(PLATFORM)
diff --git a/tools/depends/native/python36-native/Makefile b/tools/depends/native/python36-native/Makefile
index 60d71f3759ae..c780031608b5 100644
--- a/tools/depends/native/python36-native/Makefile
+++ b/tools/depends/native/python36-native/Makefile
@@ -22,8 +22,6 @@ $(TARBALLS_LOCATION)/$(ARCHIVE):
 $(PLATFORM): $(TARBALLS_LOCATION)/$(ARCHIVE) $(DEPS)
 	rm -rf $(PLATFORM)/*; mkdir -p $(PLATFORM)
 	cd $(PLATFORM); $(ARCHIVE_TOOL) $(ARCHIVE_TOOL_FLAGS) $(TARBALLS_LOCATION)/$(ARCHIVE)
-	#cd $(PLATFORM); patch -p0 < ../cpython-2.6.5-multiarch.patch
-	#cd $(PLATFORM); patch -p0 < ../cpython-2.6.5-nosslv2.patch
 	cd $(PLATFORM); $(CONFIGURE)
 
 $(LIBDYLIB): $(PLATFORM)

From 62a37feaba8622b5a915430030df3998597fee8b Mon Sep 17 00:00:00 2001
From: Rechi <Rechi@users.noreply.github.com>
Date: Tue, 22 Aug 2017 15:53:46 +0200
Subject: [PATCH 20/25] fixup! Charset Conversion From char To wchar_t

---
 xbmc/interfaces/python/XBPython.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/interfaces/python/XBPython.cpp b/xbmc/interfaces/python/XBPython.cpp
index 4cafce84cb90..d6595d066583 100644
--- a/xbmc/interfaces/python/XBPython.cpp
+++ b/xbmc/interfaces/python/XBPython.cpp
@@ -601,7 +601,7 @@ bool XBPython::OnScriptInitialized(ILanguageInvoker *invoker)
       PyEval_AcquireLock();
     else
       PyEval_InitThreads();
-    wchar_t* python_argv[1] = { L"" };
+    wchar_t* python_argv[1] = { const_cast<wchar_t*>(L"") };
     PySys_SetArgv(1, python_argv);
 
     if (!(m_mainThreadState = PyThreadState_Get()))

From e87c14aa7f9c1a142bd47ab7fe7bbfdcff252d70 Mon Sep 17 00:00:00 2001
From: Arpit Nandwani <arpit.nandwani@gmail.com>
Date: Wed, 23 Aug 2017 20:48:33 +0530
Subject: [PATCH 21/25] Added Python Version Varaiable

---
 CMakeLists.txt                      |  2 ++
 cmake/scripts/android/Install.cmake |  2 +-
 tools/android/packaging/Makefile.in | 15 +++++++--------
 3 files changed, 10 insertions(+), 9 deletions(-)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 5bb95ec25964..4e91a08418a4 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -166,6 +166,8 @@ core_optional_dep(${optional_deps})
 core_require_dyload_dep(${required_dyload})
 core_optional_dyload_dep(${dyload_optional})
 
+SET(PYTHON_VERSION 3.6)
+
 if(NOT UDEV_FOUND)
   core_optional_dep(LibUSB)
 endif()
diff --git a/cmake/scripts/android/Install.cmake b/cmake/scripts/android/Install.cmake
index b6d40d8b5947..473d005afd89 100644
--- a/cmake/scripts/android/Install.cmake
+++ b/cmake/scripts/android/Install.cmake
@@ -64,7 +64,7 @@ add_custom_target(bundle
                                                ${CMAKE_BINARY_DIR}/tools/android/packaging/media
     COMMAND ${CMAKE_COMMAND} -E copy_directory ${CMAKE_SOURCE_DIR}/tools/android/packaging/xbmc/res
                                                ${CMAKE_BINARY_DIR}/tools/android/packaging/xbmc/res
-    COMMAND ${CMAKE_COMMAND} -E copy_directory ${DEPENDS_PATH}/lib/python3.6 ${libdir}/python3.6
+    COMMAND ${CMAKE_COMMAND} -E copy_directory ${DEPENDS_PATH}/lib/python${PYTHON_VERSION} ${libdir}/python${PYTHON_VERSION}
     COMMAND ${CMAKE_COMMAND} -E copy_directory ${DEPENDS_PATH}/share/${APP_NAME_LC} ${datadir}/${APP_NAME_LC}
     COMMAND ${CMAKE_COMMAND} -E copy $<TARGET_FILE:${APP_NAME_LC}>
                                      ${libdir}/${APP_NAME_LC}/$<TARGET_FILE_NAME:${APP_NAME_LC}>)
diff --git a/tools/android/packaging/Makefile.in b/tools/android/packaging/Makefile.in
index d688a0e0902a..30051cb7ce5c 100644
--- a/tools/android/packaging/Makefile.in
+++ b/tools/android/packaging/Makefile.in
@@ -6,7 +6,7 @@ OBJS = libcurl.so \
   libbluray.so libsmbclient.so
 
 PLATFORM_OBJS =
-EXCLUDED_ADDONS = 
+EXCLUDED_ADDONS =
 
 CMAKE_SOURCE_DIR = $(shell cd $(CURDIR)/../../..; pwd)
 APP_PACKAGE_DIR = $(subst .,/,@APP_PACKAGE@)
@@ -26,7 +26,7 @@ endif
 X86OVERRIDES=XBMC_OVERRIDE_HOST=i686-android-linux XBMC_OVERRIDE_TOOLCHAIN=$(XBMC_X86_TOOLCHAIN)
 ARMOVERRIDES=XBMC_OVERRIDE_HOST=arm-linux-androideabi XBMC_OVERRIDE_TOOLCHAIN=$(XBMC_ARM_TOOLCHAIN)
 
-#this fixes a android ndk fuckup where the paths to 
+#this fixes a android ndk fuckup where the paths to
 #prebuilt stuff follow different name schemes for
 #arm and x86
 ifeq ($(findstring i686,$(CPU)),i686)
@@ -106,9 +106,9 @@ sharedobb: shared
 	@echo "$(CMAKE_SOURCE_DIR)/main.@APP_NAME_LC@.obb created"
 
 python: | xbmc/assets
-	mkdir -p xbmc/assets/python3.6/lib/
-	cp -rfp $(PREFIX)/lib/python3.6 xbmc/assets/python3.6/lib/
-	cd xbmc/assets/python3.6/lib/python3.6/; rm -rf test config lib-dynload
+	mkdir -p xbmc/assets/python@PYTHON_VERSION@/lib/
+	cp -rfp $(PREFIX)/lib/python@PYTHON_VERSION@ xbmc/assets/python@PYTHON_VERSION@/lib/
+	cd xbmc/assets/python@PYTHON_VERSION@/lib/python@PYTHON_VERSION@/; rm -rf test config lib-dynload
 
 res:
 	mkdir -p xbmc/gen/$(APP_PACKAGE_DIR) xbmc/res xbmc/res/raw xbmc/res/values images
@@ -132,7 +132,7 @@ res:
 
 libs: $(PREFIX)/lib/@APP_NAME_LC@/lib@APP_NAME_LC@.so
 	rm -rf xbmc/lib/$(CPU) xbmc/obj/local/$(CPU)
-	mkdir -p xbmc/lib/$(CPU) xbmc/assets/python3.6/lib/ xbmc/obj/local/$(CPU)
+	mkdir -p xbmc/lib/$(CPU) xbmc/assets/python@PYTHON_VERSION@/lib/ xbmc/obj/local/$(CPU)
 	cp -fpL $(SRCLIBS) xbmc/obj/local/$(CPU)/
 	cp -fp $(PREFIX)/lib/@APP_NAME_LC@/lib@APP_NAME_LC@.so xbmc/obj/local/$(CPU)/
 	find $(PREFIX)/lib/@APP_NAME_LC@/addons -name "*.so" -exec cp -fp {} xbmc/obj/local/$(CPU)/ \; || true
@@ -140,7 +140,7 @@ libs: $(PREFIX)/lib/@APP_NAME_LC@/lib@APP_NAME_LC@.so
 	find $(DEPENDS_PATH)/share/kodi/addons -name "*.so" -exec cp -fp {} xbmc/obj/local/$(CPU)/ \; || true
 	find $(DEPENDS_PATH)/lib/kodi/addons -name "*.so" -exec cp -fp {} xbmc/obj/local/$(CPU)/ \; || true
 	find $(PREFIX)/lib/@APP_NAME_LC@/system -name "*.so" -exec cp -fp {} xbmc/obj/local/$(CPU)/ \;
-	DIR=${CURDIR}; cd $(PREFIX)/lib/python3.6/site-packages; for i in `find Cryptodome -name \*.so` ; do FN=`echo $$i | cut -c1- | tr "/" "_"` ; mv $$i $$DIR/xbmc/obj/local/$(CPU)/$$FN ; done
+	DIR=${CURDIR}; cd $(PREFIX)/lib/python@PYTHON_VERSION@/site-packages; for i in `find Cryptodome -name \*.so` ; do FN=`echo $$i | cut -c1- | tr "/" "_"` ; mv $$i $$DIR/xbmc/obj/local/$(CPU)/$$FN ; done
 	cd xbmc/obj/local/$(CPU)/; find . -name "*.so" -not -name "lib*.so" | sed "s/\.\///" | xargs -I@ mv @ lib@
 	cp -fp xbmc/obj/local/$(CPU)/*.so xbmc/lib/$(CPU)/
 	$(STRIP) --strip-unneeded xbmc/lib/$(CPU)/*.so
@@ -188,4 +188,3 @@ apk-clean:
 	rm -rf assets
 
 .PHONY: force libs assets python sharedapk sharedobb res package
-

From ca285eeede94b6864ce8c9cdbac7b85c42d98ad3 Mon Sep 17 00:00:00 2001
From: wsnipex <wsnipex@a1.net>
Date: Fri, 25 Aug 2017 13:21:58 +0200
Subject: [PATCH 22/25] [depends] build expat-native as PIC

---
 tools/depends/native/expat-native/Makefile | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/tools/depends/native/expat-native/Makefile b/tools/depends/native/expat-native/Makefile
index 707d4f182b1b..b8fe596d9494 100644
--- a/tools/depends/native/expat-native/Makefile
+++ b/tools/depends/native/expat-native/Makefile
@@ -10,7 +10,7 @@ SOURCE=$(LIBNAME)-$(VERSION)
 ARCHIVE=$(SOURCE).tar.bz2
 
 # configuration settings
-CONFIGURE=cp -f $(CONFIG_SUB) $(CONFIG_GUESS) ./conftools; ./configure --prefix=$(PREFIX) --disable-shared
+CONFIGURE=cp -f $(CONFIG_SUB) $(CONFIG_GUESS) ./conftools; CFLAGS="-fPIC" ./configure --prefix=$(PREFIX) --disable-shared
 
 LIBDYLIB=$(PLATFORM)/.libs/lib$(LIBNAME).a
 

From 6ff2a39ee994b7808e44081364e9e6e2dade1584 Mon Sep 17 00:00:00 2001
From: wsnipex <wsnipex@a1.net>
Date: Fri, 25 Aug 2017 13:26:15 +0200
Subject: [PATCH 23/25] [depends] python3-native: use system expat when
 available

fixes native python on wayland
---
 tools/depends/native/Makefile                 | 3 ++-
 tools/depends/native/python36-native/Makefile | 4 ++++
 2 files changed, 6 insertions(+), 1 deletion(-)

diff --git a/tools/depends/native/Makefile b/tools/depends/native/Makefile
index f166b10b69d5..52dd0bf35a2b 100644
--- a/tools/depends/native/Makefile
+++ b/tools/depends/native/Makefile
@@ -23,6 +23,7 @@ endif
 
 ifeq ($(ENABLE_WAYLAND),yes)
   NATIVE += expat-native wayland-scanner-native python27-native scons-native
+  EXPAT = expat-native
 endif
 
 ifeq ($(TARGET_PLATFORM),raspberry-pi)
@@ -44,7 +45,7 @@ distribute-native: python36-native
 distutilscross-native: python36-native distribute-native
 tar-native: xz-native automake-native
 python27-native: zlib-native
-python36-native: zlib-native
+python36-native: zlib-native $(EXPAT)
 wayland-scanner-native: expat-native
 scons-native: python27-native
 
diff --git a/tools/depends/native/python36-native/Makefile b/tools/depends/native/python36-native/Makefile
index c780031608b5..27ee76763a72 100644
--- a/tools/depends/native/python36-native/Makefile
+++ b/tools/depends/native/python36-native/Makefile
@@ -11,6 +11,10 @@ CWD=$(shell pwd)
 HOSTPYTHONDIR=$(CWD)/$(PLATFORM)/hostpython
 
 CONFIGURE=./configure --prefix=$(NATIVEPREFIX) --disable-shared --disable-framework --without-pymalloc
+ifeq ($(ENABLE_WAYLAND),yes)
+  CONFIGURE += --with-system-expat
+endif
+
 
 LIBDYLIB=$(PLATFORM)/python
 

From 5ae17fa9f2fa3fbc3739a734c024dca2a3c88397 Mon Sep 17 00:00:00 2001
From: wsnipex <wsnipex@a1.net>
Date: Fri, 25 Aug 2017 13:36:11 +0200
Subject: [PATCH 24/25] [depends] python2-native: use system expat when
 available

---
 tools/depends/native/Makefile                 | 2 +-
 tools/depends/native/python27-native/Makefile | 4 ++++
 2 files changed, 5 insertions(+), 1 deletion(-)

diff --git a/tools/depends/native/Makefile b/tools/depends/native/Makefile
index 52dd0bf35a2b..ec72bf3a713b 100644
--- a/tools/depends/native/Makefile
+++ b/tools/depends/native/Makefile
@@ -44,7 +44,7 @@ swig-native: pcre-native
 distribute-native: python36-native
 distutilscross-native: python36-native distribute-native
 tar-native: xz-native automake-native
-python27-native: zlib-native
+python27-native: zlib-native $(EXPAT)
 python36-native: zlib-native $(EXPAT)
 wayland-scanner-native: expat-native
 scons-native: python27-native
diff --git a/tools/depends/native/python27-native/Makefile b/tools/depends/native/python27-native/Makefile
index 2df09b497709..ffac84bdfaba 100644
--- a/tools/depends/native/python27-native/Makefile
+++ b/tools/depends/native/python27-native/Makefile
@@ -11,6 +11,10 @@ CWD=$(shell pwd)
 HOSTPYTHONDIR=$(CWD)/$(PLATFORM)/hostpython
 
 CONFIGURE=./configure --prefix=$(NATIVEPREFIX) --disable-shared --disable-toolbox-glue --disable-framework
+ifeq ($(ENABLE_WAYLAND),yes)
+  CONFIGURE += --with-system-expat
+endif
+
 
 LIBDYLIB=$(PLATFORM)/python
 

From a029e74264ad0067fb4e1d1353468a38cab2e31e Mon Sep 17 00:00:00 2001
From: Rechi <Rechi@users.noreply.github.com>
Date: Sun, 27 Aug 2017 11:33:54 +0200
Subject: [PATCH 25/25] [depends][python3] enable blake2 module

---
 tools/depends/target/python36/Makefile      | 3 +++
 tools/depends/target/python36/modules.setup | 2 +-
 2 files changed, 4 insertions(+), 1 deletion(-)

diff --git a/tools/depends/target/python36/Makefile b/tools/depends/target/python36/Makefile
index ee4b8ca42d8b..71a3109fca49 100644
--- a/tools/depends/target/python36/Makefile
+++ b/tools/depends/target/python36/Makefile
@@ -64,6 +64,9 @@ endif
 	cd $(PLATFORM); $(CONFIGURE)
 
 $(LIBDYLIB): $(PLATFORM)
+	# Hack to fix a circular dependency issue in pythons Makefile
+	# only occurs if _blake2 module is enabled
+	$(MAKE) -C $(PLATFORM) $(HOSTPLATFORM) PYTHON_FOR_BUILD=$(NATIVEPREFIX)/bin/python3 NATIVE_PGEN=$(NATIVEPREFIX)/bin/pgen CROSS_COMPILE_TARGET=yes clinic
 	$(MAKE) -C $(PLATFORM) $(HOSTPLATFORM) PYTHON_FOR_BUILD=$(NATIVEPREFIX)/bin/python3 NATIVE_PGEN=$(NATIVEPREFIX)/bin/pgen CROSS_COMPILE_TARGET=yes libpython3.6.a
 	touch $@
 
diff --git a/tools/depends/target/python36/modules.setup b/tools/depends/target/python36/modules.setup
index 5b08e67a4856..8dceb740d428 100644
--- a/tools/depends/target/python36/modules.setup
+++ b/tools/depends/target/python36/modules.setup
@@ -256,7 +256,7 @@ _sha256 sha256module.c
 _sha512 sha512module.c
 
 # _blake module
-#_blake2 _blake2/blake2module.c _blake2/blake2b_impl.c _blake2/blake2s_impl.c
+_blake2 _blake2/blake2module.c _blake2/blake2b_impl.c _blake2/blake2s_impl.c
 
 # The _tkinter module.
 #
